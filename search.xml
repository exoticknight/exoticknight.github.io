<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[5 分钟速成古埃及神明]]></title>
    <url>%2Flearn-ancient-egyptian-gods-in-5-minutes%2F</url>
    <content type="text"><![CDATA[古埃及的宗教是多神教，他们认为自然现象、客观事物甚至动物，都存在神明。在新王国时期法老阿肯那顿将阿顿作为唯一神，古埃及曾短暂地存在一神教时期。这部分详细可以阅读30 分钟速成古埃及历史。 三千年的存在时间和政权的多次更迭造成古埃及神明种类繁多，系统复杂，甚至可能互相矛盾，但总的来说有三个神话系统。 九柱神九柱神是古埃及宗教中一般都采用的神话系统。 拉（Ra）太阳神，埃及神话中的最高神。生舒和泰芙努特。九柱神之一。 舒（Shu）风神，拉的儿子，与泰芙努特生盖布和努特。九柱神之一。 泰芙努特（Tefnut）雨神，拉的女儿，舒的妻子。九柱神之一。 盖布（Geb）大地之神，与努特生欧西里斯、赛特、艾西斯、奈芙蒂斯。九柱神之一。 努特（Nut）天神，盖布的妻子。九柱神之一。 奥西里斯（Osiris）冥王，也是农业之神。九柱神之一。 伊西斯（Isis）死者的守护神，也是生育之神，奥西里斯的妻子。九柱神之一。 赛特（Seth）干旱之神，风暴之神。有时也被认为是战神。九柱神之一。 奈芙蒂斯（Nephthys）死者的守护神，赛特的妻子。九柱神之一。 阿努比斯（Anubis）赛特和奈芙蒂斯，负责制作木乃伊和评判死去的人该不该永生。 荷鲁斯（Horus）奥西里斯和伊西斯的儿子，一般是代表法老的权威。 哈索尔（Hathor）爱神、美神，荷鲁斯妻子。 荷鲁斯的四个儿子为木乃伊保存四个内脏。伊姆塞特保护肝脏，哈庇保护肺，杜阿木忒弗保护胃，克贝克塞努弗保护肠。 神明之间的关系拉是众神之始，生出舒和泰芙努特。 舒与泰芙努特生盖布和努特。 盖布在下为地，努特在上为天，舒在中间撑着。 盖布与努特生奥西里斯、赛特、伊西斯、奈芙蒂斯。奥西里斯和伊西斯成夫妻，赛特和奈芙蒂斯成夫妻。 赛特嫉妒哥哥奥西里斯，举办了一个宴会，做一个刚好哥哥能躺进去的棺材，让别人躺进去试试。奥西里斯躺进去就封上扔进尼罗河溺死他。 伊西斯和奈芙蒂斯找回尸体复活，但赛特又一次杀死了奥西里斯并分尸十四块，藏在世界各地。伊西斯找了很久，除了下体凑足了尸体，负责做木乃伊的阿努比斯帮助她复活奥西里斯。伊西斯之后生下荷鲁斯，然后奥西里斯成了冥界之主。有些文献说是因为他的下体被鱼吃了，伊西斯使用木头代替导致复活不完全。 奥西里斯的经典造型是绿脸，双手握权杖交叉胸前，经常出现在法老为自己建造的陵墓门口。 荷鲁斯被秘密抚养长大之后，向赛特复仇并打败了他，过程中扯下了他的一颗睾丸，自己则失去一只眼睛。那只眼睛就被视为著名的「荷鲁斯之眼」。 八元神八元神其实是四对分雌雄的神。关于八元神的故事并不多。 代表自然水，纳乌涅特（Naunet）和 努恩（Nu）、代表空气或隐蔽或虚无，阿玛乌涅特（Amaunet）和 阿蒙（Amun）、代表黑暗，卡乌凯特（Kauket）和 库克（Kuk）、代表永恒或无限空间，哈乌赫特（Hauhet）和 胡（Huh）。 在这个体系中，拉是在四对神的相互作用下诞生的。 底比斯诸神底比斯经常作为古埃及的首都，其当地的神话和神明在古埃及宗教上占有很重的地位，甚至排挤其他神明的地位。 阿蒙（Amun）本身只是地方神祇，但是十八王朝开始随着王室的崇拜和古埃及版图扩张而逐渐成为到了主神的地步。 有时又会和拉结合，成为众神之王。 姆特（Mut）阿蒙之妻，生下孔斯，一起成为底比斯三柱神。 孔斯（Khonsu）阿蒙和姆特之子，一代月神。 麦里特塞盖尔（Meretseger）不是太重要的神，负责守卫帝王谷。 托特（Thoth）智慧之神。二代月神同时也是数学、医药之神，负责守护文艺和书记的工作。相传他是古埃及文字的发明者。 参考资料Egyptian mythologyEnneadOgdoad_(Egyptian))埃及神话九柱神八元神埃及旅遊｜一起認識複雜的埃及神祇吧！九柱神與重要神祇們古埃及主要神話體系簡介]]></content>
      <categories>
        <category>知识</category>
        <category>古埃及</category>
      </categories>
      <tags>
        <tag>ancient-egypt</tag>
        <tag>god</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30 分钟速成古埃及历史]]></title>
    <url>%2Flearn-ancient-egyptian-history-in-30-minutes%2F</url>
    <content type="text"><![CDATA[前几天在 bilibili 上看了一个 up 主的埃及旅游系列 vlog，了解了一些关于古埃及历史的知识，再通过维基什么学习，写下本文以做笔记。 本文基本来源中英文维基，英文为主中文为辅，精简了大量不太重要的细节，比较适合快速了解和学习古埃及历史。如果对内容有什么疑问或者质疑，请务必留下评论或者联系我做讨论。 综述时间上只会覆盖到中世纪之前，个人认为古埃及在阿拉伯人入侵之后就算是玩完了，所以之后的时期不做记录。 首先，整个古埃及基本就是沿着尼罗河建立的。尼罗河的走向是自南向北，古埃及也经常因为统治的原因，一段时期分成上埃及和下埃及，一段时期则是统一，正所谓分久必合，合久必分。上埃及是在南边即上游，而下埃及则是在北边即下游。 埃及学者一般根据托勒密王朝早期古埃及祭祀曼涅托的《埃及史》将古埃及历史分成八到九个时期，三十一个王朝（一个王朝不一定只有一位法老），而古埃及人则似乎是不划分历史时期的。另外考古出来的历史也各国不一，这里以维基为准。 这几个时期分别是前王朝时期、早王朝时期、古王国时期、第一中间期、中王国时期、第二中间期、新王国时期、第三中间期和古埃及后期。实际并不需要将所有的时期都记得一清二楚，只需要记得一些时期和王朝比较有名的事件和法老即可。 另外古埃及到了第三中间期之后的后期，已经无力回天，被外族来回入侵，再之后又来了马其顿和罗马，最后被阿拉伯完全控制后到现在基本就已经是一个穆斯林国家了。 古埃及年表在时间上的认定也不一，相差会有几十年，不过其开始一般都在 BC（before century，公元前）3100 左右。 点击图片查看清晰大图 前王朝时期（BC3100 之前）经历了旧石器时代和新石器时代，大概 BC3600 年开始，尼罗河沿岸出现几十个「诺姆」，相互各自斗争。 诺姆：nome，源自希腊语 Νομός，意为 “行政区”；埃及语：Gau，中译「州」。 早王朝时期（Early dynastic period, BC3100 - BC2686）第一王朝建立者，美尼斯传说中美尼斯（Menes）统一了上下埃及开创古埃及王朝。但从考古证据上则很难支持有这么一个人，反而认为是纳尔迈（Narmer）才是统一埃及第一人，或者说两者是同一个。 包含一至二王朝，两个王朝，2 / 31。 古王国时期（Old Kingdom, BC2686 - BC2181）第一个建造金字塔，左塞王现在看到的著名金字塔基本就在这个时期被建造。 此时期第一个法老（pharaoh）左塞王（King Djoser）开始建造阶梯金字塔（最常见最有名那种），位置在萨卡拉（开罗以南约 30 公里）。 阶梯金字塔据说是是伊姆霍特普（Imhotep）设计的。 伊姆霍特普，出身平民，但因智慧过人，学识渊博，受到法老的破格重用。他在整个法老时代受到崇拜，死后被尊为神，名号被刻在法老左塞雕像的基座上。…… 古埃及医学的奠基人…… 被誉为历史上第一位留下姓名的建筑师与医师，被奉为医学之神维基百科 甚至有伊姆霍特普博物馆，见 维基，egyptsites 博客。 最大的金字塔，胡夫金字塔胡夫是第四王朝的第二位法老，是首位在吉萨建造金字塔的法老。今天去埃及旅游看的三座大金字塔就在吉萨，其中最大的就是胡夫下令修建。 胡夫金字塔塔高大概 146.5 米，现为大概 137 米，边长接近 230 米，由 230 万块巨石搭建而成，最重的可达 50 吨，最小的也有 1.5 吨。 胡夫金字塔是古代世界七大奇迹中最为古老和唯一尚存的建筑物。 有一个入口，但是现在被封禁，只使用某位哈里发在 CE820 开凿的盗墓通道作为入口。 尽管建造了最大的金字塔，但胡夫本人的雕像却是考古发掘中所有法老雕像中最小的。 第二大金字塔，卡夫拉金字塔卡夫拉是胡夫的孙子。尽管看起来卡夫拉金字塔比胡夫金字塔小一点，但是卡夫拉金字塔底座更高了 10 米，塔周边也更多附属设施。 狮身人面像斯芬克斯就属于附近的建筑，但并不是问路人问题杀人那只。 孟卡拉金字塔孟卡拉是第四王朝时期的第 16 位法老，孟卡拉金字塔远小于前两座金字塔，它的高度只有大约 65 米，总体积大约只有卡夫拉金字塔 1/10。 萨拉丁的儿子奥斯曼曾试图拆除孟卡拉金字塔，最后太过困难而作罢，给金字塔北面留下很大的垂直裂缝。 包含三至六王朝，四个王朝，6 / 31。 第一中间期（First Intermediate Period, BC2181 - BC2055）古王国时期后期出现严重干旱，国力下降，封建制度也削弱了中央权利，出现第一个黑暗时期，极其混乱的一个时期。这个时期法老权力被极度削弱，地方官员权利变大，在自己领地几乎就成了法老。 七八王朝极度混乱，史书记录不清。 曼图霍特普二世（Mentuhotep II）重新统一古埃及也分成了上下埃及，下埃及经历九十两个王朝，上埃及则是十和十一王朝。最终上埃及由曼图霍特普二世（Mentuhotep II）向北进攻击败下埃及统治者再次统一古埃及，并继续主持十一王朝，进入中王国时期。 经历大概第七王朝到第十王朝，四个王朝，10 / 31。 中王国时期（Middle Kingdom, BC2030 - BC1650）十一王朝再次统一之后，开始重新收复失地，包括南边曾经在古王国和中间时期失落给努比亚的土地。 努比亚相当于今天埃及和苏丹交界位置。 十二王朝迁都底比斯（今卢克索）。 塞索斯特利斯三世（Sesostris III）扩张到努比亚塞索斯特利斯三世（Sesostris III）是十二王朝法老，善战，向努比亚扩张，然后还建造了很多堡垒，被认为是这个王朝最强大的法老。 之后他的儿子阿蒙涅姆赫特三世（Amenemhat III）的统治时期被认为是中王国时期经济最好的时期。不过他从西亚邀请了希克索人（Hyksos）到尼罗河下游三角洲定居，也给后面十三十四王朝的结束埋下了隐患。其实十二王朝末期尼罗河洪水减少也为国家带来打击。 第一位可考的女法老，塞贝克涅弗鲁（Sobekneferu）阿蒙涅姆赫特四世（Amenemhat IV）去世后，其子年幼，于是其姐妹塞贝克涅弗鲁（Sobekneferu）成为了历史考证上第一位女法老。她在位三年后去世，政权持续衰弱，是十二王朝最后的法老。 奥西里斯在这个时期成为了最重要的神。 经历十一王朝到十三王朝，三个王朝，13 / 31。 第二中间期（Second Intermediate Period, BC1650 - BC1550）十三王朝的继续衰弱导致尼罗河三角洲（属于下埃及）的政权脱离并独立，是为十四王朝。统治者可能是迦南人（闪米特人）血统。 注意十三王朝和十四王朝几乎是共存的，直到 BC1650 希克索人全面控制下埃及，攻占了古首都孟菲斯。 希克索人的外族统治希克索人对下埃及的统治被视为十五王朝，而南边的底比斯统治者也趁十三王朝的真空宣布独立并宣布十六王朝。 希克索人继续南下把十六王朝打败后，北退，上埃及建立十七王朝与希克索共存。 十七王朝学习希克索人的战术和武器，在十七王朝最后两个法老统治期间反攻北面希克索人。 阿赫摩斯一世（Ahmose I）是十七王朝最后一个法老的弟弟，继续父亲和兄长意志将希克索人赶出埃及，开创十八王朝，进入新王国时期。 包含十四王朝到十七王朝，共四个王朝，17 / 31。 新王国时期（New Kingdom, BC1570 － BC1070）这个时期有很多有名的法老。宗教上也有不少的变动。 在神明崇拜上，由于此时统一埃及十七王朝的统治者就是底比斯的家族，所以底比斯的地方神祇阿蒙（Amun）被推举到了主神的地位。由于古埃及一直以来一般都认为主神是太阳神拉（Ra），所以这段时期又经常将阿蒙和拉结合为同一个神，叫阿蒙-拉。 古埃及历史上最强盛的十八王朝就在这个时期内。 阿赫摩斯一世（Ahmose I）赶走外族，统一上下埃及十八王朝第一任法老阿赫摩斯一世（Ahmose I），他登基的时候可能只有十岁，并可能在二十岁左右完成了「驱逐胡虏」，恢复了埃及对努比亚的统治。 之后是阿赫摩斯一世的儿子阿蒙霍特普一世（Amenhotep I）继位。 接下来的法老图特摩斯一世（Thutmose I）的身世则有点模糊，有可能是阿蒙霍特普一世的儿子，或者是他的军队指挥官。他意图扩大埃及版图，并第一个在帝王谷建造坟墓。 图特摩斯一世儿女中有一个儿子，图特摩斯二世（Thutmose II），是由妃子所生；其中有一个女儿，哈特谢普苏特（Hatshepsut），是由王后所生。 王后没有儿子，于是图特摩斯二世娶了他的姐姐哈特谢普苏特并登上王位，但很快就死了，而哈特谢普苏特只生了一个女儿，所以又从图特摩斯二世的妃子中找了个儿子当图特摩斯三世（Thutmose III）。 古埃及的「武则天」，哈特谢普苏特或许是因为图特摩斯三世太幼小，又或者是因为哈特谢普苏特觉得自己是正统王室之后，因此虽然作为摄政王，但是肯定是想自己当甚至极有可能当上了法老。而且考古学者从资料和建筑中考据，亦基本承认了她法老的地位（同时图特摩斯三世仍然在位）。 哈特谢普苏特在位期间的贡献主要为重新建立被希克索人入侵时破坏的贸易路线，以及大兴土木建造了很多建筑。她停止了土地扩张，使埃及在叙利亚及巴勒斯坦的统治权动摇（死后更丢失了统治权，但后来图特摩斯三世重新收复），但加强了和邻国的贸易，使埃及变得富庶。 她在卡纳克神庙建造了两个方尖碑，其中之一是埃及现存方尖碑中最高的，约 29 米高。 她在曼图霍特普二世神庙旁建造的哈特谢普苏特神庙，是古埃及建筑杰作以及热门景区。 经历王女、王后、摄政王和法老，哈特谢普苏特让人联想起中国的「武则天」。 埃及的拿破仑，图特摩斯三世图特摩斯三世在哈特谢普苏特统治二十一到二十二年后重新归来，并积极扩充军队和埃及版图，征服了地中海沿岸的以色列和叙利亚地区，甚至让邻国给其纳贡。图特摩斯三世也被后人称为「埃及的拿破仑」。 图特摩斯三世重获权力后，通过破坏纪念碑等方式极力抹除哈特谢普苏特的存在。后面的王朝在王表编纂上也似乎故意忽略了这个法老。 哈特谢普苏特和图特摩斯三世之间的关系，一般认为图特摩斯三世怨恨哈特谢普苏特。但最近一些研究进展称此说法不准确，并声称图特摩斯三世一直担当哈特谢普苏特的军事统治领袖，哈特谢普苏特也没有取其性命；而且损毁行动在图特摩斯三世统治晚期集中进行，哈特谢普苏特的资料也不是唯一被损毁的资料；从而推测图特摩斯三世是为了巩固继承人地位而作出如此的行为，他本人和他的继母并没有过节。这部分说法维基暂时没有找到证据支持。 埃及在图特摩斯三世以及几位法老的努力下，终于在阿蒙霍特普三世（Amenhotep III）治下达到艺术和国力顶峰。阿蒙霍特普三世一生建造了很多宏伟的建筑和雕像，其中有著名的门农巨像。门农巨像座落在是蒙霍特普三世神庙的门口守卫。而阿蒙霍特普三世神庙是埃及最大最华丽的建筑群，可是后来因为地震和被拆除的缘故，现在已经不存在了，剩下两尊残破的门农巨像。 帝国的强盛、对阿蒙神的崇拜和皇家经常修建神殿，令阿蒙神庙的祭司获得极大的财富和权力，祭司们不免出现腐败和干预朝政的行为。 被后继者视为异端的宗教改革者，阿蒙霍特普四世于是阿蒙霍特普三世的儿子，阿蒙霍特普四世，相信是为了打击祭司和权贵，进行了宗教改革。他简化多神系统，要求全国改为崇拜唯一的太阳神阿顿（Aten），甚至把自己的名字改为阿肯那顿（Akhenaten），迁都埃赫塔顿（Akhetaten），摧毁阿蒙神庙。有学者认为这表明了他创造了世界上最早的一神教。但他沉迷新兴宗教事务，以至于对边疆情况置若罔闻，而此时地中海北面的赫梯人正值盛时。于是古埃及逐渐失去了西亚地区的影响力。 他的大皇后，娜芙蒂蒂（Nefertiti），很有可能和他一同统治埃及。 阿肯那顿的后继者在他死后又把旧宗教恢复回来，并大力抹消新兴宗教的记录和影响。 生前不出名，死后却最出名的法老，图坦卡蒙阿肯那顿之后经过了一个或者两个短暂统治的法老（可能是他儿子或者王后摄政），王位传到了最著名的法老——图坦卡蒙（Tutankhamun）。 图坦卡蒙曾用名图坦卡顿（Tutankhaten），从名字的更改可以看出信仰的更改。他将首都迁回底比斯，重开神庙，重新恢复阿蒙神的崇拜。 图坦卡蒙的出名是因为所有法老的坟墓都几乎被盗空了，而唯有他在帝王谷的坟墓三千多年来从没被盗，以至于发掘出近五千件文物，令法老以及图坦卡蒙成为流行文化。 关于有名的「法老的诅咒」，可以说没有任何证据表明诅咒存在，坟墓内也没有发现任何诅咒的存在。打开坟墓和棺材的在场 58 人，据研究只有 8 - 10 人在十几年内死亡，根本不足为诅咒的依据。 2019 年（本年） 1 月，图坦卡蒙坟墓向游客开放。 混乱的最后几任十八王朝法老然而图坦卡蒙似乎一直疾病缠身，18 岁就死了，死因有各种猜测，包括疟疾、腿疾或者被谋杀。他与其异母姐姐安克姗海娜曼的两个女儿也早年夭折，因此图特摩斯家族就绝后了。安克姗海娜曼似乎曾经写信给赫梯国王苏庇路里乌玛一世要求他要一个王子嫁给她，但是王子还没到就被杀了。 之后是阿肯那顿和图坦卡蒙大臣，甚至可能是其背后的操纵者，阿伊（Ay），极有可能娶了安克姗海娜曼，当上了法老，统治了一个很短暂的时期。之后就被图坦卡蒙的将军，霍朗赫布（又或者哈伦海布，Horemheb）夺取了法老位置。 霍朗赫布以孟菲斯为首都，继续抹除阿顿以及其前任等人的痕迹，算是个解决宗教动荡和国家分裂等麻烦的人。 霍朗赫布跟王室没有关系，也没有儿子，法老位置传给了当时的大臣门帕提拉（原名普拉美斯，Paramesse），即十九王朝的第一任法老拉美西斯一世（Ramesses I）。 被儿子盖住名声的塞提一世拉美西斯一世的儿子塞提一世（Seti I）和她父亲重建了王国的秩序，并在叙利亚和迦南地区打击赫梯人的势力。从纪念碑上可以找到他的伟大功绩，虽然一般来说都是倾向于夸大。总的来说，塞提一世可以说是恢复新王国时期的荣光。 塞提一世也兴建了很多建筑，包括位于底比斯的塞提一世祭庙、位于阿拜多斯的塞提一世纪念庙以及大柱式大厅，虽然大部分应该是在拉美西斯二世时期完成的。 阿拜多斯的塞提一世纪念庙虽然外表其貌不扬，但是内部壁画精美，而且有不少壁画仍然有颜色。其中一面墙上按时间顺序记录了大多数王朝的法老的名字，从美尼斯到塞提一世共 76 个，被称为阿拜多斯王表，是后世研究历史的主要来源之一。 鼎鼎大名的拉美西斯二世塞提一世的儿子就是赫赫有名的拉美西斯二世（Ramesses II）了。他如此的有名以至于后来有九位法老使用了拉美西斯这名字。他在位长达 66 到 67 年，执政的时期是新王国最后的强盛年代。 但凡古埃及强盛的时期，统治的法老无不是领土争端和宏伟建筑这两方面有所建树，拉美西斯二世也不例外。他打败从地中海入侵的海盗，向东北占领迦南地区和南叙利亚地区，和北面的强敌赫梯国王穆瓦塔利二世（Muwatalli II）来回地打拉锯战，最后分庭抗礼；稳定南边的努比亚。他在位时间比较长，也在埃及各地建造非常多的建筑，甚至在不是他建造的建筑上也留下标志。 卡迭石战役是埃及和赫梯之间比较著名的战役。战役的情况很可能是这样：埃及想进军占领卡迭石，但被赫梯战车袭击并击溃；法老在营地受困的时候雇佣兵到了，反击了赫梯，导致赫梯军败退；埃及虽然赢了这场战斗但是也无法攻克卡迭石，战略上算是输了。之后双方一直僵持不下。卡迭石战役有非常详细的记录，但基本都是埃及方面一面之词，因此也存在夸大拉美西斯二世的可能性。 之后穆瓦塔利二世病逝，拉美西斯二世和继位的哈图西里三世（Hattusili III）缔结埃及赫梯和约，此时距离卡迭石战役已经十五六年了。 埃及赫梯和平条约，或称卡迭石条约、永恒条约、银条约，是古代近东（即今西亚、中东地区）地区协议双方都有保存下来的最古老的条约。缔结和约结束了长期的冷战实际上对签署双方都有利益。埃及的目的，很可能是为了吹嘘法老功绩，并成立军事同盟以共同对抗西亚更东边的新贵力量亚述；而赫梯的目的，则可能是新王为了巩固地位以及利用法老的国际影响力提升自己的国际地位。 拉美西斯二世的闻名也许也来自于他遍布埃及的大型建筑和到处刻画自己的荣光事迹。 比较有名的建筑是拉美西姆神庙、哈布城神庙和阿布辛贝勒神庙。 拉美西姆神庙现今已经是废墟，往日的样子只能靠门口和后面的建筑来想像了。 比较值得注意的是庙内有一副拉美西姆国王名单（Ramesseum king list），列出了新王朝的大部分法老。 哈布城神庙（Medinet Habu）离哈特谢普苏特神庙不远，很多法老都在这修建过建筑，刻过壁画。然而拉美西斯二世应该是其中最张扬的了，似乎很害怕被人遗忘。 拉美西斯二世本身就喜欢乱改别人的壁画，因此他也害怕别人抹掉他的壁画，于是他的壁画都刻得非常深。 阿布辛贝勒神庙（Abu Simbel temples）应该是很多人从电视媒体等看到过的神庙之一，整个神庙在岩石上开凿而成，门口四个雕像也是其标志之一。 神庙东北面是法老为哈索尔（Hathor，古埃及女神）和妮菲塔莉（Nefertari，拉美西斯二世的大王后）所建的小庙（the Small Temple）。妮菲塔莉的雕像跟拉美西斯二世一样高，表明地位跟他几乎平起平坐，也是几乎唯一一位在世就被神格化的埃及王后。其他同样有名的王后是克利奥帕特拉七世（埃及艳后）、娜芙蒂蒂（阿肯那顿的大王后）和哈特谢普苏特（埃及「武则天」）。 近代由于在阿斯旺兴建水坝，联合国筹钱将阿布辛贝勒神庙和小庙搬离到比原地高 200 米处。 频繁的战争、大兴土木，造就了巨大的国库开销，加大了国力下降。在拉美西斯二世死后，埃及就立刻开始走下坡路。 第二十王朝的祭司当权过了几任法老后，到了第二十王朝第二任法老拉美西斯三世的统治。他抵抗了几次地中海和利比亚的入侵，治下还出现了人类历史上第一次有记录的劳工罢工。他的一个妃子还曾试图毒杀他，最后是失败了。 拉美西斯五世，土地和财政基本就已经被阿蒙神庙的祭司所控制了。 拉美西斯六世在建造坟墓时无意间将图坦卡蒙坟墓埋在了地下，避免了其日后被盗掘。 第二十王朝，古埃及陷入内忧外患，尼罗河水位下降、内政动乱、法老坟墓被盗、官员腐败，又丢了叙利亚和巴勒斯坦，最后法老基本就没有统一埃及的权力了。 包含十八王朝到二十王朝，共三个王朝，20 / 31。 第三中间期（3rd Intermediate Period, BC1069 - BC664）拉美西斯十一世死后，结束二十王朝，斯门代斯一世（Smendes I）开创二十一王朝，然而此时法老权力已经极弱，基本被赶到下埃及去了，上埃及和中埃及地区则是由底比斯阿蒙神庙的大祭司们所控制。 利比亚人的二十二、二十三、二十四王朝之前二十王朝已经在尼罗河三角洲定居的利比亚人，在舍顺克一世（Shoshenq I）统领下统一埃及，创立二十二王朝，这里的法老已经不是本土埃及人了。然后二十三王朝二十四王朝，王室和内政仍然比较动荡，南方起源于库施（kush）的努比亚王国趁乱北上把整个埃及打了下来，赶走了利比亚人，建立二十五王朝。 努比亚人的二十五王朝努比亚人重新恢复了古埃及的的宗教传统，修复和建造了不少寺庙和纪念碑，还在家乡（位于现在的苏丹）重新建造起金字塔来。 包含二十一王朝到二十五王朝，共五个王朝，25 / 31。 古埃及晚期 / 波斯帝国时期（Late Period, BC664 - BC332）之后西亚的亚述人开始入侵古埃及，努比亚人不敌，向南退回努比亚。亚述人可能对占着古埃及没有兴趣，在洗劫一番后退了回去，扶植了普萨美提克一世（Psammetichus I）作为法老。 古埃及本土最后的荣光，二十六王朝之后，普萨美提克一世趁亚述帝国忙于战乱，联合古希腊的雇佣军，又重新统一了古埃及，建立二十六王朝，恢复了繁荣稳定。之后亚述被内部独立的新巴比伦帝国推翻，普萨美提克一世也曾想恢复西亚的霸权，但被尼布甲尼撒二世（Nebuchadnezzar II）统治的新巴比伦帝国打了回来。 那个古埃及法老用婴儿做实验，实验听不到别人说话怎么学语言的故事，就是普萨美提克一世的故事，记录在希罗多德写的书「历史」第二卷中。 然而二十六王朝已经是最后一个埃及本土王朝了。更东边的波斯阿契美尼德帝国（波斯第一帝国）灭了新巴比伦帝国，接着吞并了古埃及，波斯国王冈比西斯二世（Cambyses II）成了法老，称为二十七王朝。 之后二十六王朝后裔推翻波斯的统治，先后建立短暂的二十八、二十九、三十王朝。 然后波斯人再次征服古埃及，是为三十一王朝。 包含二十六王朝到三十一王朝，共六个王朝，31 / 31。 马其顿的亚历山大解放埃及 -&gt; 托勒密王朝（Macedonian and Ptolemaic Egypt, BC332 - BC30）埃及解放者，亚历山大当无人不知的亚历山大击溃波斯大军并来到埃及的时候，根本没有遇到什么抵抗，埃及当地的波斯管理者就直接将埃及献给他了，埃及人民还视其为埃及的解放者。 亚历山大尊重当地信仰，去绿洲朝圣得到神谕。神谕宣称他是阿蒙的儿子。实际上就是得到了祭司等有权势的人的承认。他成立了一个新的希腊城市名为亚历山大（他到哪就在哪建亚历山大城），并任命希腊人——而不是埃及人——作为高官。 亚历山大没有在埃及待很久，就去征服其他地方了，从此再没有回来过。他的部下托勒密留在埃及统治，并从亚历山大死后分崩离析的亚历山大帝国中独立出来，创立托勒密王朝统治了近三百年。 希腊法老，托勒密王朝托勒密王朝中，男性都叫托勒密（Ptolemy），女性一般叫克利奥帕特拉（Cleopatra）、贝勒尼基（Berenice）和阿尔西诺伊（Arsinoe），因此所有统治者都是这四个名字的加几世这样的称呼。最为人知的就是末代法老，埃及艳后，克利奥帕特拉七世。 托勒密王朝没有使用希腊文明取代埃及文明，反而扶持其延续，修建埃及风格的神庙，维护传统宗教仪式。当然也带来了希腊文明的影响，这个时期很多文艺作品都有两个文明融合的风格。 罗塞塔石碑，托勒密五世诏书罗塞塔石碑本来并不是什么比较特别的石碑，只是托勒密五世加冕一周内纪念所制，但碑上同时使用了三种语言，分别是圣书体（埃及象形文字）、埃及草书（世俗体）和古希腊文，令后世学者可以做参考比对，通过古希腊文来解读圣书体，从而使这块石碑无比珍贵，也因此罗塞塔石碑在现代也被引申为「暗喻」、「翻译」和「关键线索」等的含义。 艳后与凯撒克利奥帕特拉七世是托勒密王朝中第一个学会埃及语并接受埃及信仰和埃及神明的人，这是其他王室成员所拒绝的事（想想罗塞塔石碑还需要古希腊文书写）。她早年在就政治上活跃，应该算是被迫和托勒密十三世（同父异母弟弟）结婚以一同统治埃及。但之后两人发生冲突，艳后被迫流亡叙利亚，招兵买马打算反攻托勒密十三世。 此时罗马内部也正在争斗，凯撒打败了庞培，后者被迫跑到埃及。而托勒密十三世可能希望寻求凯撒支持而擅自将凯撒老对手庞培暗杀了，在凯撒追到埃及时献上庞培的头颅。这可能令凯撒十分不满，因为庞培是他的劲敌、女婿，也是罗马执政官，不应该被异国人杀死。 克利奥帕特拉七世可能看准了这个机会潜回埃及，并将自己献给凯撒，做他的情人，取得凯撒的支持。之后凯撒对埃及统治者的仲裁，是克利奥帕特拉七世上位。 传说当时克利奥帕特拉把自己伸直，用毯子卷起来包覆其中，命人抬着进入王宫，这时克利奥帕特拉年仅21岁，凯撒52岁。维基百科 托勒密十三世当然十分不满，率军围攻亚历山大城内罗马军。凯撒等到增援到来，脱围之后在尼罗河战役打败托勒密十三世，随后另立了托勒密十四世（仍旧是艳后的弟弟）和艳后结婚统治埃及。艳后虽然名义上嫁给托勒密十四世，但是实际上却和凯撒相好，还生了一个孩子托勒密·凯撒。 BC46，艳后来到罗马，遭到罗马人民的厌恶，因为凯撒已婚，而她和凯撒关系暧昧。但凯撒不愧为独裁者，完全罔顾旁人，甚至为艳后制作黄金雕像，和罗马人先祖维纳斯神像一起摆放。在凯撒被刺后，艳后还留在罗马，可能是希望自己儿子继承凯撒。但是凯撒大概没有承认这个儿子，而是在遗嘱另立他的养子屋大维作为继承人。于是她回到埃及，毒死了托勒密十四世，与其儿子共同统治埃及。 艳后与安东尼安东尼是凯撒生前最重要的军队指挥官。凯撒被刺后，他和屋大维解决了反凯撒势力。之后在埃及传唤艳后的时候也应该是被迷住了，和她在 BC41 到 BC40 年度过了一段时光。接着安东尼离开了埃及，艳后不久后生下一男一女双胞胎，相信就是安东尼的儿女。 安东尼和屋大维从 BC41 年开始就不和，因为安东尼妻子发起了和屋大维对抗的战争。虽然后来妻子突然身亡，安东尼也娶了屋大维的姐姐小屋大薇以维持稳定，但是两人仍然是竞争关系。安东尼把大量土地给予了艳后，屋大维利用这一点宣称其为外国女王而牺牲共和国权利。两人关系持续恶化，安东尼也冷落小屋大薇。之后对安息帝国的战争失利，安东尼回到埃及。BC36 年，艳后又为安东尼生下第二个儿子。 BC34 年赢得对亚美尼亚的战争后，安东尼和艳后在大胜后的举动被屋大维大肆利用，煽动罗马对安东尼的不满，包括艳后以神的名义宣称自己和凯撒的儿子是万王之王，自己则是万王之女王，和安东尼的儿女则分别册封国王等。安东尼更公然向罗马宣称将包括打下亚美尼亚等一部分罗马行省赠予克利奥帕特拉七世。最冒犯屋大维的，是安东尼宣称艳后和凯撒的儿子托勒密·凯撒才应该是凯撒的继承人。 屋大维借机行事向埃及女王宣战，在亚克兴角海战中打败安东尼。安东尼输掉海战的原因可能是因为海军在战事胶着时出现叛逃，安东尼和艳后逃回了埃及，陆军见势也投降屋大维了。 屋大维乘胜追击到埃及，退无可退的安东尼误认为艳后已自杀，用剑刺自己，可能是被带到艳后藏身的坟墓才真正死去。艳后随后也被捕了。 关于克利奥帕特拉七世的死法，无人知道。流传最广的版本是她让毒蛇咬自己而毒发身亡，也有观点认为他是被屋大维下令处死。 她和凯撒的儿子托勒密·凯撒被屋大维处死，从此埃及成为了罗马帝国的行省，托勒密王朝终结，埃及的法老时代也终结了。 罗马统治时期 -&gt; 阿拉伯人入侵作为罗马帝国行省的埃及，发生的事情属于罗马的历史了，这里不详述。只是 CE264 年的时候，反抗罗马的帕尔米拉女王季诺碧亚征服了埃及使其脱离罗马，并自称埃及女王，说她的家族可追溯到克利奥帕特拉七世。后来罗马也没有战胜她，只能是围城断粮逼其投降。 埃及有一段时间曾被萨珊王朝所占领（CE621 - CE629），拜占庭（东罗马帝国）虽然重新夺回，但十年后阿拉伯帝国入侵的时候，已经无力抵抗，自此埃及伊斯兰化，埃及文明也不复存在。 古埃及神明古埃及是一个宗教特色很浓的国家，了解其神明系统有助于深入理解古埃及，不过没有兴趣也可不看。 见 古埃及神明 一文。 一些小知识法老的头冠分两部分，代表上埃及的白色王冠，代表下埃及的红色王冠，一般法老会戴着两个，诏示其为整个埃及的统治者。 古埃及神话中的神明都是兄妹 / 姐弟结合，这可能造成了古埃及王室基本都是近亲结合。如果侧室的儿子登基法老，一般也要娶正室的女儿。统治者可能借此保持所谓的血统纯正。 建造金字塔和神庙的大石头、花岗岩等，很多是从阿斯旺开凿的。 部分参考资料开放世界埃及篇古埃及 - 维基百科，自由的百科全书古埃及历史 - 维基百科，自由的百科全书阿姨学、古埃及 | 阿姨学词典 Wikia | FANDOM powered by WikiaHistory of ancient Egypt - WikipediaPrehistoric Egypt - WikipediaEarly Dynastic Period (Egypt) - WikipediaOld Kingdom of Egypt - WikipediaFirst Intermediate Period of Egypt - WikipediaMiddle Kingdom of Egypt - WikipediaSecond Intermediate Period of Egypt - WikipediaNew Kingdom of Egypt - WikipediaThird Intermediate Period of Egypt - WikipediaLate Period of ancient Egypt - WikipediaPtolemaic Kingdom - WikipediaSasanian Egypt - WikipediaFirst Dynasty of Egypt - WikipediaSecond Dynasty of Egypt - WikipediaThird Dynasty of Egypt - WikipediaFourth Dynasty of Egypt - WikipediaFifth Dynasty of Egypt - WikipediaSixth Dynasty of Egypt - WikipediaSeventh Dynasty of Egypt - WikipediaEighth Dynasty of Egypt - WikipediaNinth Dynasty of Egypt - WikipediaTenth Dynasty of Egypt - WikipediaEleventh Dynasty of Egypt - WikipediaEleventh Dynasty of Egypt - WikipediaTwelfth Dynasty of Egypt - WikipediaThirteenth Dynasty of Egypt - WikipediaFourteenth Dynasty of Egypt - WikipediaFifteenth Dynasty of Egypt - WikipediaSixteenth Dynasty of Egypt - WikipediaAbydos Dynasty - WikipediaSeventeenth Dynasty of Egypt - WikipediaEighteenth Dynasty of Egypt - WikipediaNineteenth Dynasty of Egypt - WikipediaTwentieth Dynasty of Egypt - WikipediaTwenty-first Dynasty of Egypt - WikipediaTwenty-second Dynasty of Egypt - WikipediaTwenty-third Dynasty of Egypt - WikipediaTwenty-fourth Dynasty of Egypt - WikipediaTwenty-fifth Dynasty of Egypt - WikipediaTwenty-sixth Dynasty of Egypt - WikipediaTwenty-eighth Dynasty of Egypt - WikipediaTwenty-ninth Dynasty of Egypt - WikipediaThirtieth Dynasty of Egypt - WikipediaArgead dynasty - WikipediaPtolemaic Kingdom - WikipediaValley of the Kings - WikipediaGiza pyramid complex - WikipediaHistories (Herodotus) - WikipediaAssyria - WikipediaKingdom of Kush - WikipediaHyksos - WikipediaRamesseum - WikipediaAncient Near East - WikipediaAbu Simbel temples - WikipediaEgyptian–Hittite peace treaty - WikipediaBattle of Kadesh - WikipediaAbydos King List - WikipediaAbydos, Egypt - WikipediaCanaan - WikipediaKarnak - Wikipedia早王朝时期 - 维基百科，自由的百科全书古王国时期 - 维基百科，自由的百科全书第一中间时期 - 维基百科，自由的百科全书中王国时期 - 维基百科，自由的百科全书第二中间时期 - 维基百科，自由的百科全书新王国时期 - 维基百科，自由的百科全书第三中间时期 - 维基百科，自由的百科全书古埃及晚期 - 维基百科，自由的百科全书阿契美尼德王朝 - 维基百科，自由的百科全书托勒密时期 - 维基百科，自由的百科全书罗马及拜占庭时期 - 维基百科，自由的百科全书萨珊时期 - 维基百科，自由的百科全书埃及第一王朝 - 维基百科，自由的百科全书埃及第二王朝 - 维基百科，自由的百科全书埃及第三王朝 - 维基百科，自由的百科全书埃及第四王朝 - 维基百科，自由的百科全书埃及第五王朝 - 维基百科，自由的百科全书埃及第六王朝 - 维基百科，自由的百科全书埃及第七王朝 - 维基百科，自由的百科全书埃及第十一王朝 - 维基百科，自由的百科全书埃及第十二王朝 - 维基百科，自由的百科全书埃及第十三王朝 - 维基百科，自由的百科全书埃及第十四王朝 - 维基百科，自由的百科全书埃及第十五王朝 - 维基百科，自由的百科全书埃及第十六王朝 - 维基百科，自由的百科全书埃及第十七王朝 - 维基百科，自由的百科全书埃及第十八王朝 - 维基百科，自由的百科全书埃及第十九王朝 - 维基百科，自由的百科全书埃及第二十王朝 - 维基百科，自由的百科全书埃及第二十一王朝 - 维基百科，自由的百科全书埃及第二十二王朝 - 维基百科，自由的百科全书埃及第二十三王朝 - 维基百科，自由的百科全书埃及第二十四王朝 - 维基百科，自由的百科全书埃及第二十五王朝 - 维基百科，自由的百科全书埃及第二十六王朝 - 维基百科，自由的百科全书埃及第二十七王朝 - 维基百科，自由的百科全书埃及第二十八王朝 - 维基百科，自由的百科全书埃及第二十九王朝 - 维基百科，自由的百科全书埃及第三十王朝 - 维基百科，自由的百科全书埃及第三十一王朝 - 维基百科，自由的百科全书古希腊 - 维基百科，自由的百科全书馬其頓王國 - 维基百科，自由的百科全书托勒密王朝 - 维基百科，自由的百科全书波斯 - 维基百科，自由的百科全书帝王谷 - 维基百科，自由的百科全书吉萨金字塔群 - 维基百科，自由的百科全书历史 (希罗多德) - 维基百科，自由的百科全书亚述 - 维基百科，自由的百科全书库施 - 维基百科，自由的百科全书喜克索斯人 - 维基百科，自由的百科全书拉美西姆 - 维基百科，自由的百科全书古代近东 - 维基百科，自由的百科全书阿布辛贝勒神庙 - 维基百科，自由的百科全书埃及赫梯和约 - 维基百科，自由的百科全书卡迭石战役 - 维基百科，自由的百科全书阿拜多斯王表 - 维基百科，自由的百科全书阿拜多斯 - 维基百科，自由的百科全书迦南 - 维基百科，自由的百科全书卡纳克神庙 - 维基百科，自由的百科全书 修订记录2015.05.15 搜集材料 完成文章结构 2019.05.20 完成初稿 2019.05.21 新增缩略图 整体润色 2019.05.22 整理参考资料 增补早期王朝的内容 2019.05.23 新增「古埃及神明」一节]]></content>
      <categories>
        <category>知识</category>
        <category>古埃及</category>
      </categories>
      <tags>
        <tag>ancient-egypt</tag>
        <tag>history</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不要再只会用 for 了]]></title>
    <url>%2Fdont-only-use-for-any-more%2F</url>
    <content type="text"><![CDATA[No Silver Bullet 老黄牛的 for 几乎每一个编程语言都有 for，JavaScript 也不例外。 在 JavsScript 中，for 广泛用于遍历数组中，也能用于遍历对象的属性。 语法： 12for ([initialization]; [condition]; [final-expression]) statement initialization 是初始化语句，通常用于初始化计数变量（比如，你们最爱的 i）；condition 是判断本次是否执行 statement；final-expression 在 statement 执行完后执行，通常用于对计数变量进行变换。 例如，要遍历一个数组 arr，那么可以这样写： 1234for (var i=0; i&lt;arr.length; i++) &#123; ;// 做你爱做的事 // arr[i] 就能在每一次运行过程中取到在 arr 中的元素&#125; 或者经常见到所谓的性能优化： 1234for (var i=0, len=arr.length; i&lt;len; i++) &#123; ;// 做你爱做的事 // arr[i] 就能在每一次运行过程中取到在 arr 中的元素&#125; 强烈建议使用 const 或 let 声明变量而不是使用 var，因为 var 会在 for 语句外声明变量，结果就是变量可能会在意外的地方被读取到。如果你不能使用 ES2015 或更新的版本，下文同样有解决方法（同样是本文的主要内容）。 如果你写过 C 系列，那么你有可能忍不住自己的麒麟臂，写出「炫技」的代码来。比如 MDN 上的这个例子。 1234567891011121314151617181920212223242526function showOffsetPos(sId) &#123; var nLeft = 0, nTop = 0; for ( var oItNode = document.getElementById(sId); /* initialization */ oItNode; /* condition */ nLeft += oItNode.offsetLeft, nTop += oItNode.offsetTop, oItNode = oItNode.offsetParent /* final-expression */ ); /* semicolon */ console.log('Offset position of \'' + sId + '\' element:\n left: ' + nLeft + 'px;\n top: ' + nTop + 'px;');&#125;/* Example call: */showOffsetPos('content');// Output:// "Offset position of "content" element:// left: 0px;// top: 153px;" 这么写看着很酷，但是实际上不要这样写，尤其是在团队合作中。这样的代码一是混杂难懂，二是难以维护。代码首先是写给人看的，接着才是给机器运行的。 或许你已经非常习惯写 for 了，习惯到了看见一个数组就自然而然打出 for (...) 来。但是你有没有想过，很多时候，遍历数组其实跟索引并没有什么关系，代码只是要将数组里面的元素按顺序处理完。然而，数组天然就应该是顺序的，根本无需要一个额外的 i 来保证。换句话说，数组应该利用自身属性，提供无需索引的顺序读取方法，而索引只是在顺序读取的过程中的一个记录变量。 那这样有什么优势呢？ 从处理流程上说，举个例子：假设你是一个接待员，工作是处理一列队伍的咨询。使用 for 的处理方法是：先计算整个队伍的长度，然后喊第一个人开始处理；每处理完一个人，就将序号加一再喊；直到序号等于队伍长度。而使用直接顺序读取的处理方法是：从队伍最前开始处理，每处理完一个，直接转到下一个重新开始处理，直到队伍没有下一个需要处理。这样以来就能省去了对队伍长度和索引的处理。 从代码逻辑上说，在数组上提供顺序读取方法，是将全局的语法转化为了相当于成员函数的执行，解除了和全局的耦合的同时，结合链式调用和灵活的回调函数能解放出极大的数组处理潜力。你能轻松在一行代码内基于数组进行非常多而灵活的处理，并且将「肮脏」的处理过程隐藏起来，直接得到一个处理得「连你阿妈都唔识」的结果，干净利落。 下面来认识一下这些顺序读取方法吧。 优雅的 forEach, map, filter, reduce 在 ES5（ES5.1） 中，JavaScript 新增了多个数组方法，包括：forEach, map, filter, reduce。 每个方法都接受一个回调函数作为参数传入，每个方法都会在取得一个元素的时候调用此回调函数，不同在于不同方法对待回调函数的结果上。 forEachforEach 返回值为 undefined，适合通过数组来操作其他对象。 123arr.forEach(function callback(currentValue, index, array) &#123; //your iterator&#125;[, thisArg]); mapmap 返回值为回调函数返回值组成的数组，适合处理数组变换。 123var new_array = arr.map(function callback(currentValue, index, array) &#123; // Return element for new_array&#125;[, thisArg]) filterfilter 返回值为回调函数返回真所对应的元素组成的数组，适合处理数组筛选。 123var new_array = arr.filter(function callback(currentValue, index, array) &#123; // Return true or false&#125;[, thisArg]) reducereduce 返回值为初始值经过和每个元素作用后得到的最终值，适合遍历数组后得到一个值或者一个对象的情况。 123var new_array = arr.reduce(function callback(accumulator, currentValue, index, array) &#123; // Return accumulator&#125;[, initialValue]) 别忘了在回调函数中返回结果！ 新方法新思路配合几个编写代码时的常见场景，看看不使用 for 的解决方法。 循环多次执行某些动作给定一个数组，打印其元素。 1var arr = [1, 2, 3] for 123for (var i=0; i&lt;arr.length; i++) &#123; console.log(arr[i]) // 1 2 3&#125; 炫技 12345for ( var i=0; i&lt;arr.length; console.log(arr[i++]) ); 改写 1arr.forEach(el =&gt; console.log(el)) // 1 2 3 对数组的每一个元素进行变换给定一个数组，将其元素都加一。 1var arr = [1, 2, 3] for 123for (var i=0; i&lt;arr.length; i++) &#123; arr[i] = arr[i] + 1&#125; 炫技 12345for ( var i=0; i&lt;arr.length; arr[i] = arr[i++] + 1 ); 改写 1arr.forEach((el, i, ar) =&gt; ar[i] = ar[i] + 1) 更好 1const newArr = arr.map(el =&gt; el + 1) 在允许的情况下尽量不要去修改原数据，而是返回一个新的数组。 提取数组中符合某个标准的元素给定一个数组，筛选出大于 2 的元素。 1var arr = [1, 2, 3] for 123456var newArr = []for (var i=0; i&lt;arr.length; i++) &#123; if (arr[i] &gt; 2) &#123; // e.g. should be larger than 2 newArr.push(arr[i]) &#125;&#125; 改写 1const newArr = arr.filter(el =&gt; el &gt; 2) 使用数组生成新数组给定一个数组，要求使用其元素内容作为键，元素下表作为值，生成一个新数组 1var arr = ['a', 'b', 'c'] for 1234567var newArr = []for (var i=0; i&lt;arr.length; i++) &#123; var obj = &#123;&#125; obj[arr[i]] = i newArr.push(obj)&#125;// can access 'i' and 'obj' here 改写 123456var newArr = arr.map(function(el, i) &#123; var obj = &#123;&#125; obj[el] = i return obj&#125;)// cannot access 'obj' here, hell yeah! ES2015 12const newArr = arr.map((el, i) =&gt; &#123; return &#123; [el]: i &#125; &#125;)// less code in one line! fuck yeah! 遍历数组，得到一个最终值给定一个数字数组，将其包含的数字累加 1var arr = [1, 2, 3] for 1234var result = 0for (var i=0; i&lt;arr.length; i++) &#123; result += arr[i]&#125; 改写 1const result = arr.reduce((ret, el) =&gt; ret + el, 0) 给定一个键值数组，将其转换为一个对象 123456var arr = [ &#123; key: 'a', value: 1 &#125;, &#123; key: 'b', value: 2 &#125;, &#123; key: 'c', value: 3 &#125;, &#123; key: 'd', value: 4 &#125;,] for 1234var result = &#123;&#125;for (var i=0; i&lt;arr.length; i++) &#123; result[arr[i].key] = arr[i].value&#125; 改写 1234const result = arr.reduce((obj, &#123; key, value &#125;) =&gt; &#123; obj[key] = value return obj&#125;, &#123;&#125;) 从以上例子中可以看到，ES2015 的代码更加清晰可读，而且代码打起来流畅省时（你自己试试！）。如果你还没使用上 ES6，那么应该赶紧去学！或许这篇文章和这篇文章能说服你。 也可以看看本人写的 《Understanding ECMAScript 6》笔记。 不灭的 for尽管数组新增的方法十分强大，但是 for 除了会在遍历数组中使用，还会在处理对象的时候使用，比如使用 for...in 遍历对象的属性（及其原型上的属性）。在这些场合上，就需要具体情况具体分析了。 遍历对象问题给出 app 的版本以及版本的使用量，统计最新两个大版本的使用量。版本命名符合 semver 标准，形如 ‘x.x.x’。 1234567891011121314151617181920212223var apps = &#123; '6.6.0': 53695, '6.10.0': 47319, '5.4.0': 42601, '5.8.5': 41320, '5.5.5': 40322, '5.8.1': 38509, '5.1.5': 26473, '5.2.1': 24267, '6.10.1': 17042, '5.8.0': 13878, '5.5.1': 12887, '5.1.0': 9836, '6.5.0': 8909, '5.0.0': 6704, '4.7.0': 5915, '4.5.0': 5300, '4.3.0': 4213, '5.7.0': 4000, '4.6.1': 3647, '4.4.0': 1921, '4.6.0': 1802&#125; for 123456789101112131415let largest = 0const versions = &#123;&#125;for (const key in apps) &#123; const major = parseInt(key.split('.')[0], 10) if (!versions[major]) &#123; versions[major] = &#123;&#125; &#125; versions[major][key] = apps[key] largest = largest &lt; major ? major : largest&#125;const newApps = &#123;&#125;for (let i=0; i&lt;2; i++) &#123; Object.assign(newApps, versions[largest-i])&#125; ES2015 123456789101112131415let largest = 0const versions = Object.keys(apps).reduce((obj, key) =&gt; &#123; const major = parseInt(key.split('.')[0], 10) if (!obj[major]) &#123; obj[major] = &#123;&#125; &#125; obj[major][key] = apps[key] largest = largest &lt; major ? major : largest return obj&#125;, &#123;&#125;)const newApps = [...Array(2).keys()].map(x =&gt; largest - x).reduce((obj, key) =&gt; &#123; return Object.assign(obj, versions[key])&#125;, &#123;&#125;) 使用 for 和不使用 for相比，相差不大，甚至代码看起来更清晰，而且有 ES2015 的加成，消除了变量泄露的影响。所以如果是遍历对象，就没必要去用数组的方法了。 性能问题截止目前位置（2017-10-17），从 benchmark 来看，在性能上，for &gt; forEach &gt; for...of。 因此在一些对性能要求比较高的代码中，使用 forEach 和 for...of 需要谨慎，这有可能会成为性能瓶颈。另外 for...of 在浏览器上的支持度不高，所以还是可以暂时不使用，除非你清楚自己在干什么。 不过，仍然是那句话，代码首先是写给人看的，性能优化应该在功能实现之后再考虑。 循环中断问题一般来说，使用 for 和使用数组方法在功能实现上是一样的，但是由于 for 是编程语言层面的实现，可以使用 break 和 return 手段进行中断；上文中的数组方法由于是遍历调用函数，并不存在什么停止的条件，因此肯定是会将所有元素都过一遍。在这种情况下，就乖乖使用 for 吧。 当然也可以使用 Array.some 等方法模拟中断效果，但要是那样做还不如直接 for 呢。 Promise 的问题使用数组方法时，最容易出错的地方是和 Promise 一起使用的时候。 比如需要从不同的 URL 请求数据，极其容易写成以下错误的代码。 12345678const URLs = [ 'http://www.a.com', 'http://www.b.com', 'http://www.c.com',]const results = URLs.map(url =&gt; &#123; return $.ajax(url)&#125;) 你会发现 results 的内容只是 Promise 实例，根本不是期望的值。代码的问题在于几乎所有的网络请求 API，返回的都是一个 Promise 实例。 正确的做法是使用 Promise.all 将多个 Promise 实例包装成一个 Promise 实例： 123456789const URLs = [ 'http://www.a.com', 'http://www.b.com', 'http://www.c.com',]let resultPromise.all(URLs.map(url =&gt; &#123; return $.ajax(url)&#125;)).then(res =&gt; result = res) 如果你使用 async／await，千万不要这样写： 12345678const URLs = [ 'http://www.a.com', 'http://www.b.com', 'http://www.c.com',]const results = URLs.map(async url =&gt; &#123; await $.ajax(url)&#125;) 同样这种写法只能得到一个 Promise 实例数组。应该这样： 12345678const URLs = [ 'http://www.a.com', 'http://www.b.com', 'http://www.c.com',]const results = await Promise.all(URLs.map(url =&gt; &#123; return $.ajax(url)&#125;)) ⚠️ 注意你不能在没有 async 标识的函数中使用 await，因此在各种全局状态下是无法使用 await 的。幸好 async／await 处理的就是 Promise，你只需要改用 .then 就好了。 举一个更极端的例子，URL 请求需要按顺序发送，上一次的结果需要作为下一次请求的参数。怎么写呢？ Promise 方法： 12345678910111213141516const URLs = [ 'http://www.a.com', 'http://www.b.com', 'http://www.c.com',]let resultURLs.map(url =&gt; &#123; return params =&gt; &#123; return $.ajax(url + params) &#125;&#125;).reduce((prev, next) =&gt; &#123; return prev.then(next)&#125;, Promise.resolve('')).then(ret =&gt; result = ret) async／await 方法： 123456789101112const URLs = [ 'http://www.a.com', 'http://www.b.com', 'http://www.c.com',]const result = await URLs.map(url =&gt; &#123; return params =&gt; &#123; return $.ajax(url + params) &#125;&#125;).reduce((prev, next) =&gt; &#123; return prev.then(next)&#125;, Promise.resolve('')) 但是看看用 for 会如何？ 123456789const URLs = [ 'http://www.a.com', 'http://www.b.com', 'http://www.c.com',]let resultfor (const url of URLs) &#123; result = await $.ajax(url + result)&#125; 意外的简洁。这归功于数组的有序性，以及 for 在语言层面上的可被打断性。 可见在处理顺序的异步请求上，for 有着很大的优势，但在并发请求上，还是乖乖用 .map 吧（比 for + .push 要好）。]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>bytalk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mocha + Chai + istanbul in ES2015]]></title>
    <url>%2Fmocha-chai-istanbul-in-es2015%2F</url>
    <content type="text"><![CDATA[使用 JavaScript 写代码的时候，无论是使用 TDD 方法还是为了保证代码的质量和可维护性，都应该考虑加上单元测试。在博文 mocha + chai + Travis CI + Codecov 使用流程 中有简单地介绍了如何使用流行的 JavsScript 库来对代码进行自动测试，检查代码覆盖率。 在那篇文章中，使用的是 Mocha／Chai／istanbul 和在线的 Codecov，以及和 Github 关系密切的 Travis CI，而且测试的 JavaScript 代码是 es5。现在 es2015 已经标准化了，那么教程也需要更新一下了。另外如果项目是私有项目，那么还是使用完备的离线测试环境比较好。接下来就是一个快速可行的教程。 安装和配置测试框架无需变更，还是 Mocha + Chai 的组合，但是 istanbul 需要稍微变动一下。 如果你不需要 istanbul 做覆盖率测试，那么需要使用 npm install --save-dev babel-register 和 mocha --require babel-register 使 mocha 能识别 es2015 的代码 使用新套件，直接安装 npm i -S mocha chai cross-env nyc babel-plugin-istanbul babel-register babel-preset-env。 mocha 和 chai 不用解释了，nyc 可以理解是 istanbul 的命令行工具；babel-plugin-istanbul 是在 babel 中插入 istanbul，babel-register 是 istanbul 使用的 babel 接口，这样两个库就打通了；最后 babel-preset-env 是 babel 的运行配置。 先来配置 babel-plugin-istanbul，新建 .babelrc： 12345678910&#123; "presets": [ "env" ], "env": &#123; "test": &#123; "plugins": [ "istanbul" ] &#125; &#125;&#125; presets 配置告诉 babel 使用 babel-preset-env。当然也可以用 ‘es2015’ + ‘stage-0’ 的组合，具体可以自行斟酌。 env.test.plugins 告诉 babel 在 NODE_ENV=test 的情况下使用插件 babel-plugin-istanbul。 接下来配置 babel-register，新建 .nycrc： .nycrc 是 nyc 的配置文件，和 .babelrc 类似，当然配置也是可以直接写进 package.json 的。 1234567891011&#123; "require": [ "babel-register" ], "reporter": [ "lcov", "text-summary" ], "sourceMap": false, "instrument": false&#125; 以上的配置直接用了官方的配置。require 字段告诉 nyc 使用 babel-register，reporter 字段的 ‘lcov’ 会让 nyc 生成 lcov.info 文件和对应的 HTML 报告，如果使用 lcovonly 则只生成 ‘lcov.info’。’text-summary’ 则是会在控制台输出覆盖率等信息。 文件会默认生成在 /coverage 下，可以使用 report-dir 字段指定。 最后，在 package.json 中加入： 123"scripts": &#123; "test": "cross-env NODE_ENV=test nyc mocha test/**/*.spec.js"&#125;, 测试编写事例比如有 index.js： 12345export class Test &#123; constructor () &#123; this.data = 'a' &#125;&#125; 那么可以写 test/index.spec.js，可以直接上 ES2015 的语法： 123456789import &#123; expect &#125; from 'chai'import &#123; Test &#125; from '../index'describe('index test', function() &#123; it('should be a string', function() &#123; let test = new Test expect(test.data).to.be.a('string') &#125;)&#125;) 使用 npm test 运行测试，得到： 1234567891011121314151617&gt; cross-env NODE_ENV=test nyc mocha test/**/*.spec.js index test ✓ should be a string 1 passing (8ms)=============================== Coverage summary ===============================Statements : 100% ( 1/1 )Branches : 100% ( 0/0 )Functions : 100% ( 1/1 )Lines : 100% ( 1/1 )================================================================================ Bonus在测试中经常需要测试 promise 等异步操作，虽然 Mocha 库是可以使用回调来完成测试的，但是我们当然要用 async／await 啦。 比如，需要测试 index.js 中的 requestAsync： 1234567891011export class Test &#123; constructor () &#123; this.data = 'a' &#125; requestAsync () &#123; return new Promise((res, rej) =&gt; &#123; res(this.data) &#125;) &#125;&#125; 那么需要先 npm i -S babel-polyfill babel-plugin-transform-async-to-generator。 然后配置 .nycrc，加上 ‘babel-polyfill’ 支持 generator 运行时： 1234567&#123; "require": [ "babel-polyfill", "babel-register" ], ...&#125; 配置 .babelrc，加上 ‘transform-async-to-generator’，将 async 模式转换为 generator 模式。 12345678&#123; ... "env": &#123; "test": &#123; "plugins": [ "istanbul", "transform-async-to-generator" ] &#125; &#125;&#125; 接着这样测试异步： 12345678910import &#123; expect &#125; from 'chai'import &#123; Test &#125; from '../index'describe('test#requestAsync', function() &#123; it('should get a string', async function() &#123; const test = new Test const ret = await test.requestAsync() expect(ret).to.be.a('string') &#125;)&#125;) 在测试项 it 的第二个函数前加 ‘async’ 标志异步，然后在返回 promise 的调用前加上 ‘await’，OK。 1234567891011121314151617&gt; cross-env NODE_ENV=test nyc mocha test/**/*.spec.js test#requestAsync ✓ should get a string 1 passing (14ms)=============================== Coverage summary ===============================Statements : 100% ( 3/3 )Branches : 100% ( 0/0 )Functions : 100% ( 3/3 )Lines : 100% ( 3/3 )================================================================================]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>mocha</tag>
        <tag>chai</tag>
        <tag>istanbul</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说牛客上的一道 JavaScript 题目]]></title>
    <url>%2Ftalk-about-a-question-in-nowcoder%2F</url>
    <content type="text"><![CDATA[牛客上有这么一道 JavaScript 的 题目。 1234567// 填写内容让下面代码支持 a.name = “name1”; b.name = “name2”;function obj(name)&#123; 【1】&#125;obj.【2】 = "name2";var a = obj("name1");var b = new obj; 【1】和【2】是填写的内容，【2】的答案是 prototype.name，没争议。 问题是【1】，参考答案居然是 if(name){ this.name = name;}return this;，这么随便地玩弄 this 不就是明摆着污染全局变量吗？暴力赋值不可取。 下面的一些高票讨论还说了一大堆解释的废话，连他自己都说自己好罗嗦。对，你不但罗嗦，而且还没有改错。注释里都说了给 window 的属性赋值，还不自知出问题，真是误人子弟。 先来分析一下题目，a 和 b 都从 obj 来，为什么同名的属性值不一样？可以看出，是对 obj 这个函数的调用方式不一样，a 是 obj 函数的调用结果，而 b 则是 obj 作为 构造函数 调用的结果。所以这题的重点应该是如何区分函数调用和构造函数调用。 一个关键字 new 决定了不同。new 的作用是什么呢？MDN 上说了，面试也会考你的，简单来说是三步，new foo： 生成一个继承于 foo.prototype 的对象 foo 会被调用，其中的 this 值会被绑定为 1 中的对象 如果 foo 没有返回一个对象（注意是对象！），则返回 1 的对象 从 2 就可以看出 this 值会被 new 绑定为一个确定的对象，而不是像普通函数调用中那样自己不可预料，要看上下文的进程。 于是就可以在这里做文章。先来判断 this 的值。 1if (this instanceof obj) &#123;&#125; instanceof 会检查 this 的原型链上是否存在 foo.prototype。也就是说能判断是否满足第 1 条，确保了对象能从 prototype 中读取到 name 属性。（毕竟代码中并没有给 b 的赋值中传入） instanceof 并不是完美的判断方法，但是在这里足够了，后面会谈到这个问题。 12345678if (this instanceof obj) &#123; // new 调用&#125; else &#123; // 非 new 调用 return &#123; name: name &#125;&#125; 非 new 调用的情况下，直接返回一个新对象就 OK 了。 而在 new 调用的情况下，可以看到 function obj(name) 定义的时候是有参数的，调用的时候却没参数，这就要小心了，为了安全起见，还是判断一下为妙。 1234567891011if (this instanceof obj) &#123; // new 调用 if (name !== undefined) &#123; this.name = name &#125;&#125; else &#123; // 非 new 调用 return &#123; name: name &#125;&#125; 一般来说，判断会写成 if (name)，但是碰到 null、0、false 就 GG 了，所以还是谨慎点吧。 问题到这里就可以比较完美地解答了。 bonus: instanceof 的问题『instanceof 会检查 this 的原型链上是否存在 foo.prototype』，为什么说得这么拗口，是因为需要表达出 instanceof 本来就不是真的用来检测是否调用 new 的方法。 在题目里面，要求的是 a 需要从原型链上读取到特定的属性值，所以 instanceof 的作用刚好在这里能符合要求而已。 函数调用除了题目中的方法还有第三种方法，那就是 foo.call、foo.apply，而且也能为函数指定 this 的值（所以还有 bind）。因此是存在方法调戏 instanceof 的。 123456foo.prototype.name = 'foo'var midman = new foo('fake foo')var a = foo.call(midman)var b = foo.call(midman, 'b')a // undefined, WTF?!b // undefined, WTF?! 这里的 foo 调用的方式是作为函数来调用，但是为 this 绑定的值是从 foo 上 new 出来的，换句话说，其原型链上存在 foo.prototype，于是就骗过了 instanceof。 于是 ES2015 来搭救你了，新增了一个 new.target。于是修改成： 1234567891011if (new.target !== undefined) &#123; // new 调用 if (name !== undefined) &#123; this.name = name &#125;&#125; else &#123; // 非 new 调用 return &#123; name: name &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
        <category>黑客</category>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FictionInjection-始动：Angular 依赖注入分析和源码抽取改造（上）]]></title>
    <url>%2Ffictioninjection-series-analyze-angular-dependence-injection-and-extract-it-part-1%2F</url>
    <content type="text"><![CDATA[几年前有一个项目构思，由于技术水平低，当时并没有思考得很清楚，所以一直没怎么着手开始。近来前端很多优秀的库出现了，也让我对那个项目有了新的想法。在写了几个 JavaScript 的项目后我觉得可以尝试开始了。尝试并成功写出一些代码之后，就开（挖）始（坑）了这个系列的博文。 项目是写一个 JavaScript 框架，干什么的在此并不是重点，但是首先需要一个可扩展的模块系统。最简单就是直接用 jQuery 扩展的写法，直接将函数等的挂载在一个对象下，不过如此一来模块之间依赖非常多的话，管理起来会十分困难。也可以使用 AMD / CMD 的模块化的方法，不过考虑到 ES2015 已经加入了 import / export 的语法，最好就直接使用。然而使用了 ES2015 的语法之后，仍然使用 AMD 等的语法就显得很别扭，但是又想要依赖注入功能怎么办？ 解决方法是模（fu）仿（zhi）著名的 AngularJS 中关于依赖注入的源代码。 Angular 有两个版本，1.x 和 2.x，但是 2.x 中，淡化了模块的概念，直接采用 component 和 ES2015 的 import / export 的机制，所以依赖注入已经不太算是亮点了。而且 Angular2 采用 TypeScript 编写，从语法编写上也不适合作为参考。最后选定 1.4.5 版本。 Angular 项目下还有一个不怎么有人知道的 di.js 项目，是从 Angular 中独立出来的依赖注入库，但是从文档来看，也是需要 TypeScript 来使用。 文章较长，给个目录 实现依赖注入 从 API 入手 开始分析 统一包装 小结 注入器的奥秘 读源码的意外发现 实现依赖注入↑JavaScript 如何实现依赖注入呢？AngularJS 给出了三个解决方法。 12345678910// 直接在参数里面声明module.service( function ( $http ) &#123;&#125; )// 使用显示注释function a () &#123;&#125;a.$inject = ['$http']module.service( a )// 数组内联module.service( ['$http', function ( http ) &#123;&#125;] ) 实际上三个方式都是一样的，只是使用方式不一样，最后都是使用了 JavaScript 的闭包来实现依赖的注入，原理如下： 123456function method ( $http ) &#123; return function ( args ) &#123; // $http.get( args ) // ..... &#125;&#125; 将依赖作为参数传入 menthod 得到的返回值就是是一个可以调用 $http 服务的函数了。 像这样 [&#39;$http&#39;, function ( http ) {}] 最后一个元素是函数的结构可以称为一个‘可注入结构’。 从 API 入手↑Angular 库的源代码文件非常大，一般基本不会从头开始看。而 API 作为库对外的窗口，从 API 的使用顺藤摸瓜地查找代码是比较好的做法。Angular 模块的使用一般如下： 123456789101112// declare moduleconst a = angular.module( 'a', [] );const b = angular.module( 'b', [] );const c = angular.module( 'c', ['a'] );// use the modulea.value( 'a', 123 ).factory( 'a', function() &#123; return 123; &#125; ).service( 'serviceName', ... ).directive( 'directiveName', ... ).filter( 'filterName', ... ); 先创建一个模块，用数组说明它的依赖模块，然后模块就可以调用 value、service、directive 等 API，API 的第一个参数是名字，第二个参数则是值或者函数或者数组，了解 AngularJS 的读者应该知道其实是值或者返回值的构造函数或者包含依赖和构造函数的数组。 打开 Angular.js ，查找出 module(name, requires, configFn) 函数的定义，位于一个更大的函数 setupModuleLoader 内。setupModuleLoader 为 module 函数编写了一些检测函数和变量。最重要的是 modules 变量，用来保存所有的模块信息。 下面来分析 module 函数。 123if (requires &amp;&amp; modules.hasOwnProperty(name)) &#123; modules[name] = null;&#125; 可以看出如果模块重复创建是会覆盖之前的。 12/** @type &#123;angular.Module&#125; */var moduleInstance = &#123; moduleInstance 就是将会返回出去的模块对象，可以看到里面有 name 和 requires 等属性和 provider 和 factory 等函数。 里面所有的方法，都是通过调用 invokeLater 和 invokeLaterAndSetModuleName 生成的新函数。新函数的上下文中带有 provider 和 method 信息。比如 service 函数：provider=’$provide’，method=’service’，暂时还看不出来信息有什么用，可以先跳过。新函数在调用的时候会将信息连同调用的参数一起 push 进模块的 _invokeQueue 属性中。 绕了一大圈，就是知道了：在调用 value、service、provider 这些基本的模块功能函数的时候，其实只是将构造函数和相关信息先保存了下来，根本就没有做初始化模块等工作。 但是作为一个库必定需要跟 window 或者 document 产生点关系不然无法操作 DOM，根据编写过不少库的经验来看，通常将这样的代码放在最后。于是拉到最后一看，gotcha。 123jqLite(document).ready(function() &#123; angularInit(document, bootstrap);&#125;); 明显意思就是在文档准备完毕的时候调用 angularInit，转到 angularInit 的定义发现调用了 bootstrap(appElement, module ? [module] : [], config);，再转到 bootstrap 的定义，在函数内部又会调用 doBootstrap 函数，一系列的检查之后，调用了 createInjector 函数就结束了，转到 createInjector 的定义一看，有 $provide factory 等字样，说明找对地方了。 开始分析↑重点来分析 createInjector 函数。 函数体大概可以分成四段。 第一段是定义了 providerCache、instanceCache、providerInjector 和 instanceInjector。最后返回 instanceInjector 对象。providerInjector 和 instanceInjector 各为将 providerCache 和 instanceCache 传入 createInternalInjector 函数的返回值。 第二段是 provider 函数的定义，用以供初始化时候的调用。 第三段是 loadModules 函数的定义，作用是，显然，初始化模块。 第四段是 createInternalInjector 函数的定义，函数返回的是真正的注入器。 从第一段的代码来看，真正的工作是在 loadModules 函数中，因为 createInternalInjector 函数只返回一个对象，没有 ‘side effect’ 的代码。 loadModules 函数上来就是一个对模块数组的遍历，然后在遍历内取模块的属性 _invokeQueue 来调用 runInvokeQueue 函数对已经缓存下来的对象或方法的构造函数进行处理。 值得注意的是在做调用 runInvokeQueue 前，有一个递归的调用 loadModules(moduleFn.requires)，表明了在初始化本模块之前，会先初始化依赖的模块。 到目前为止，可以判明模块初始化的分两个阶段，第一个是：声明模块及其依赖模块 -&gt; 缓存模块变量的构造函数；第二个是：选取一个根模块（对应 AngularJS 中的 ‘app’ 模块） -&gt; 找出其依赖的模块，对于每一个依赖，递归地先初始化其依赖的模块，再初始化自身 -&gt; 处理模块中缓存的变量的构造函数。 如此采取先缓存所有模块再通过依赖树来初始化的做法虽然看起来繁琐，但是得到一个重要的特性就是声明模块的时候不用关注依赖的顺序，只需要表明依赖就可以了。如果声明的时候就立刻初始化，则必须小心检查所依赖的模块初始化是否已经完成了，然而如此一来就退化成了普通的模块化方法了。延迟初始化是实现依赖注入的重要过程。 模块依赖已经明了，现在来看看作为处理函数的 runInvokeQueue 函数。 123456789function runInvokeQueue(queue) &#123; var i, ii; for (i = 0, ii = queue.length; i &lt; ii; i++) &#123; var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]); provider[invokeArgs[1]].apply(provider, invokeArgs[2]); &#125;&#125; 重要的代码只有两行，provider = providerInjector.get(invokeArgs[0]); 和 provider[invokeArgs[1]].apply(provider, invokeArgs[2]);。 往上看一下，调用 providerInjector.get 相当于是调用 getService。 12345678910111213141516171819202122function getService(serviceName, caller) &#123; if (cache.hasOwnProperty(serviceName)) &#123; if (cache[serviceName] === INSTANTIATING) &#123; throw $injectorMinErr('cdep', 'Circular dependency found: &#123;0&#125;', serviceName + ' &lt;- ' + path.join(' &lt;- ')); &#125; return cache[serviceName]; &#125; else &#123; try &#123; path.unshift(serviceName); cache[serviceName] = INSTANTIATING; return cache[serviceName] = factory(serviceName, caller); &#125; catch (err) &#123; if (cache[serviceName] === INSTANTIATING) &#123; delete cache[serviceName]; &#125; throw err; &#125; finally &#123; path.shift(); &#125; &#125;&#125; 代码虽多，但基本就是干一件事，返回 cache 中的对象，如果没有，就用 factory 创建一个再返回。而调用的对象 providerInjector 的定义来看，cache 就等于： 12345678910providerCache = &#123; $provide: &#123; provider: supportObject(provider), factory: supportObject(factory), service: supportObject(service), value: supportObject(value), constant: supportObject(constant), decorator: decorator &#125;&#125;, OK，现在可以知道了那些被延迟初始化的模块元素会在这里被处理了。 从上文可以知道，invokeArgs[0] 的值为 $provider，invokeArgs[1] 的值为 service / factory 等，invokeArgs[2] 则为参数数组。 看看以下的示例： 12345// 如此使用m.service( 'b', ['a', function ( a ) &#123; this.a = a &#125;] );// 初始化的时候实际上调用$provider.service( 'b', ['a', function ( a ) &#123; this.a = a &#125;] ); 统一包装↑接下来就是分析模块元素（对外表现为 API）的代码了。 函数有点多，但是还是能看得出来。supportObject 不用管，只是负责转换一下参数，基本的函数是 provider，factory 会调用它，然后 value 和 service 会调用 factory。 12345678910function provider(name, provider_) &#123; assertNotHasOwnProperty(name, 'service'); if (isFunction(provider_) || isArray(provider_)) &#123; provider_ = providerInjector.instantiate(provider_); &#125; if (!provider_.$get) &#123; throw $injectorMinErr('pget', "Provider '&#123;0&#125;' must define $get factory method.", name); &#125; return providerCache[name + providerSuffix] = provider_;&#125; 第一个判断和第二个判断在 factory 调用的时候是无效的，因为 factory 调用 provider 的时候第二个参数是 Object，而且带有 $get 属性。实际上在本阶段做的是，就是将调用 API 传入的第二个参数（第一个参数是名字）再包装一层对象，再存储在 providerCache 中，对象统一拥有 $get 属性，或者说，接口。 其中，$get 属性是一个可供调用的函数，功能是即使模块元素混杂存储，也能被统一的接口成功调用。 对于 value，调用 API 的时候传入的是值，因此需要包装成返回这个值的函数才赋值给 $get。 对于 constant，值是不变的，所以可以看到就直接存储了。 对于 decorator，同样会定义 $get 属性。 对于 service，设计上应该生成一个单例并存储下来。不过在这里，仍然是继续包装起来。 源代码： 123456789101112131415161718192021function enforceReturnValue(name, factory) &#123; return function enforcedReturnValue() &#123; var result = instanceInjector.invoke(factory, this); if (isUndefined(result)) &#123; throw $injectorMinErr('undef', "Provider '&#123;0&#125;' must return a value from $get factory method.", name); &#125; return result; &#125;;&#125;function factory(name, factoryFn, enforce) &#123; return provider(name, &#123; $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn &#125;);&#125;function service(name, constructor) &#123; return factory(name, ['$injector', function($injector) &#123; return $injector.instantiate(constructor); &#125;]);&#125; 实际干了如下的事情： 1234567891011(function (name) &#123; return provider(name, &#123; // 跟其他 API 一样调用 provider 函数 $get: function () &#123; return instanceInjector.invoke( ['$injector', function($injector) &#123; return $injector.instantiate(constructor); // 注意 constructor 是用户自定义的‘可注入结构’ &#125;] // 这又是一个‘可注入结构’，注入的是 '$injector'，实际上就等于 instanceInjector , this); &#125; &#125;);&#125;)( 'serviceName' ) 最后依然将包装好的函数存入 $provider。 只是为什么还是存储在 $provider，而不是直接调用函数进行初始化？比如 service，为什么还要再包装上一层‘可注入结构’？ 小结↑前文提到，使用延迟初始化实现了模块的依赖注入，使依赖的模块不需要提前定义。 实际上模块内的元素（factory / service 等）也是可以使用依赖注入的。使用过 AngularJS 的肯定知道定义某一个 controller 的时候可以注入某个 service，然而 controller 和 service 的定义顺序应该不能对代码运行造成影响。 因此，在此时，模块元素的“构造函数”（注意是用户自定义的那个函数而并非供 new 调用的那个函数）还并不具备运行的条件，因为还是需要等依赖的元素初始化。 于是某种意义上，模块元素就需要第二重注入。把‘可注入结构’缓存在 $provider 中实际上就是对应了前文叙述的‘把模块先全部缓存’，包装上一个函数再统一放在 $get 属性下明显是方便供下一阶段的调用。 万事俱备，只欠注入了。 分析到现阶段，大家应该对平常使用频繁的 service、factory 等函数有了更深的认识了。 注入器的奥秘↑现在把精力放在 createInternalInjector 函数。 此函数在开始分析一节中已经提到了，作用只是返回一个对象。这个对象就是真正的注入器。 此函数被调用了两次，分别是得到 providerInjector 和 instanceInjector。 注入器中重要的函数有三个，分别是 getService、invoke 和 instantiate。 在开始分析中已经大致介绍了，getService 函数干一件事，返回 cache 中的对象，如果没有，就用 factory 创建一个再返回。 对于 providerInjector，factory 函数是： 123456function(serviceName, caller) &#123; if (angular.isString(caller)) &#123; path.push(caller); &#125; throw $injectorMinErr('unpr', "Unknown provider: &#123;0&#125;", path.join(' &lt;- '));&#125; 不难理解，因为在调用 provider 的时候，providerCache 中的函数应该已经在上一个初始化模块阶段中被定义好，如果没找到，那么肯定是调用了未定义的 provider。 对于 instanceInjector，factory 函数是： 1234function(serviceName, caller) &#123; var provider = providerInjector.get(serviceName + providerSuffix, caller); return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);&#125; instanceCache 本身就是空的，因此在找不到的时候，就去 providerInjector 里找 provider，然后得到其调用的结果，就是真正需要的实例（instance）了。$get 在这里就凸显出统一调用的用处了。 invoke 函数则是处理‘可注入结构’和调用函数。从源码中也可以看到组装参数和调用函数，其中也会调用 getService 去得到实参的值来实现注入。从这里的 getService 出发，又有可能调用 factory 继而继续调用 invoke 来得到所依赖的实例，直到没有任何依赖需要实例化，从而完美的实现了自洽。 instantiate 函数是用来处理 ‘service’ 的，是用来模拟 new 的，从代码来看也是如此：复制一个函数的 prototype，绑定为函数的 this，然后调用函数。因此调用 service API 的时候，可以完全使用构造函数的写法，同时也能得到注入特性。 读源码的意外发现↑读源码一般都会有一定的收获，或是技巧上的，或是思想上的。 当读完了 Angular 的依赖注入的代码后，才发现 Angular 虽然表明支持模块化，但是实际上所谓的模块化只是徒有其名，模块的定义只是方便框架自己做延迟初始化的工作，没有模块之实。模块只是依赖树上的节点，最终生成出来的命名空间跟模块没有一丁点的关系，所有模块里的东西，不论是 ‘value’、’service’ 和 ‘provider’ 等，都是平铺在 instanceCache 里面的。这样的做法明显的一个结果就是命名冲突，两个不同模块里面的同名对象，后实例化的会覆盖掉先实例化的。这一点非常的不好，因为完全不符合模块化的预期结果。 在下一篇编（fu）写（zhi）注入功能的时候，我会修改这部分使其能满足模块化的实际预期。]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>FictionInjection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看《Sherlock: The Abominable Bride》]]></title>
    <url>%2Fwatch-sherlock-the-abominable-bride%2F</url>
    <content type="text"><![CDATA[看完新出的夏洛克，想必大家都会很茫然。刚好今晚也看了，就说说我看了电影和影评后的总结吧。 PS: 有剧透才能更好地看电影。 PS: 如果你是想看好莱坞大片，还像和我同一片场的人那样带着爆米花和泡椒凤爪来看的，可以退票了。 简单来说，整部电影的剧情几乎都是在嗑了药的夏洛克进入多层梦境中发生的。他要解决上一季结尾中莫里亚蒂的 “回归” 的问题，于是在脑内——或者说是思维迷宫内——解决一百年前的另外一个 “死而复活的新娘” 的问题。而解决这个问题的方法，就是将自己带入到那个维多利亚时代中，思考自己会如何行动，剧情如何发展。这也就是为什么差不多通篇都是维多利亚时代风格的由来。案情重组，简而言之。不过，有一个问题，就是实际上根据设定，电影中福尔摩斯并不是十九世纪的人物，如此一来就对原来的案情进行了干涉，出现矛盾，这个后面再谈。 令来看福华 CP 的，卖腐的，相爱相杀的女性，啊不，观众大失所望，恐怕是悬疑色彩的浓重，剧情的多段跳跃和突然切换，以及似乎毫无卖腐的情节。然而我等从第一季就只对其具备推理性质和现代化改编产生强烈爱好的人却是大欢喜：这才是正剧的风格，第三季给某些群体派太多显而易见的糖了。 然而电影中的推理很好吗？电影没有派糖吗？非也。 先说推理。电影中的诡计归结成一句话就是：死了的新娘为何能复活并杀死其丈夫？答案是一开始就没死，是在姐妹们的帮助下演戏，之后再当街杀丈夫并给大众一种复活的假象再高明地自杀，不留下破绽，并且还继续利用这种牺牲换来了死而复生继而复活的恐怖现象来帮助姐妹完成对姐妹的丈夫的复仇。卧槽竟然吞枪自杀只是演戏？乍一看似乎有点敷衍，但是和朋友讨论后认为，如果考虑到十九世纪科技水平的低下和侦查手段的匮乏，加上法医的暗中帮助，实际上完全是可能发生的。所以说推理虽然并不出彩或者惊世骇俗，然而还是有意思的。只是编剧没有给解答过程一个酷炫的表现，所以观众就有不爽、硬了不射的憋屈。那为什么不表现得很光很亮很油还很 duang 呢？同样后面再谈。 再说派糖，电影中最明显的就是瀑布旁莫里亚蒂说的 “你们不如私奔吧” 的吧？原著可是福尔摩斯和教授一起掉下瀑布失踪的，电影里面华生来救福尔摩斯了啊。麦考夫在飞机里面对夏洛克嗑药的担心和毫不掩饰的 be there for you 你们无视了吗？午夜夏洛克和华生的深入交谈你们没触动吗？只能说糖派得有点晦涩了，伪粉抖一抖就掉了，真粉还是会粘着。 另外纵观整个案件，诡计的实施涉及到已经患绝症的新娘，女仆，为了证明自己和男性一样能胜任工作而不得不女扮男装的女法医（电影此处对 man 的翻译应该有问题）以及一众的女性秘密组织，换句话说，这其实标志着女性的反抗。电影中已有多处暗示：玛丽说她希望跟华生一样能做事，并且参加女性选举权的争取；麦考夫说有一个眼皮底下的 enemy，undetected, and unstoppable，还说 we will lose，because they are right we are wrong；玛丽从十九世纪的被晾在一边到二十世纪终于能和丈夫一起参与事情；华生家庭的情况；通通都是编剧支持女性争取权利的暗示。这也是跟随了近年电影频繁地使用女性作为主角，将女性塑造出不同形象的大流（我是从冰雪奇缘开始察觉近来电影有这样的趋势的）。这才是给女性派的最好的糖不是吗？ 最后来说说电影对夏洛克这个人物的思考，顺便也把前面两个 “后面再谈” 解决了。原著中福尔摩斯基本上被塑造成理性思考和推理的机器，然而比较 tricky 的一点是根据设定，小说是道尔笔下的华生写的，小说中福尔摩斯的形象是道尔笔下的华生给大众塑造的，真实 (?) 的夏洛克到底是怎样的人无从得知。电影中也有反复地强调华生将夏洛克的案件写成文章发表。在午夜华生反复质问夏洛克关于感情和过去的问题，夏洛克没有说出来。这是编剧对夏洛克这个人物感情的探讨，没什么清晰的结论。之后没能保护受害人，夏洛克把自己关在房间里又磕药。然后莫里亚蒂就出现了在房间又吞枪了一次，没死，夏洛克觉得想不通怎么死不了的时候飞机着陆了把他震醒了。醒过来的二十一世纪是现实。一番交流后他又睡了，在梦里十九世纪醒来，开始了找玛丽和到在教堂里面解谜。最后指认凶手的时候他突然想到，凶手为什么要找他来破案呢？因为历史上新娘案就没被侦破，他作为侦探加入进案件了就产生了干涉，造成了奇怪的悖论。接着莫里亚蒂又出来了，场景就又切换到二十一世纪了，但是是更深一层梦里的二十一世纪，因为最后死尸活过来了，在现实里是不可能的。紧接着场景转到了著名的瀑布，这个估计就是夏洛克心里近乎最深层的地方了。可以看到，每当梦里有不寻常的事情发生，莫里亚蒂就会出来，试图让夏洛克偏离方向，只是第一次被飞机降落打断了。于是也就解释了为何解谜过程不酷炫，第一解谜发生在夏洛克脑内，显然不需要 “炫” 给自己看；第二，解谜会引出悖论从而引出教授，太酷炫会让观众大脑当机无法思考莫里亚蒂出现的原因。看到这你是不是忘记了这一段说的是夏洛克人物的探讨了？前面说了一大段剧情其实就是论证了在这个系列中，编剧认为莫里亚蒂就是夏洛克的心结和过去，或者说他脑中的魔鬼，会让夏洛克的思考出现问题。这是编剧对夏洛克过去的探讨。在原著中两人双双跌下瀑布，电影中是华生出来救场，并且表现得完全不像非梦境的华生。这 “夏洛克被心魔莫里亚蒂殴打，华生赶来将教授一脚踹下” 的场景表明夏洛克不再纠结莫里亚蒂 “复活” 了，而明白是他 “回来” 了。 于是正如新娘最终还是死了，莫里亚蒂大约的确已经死了。正如复仇是秘密组织干的，无责任猜测一下下一季的剧情大概就是教授的同伙来复仇了。 最后来看看编剧在电影里融合了什么呢？电视剧中的人物的重新运用，合格的推理，女性主义，对夏洛克的人物心理探讨，还有两季之间的承前启后。或许把这么多的东西融于一炉是有点用力过猛了，我刚看完的时候也是有点懵了，但是走回家的路上却越想越有意思。 我给这电影三个评价： 女性主义的胜利 原著党的胜利 伪粉的处刑]]></content>
      <categories>
        <category>生活</category>
        <category>电影</category>
      </categories>
      <tags>
        <tag>movie</tag>
        <tag>bytalk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[クリスマス？なにそれ？美味しいの？]]></title>
    <url>%2Fsingle-bell-2015%2F</url>
    <content type="text"><![CDATA[一个妹子给我推荐了这个刷算法题换装的游戏。 然而随着一道又一道的题目的通过，悲伤感越来越重却是怎么回事。 在平安夜和圣诞节一个人对着电脑敲代码来给虚拟妹子解锁装扮也是够自虐的。]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 ES6 编写一个生命游戏]]></title>
    <url>%2Fwrite-a-game-of-life-using-es6%2F</url>
    <content type="text"><![CDATA[GitHub 地址 缘起前段时间看了《Understanding ECMAScript 6》，因为有 JavaScript 的基础，很快就上手了，还写了 笔记。然而编程只看书是不够的，还需要让身体熟悉起来。刚好最近在看「全部成为 F」这部新番，看到 ED 采用了「生命游戏」的表现形式，于是便有了用 ES6 来写一个的主意。 「生命游戏」「生命游戏」的英文原文是「Game of Life」，是细胞自动机的一种形式，每个细胞的未来状态只取决于以其为中心周围八格细胞的当前状态。更详细的信息请看 wiki 条目，给出一个有意思的动画图。 而状态判断只有四条： 当前细胞为存活状态时，当周围低于 2 个（不包含 2 个）存活细胞时， 该细胞变成死亡状态。（模拟生命数量稀少） 当前细胞为存活状态时，当周围有 2 个或 3 个存活细胞时， 该细胞保持原样。 当前细胞为存活状态时，当周围有 3 个以上的存活细胞时，该细胞变成死亡状态。（模拟生命数量过多） 当前细胞为死亡状态时，当周围有 3 个存活细胞时，该细胞变成存活状态。 （模拟繁殖） 算法思考假设有一个棋盘，每一个格子代表一个细胞。在每一次生成下一代细胞，先遍历每一个细胞，查询它周围八格细胞的状态，设置本细胞下一代的状态。 显然这样的算法基本毫无意义，因为显然棋盘是不定大小的，细胞也不是每一代都一定会变化的，遍历整个棋盘也是浪费时间的。 实际上，发生变化或者有可能发生变化的细胞，基本是聚集在活细胞周围的。如果一个死细胞附近没有活细胞，那么这个细胞就不会发生变化。所以，可以换个思路，每一个曾经活过或者在活细胞周围的细胞都维持一个它的邻居细胞的数目记录。每当一个细胞活过来了，就通知周围八格的细胞，让它们的活邻居细胞的数目记录增加 1；相反每当一个细胞死了，就通知周围八格的细胞，让它们的活邻居细胞的数目记录减少 1。显然在更新完之后，周围八格的细胞不论生死都清楚自己周围的活细胞数，也就是能够得到自己的未来状态了。同时，在通知周围八个邻居的时候，也可以统计出对于本细胞来说的活邻居数，于是本细胞的未来状态也能够得到了。 于是算法能描述如下： 1234567891011121) 在某一次生成本次状态中，有将改变状态的细胞集合 S2) 遍历集合 S，对于细胞 i： 改变细胞 i 的状态 细胞 i 的活邻居数置零 遍历 8 个邻居细胞，对于邻居细胞 j： 如果细胞 i 改变后的状态 == 存活，细胞 j 的活邻居数增加 1 如果细胞 i 改变后的状态 == 死亡，细胞 j 的活邻居数减少 1 计算细胞 j 的未来状态并记录在将改变状态的细胞集合 S&apos; 中 如果细胞 j 是活细胞： 细胞 i 的活邻居数增加 1 计算细胞 i 的未来状态并记录在将改变状态的细胞集合 S&apos; 中3)S = S&apos;，重复 1)、2) ES6 写起来ES6 中有 class 的概念，虽然实现方式其实就是 function 和原型，但是在写的时候就不用像以前用「模拟」的手段来编写啦。 基本对象基本来说，分三个主要对象：提供算法的 class Life，提供单元格绘制的 class Grid，提供 DOM 动画控制的 class Game。Game 从算法中得到需要重绘的单元格，通过 Grid 来绘制单元格。 class Life已经有算法描述了，写起来并不复杂。新建一个 life.js 文件，导出 Life 类。 123456789101112131415161718192021222324export default class Life &#123; constructor ( row, col ) &#123; this.row = row; this.column = col; this.generation = 0; /* * this.world = &#123; * '0,0': // 'x,y' * [ * 1, // alive 1, dead 0 * 0, // count of neighbour * ] * &#125; */ this.world = &#123;&#125;; /* * '0,0': // 'x,y' * 1 // to be alive 1, to be dead -1, 0 not change */ this.changedState = &#123;&#125;; &#125;&#125; 构造函数只需要得到世界（棋盘）的长宽就行了，this.world 记录世界中受关注细胞的状态，this.changedState 记录将要改变状态的细胞。 算法本体代码，相当于描述 2) 中循环中的操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788_processLife ( x, y, state ) &#123; let currentCellHash = x + ',' + y; if ( this.world[currentCellHash] ) &#123; // 根据 state 改变状态 this.world[currentCellHash][0] = state ? 1 : 0; &#125; else &#123; // 如果世界中不存在记录，则肯定是新的活细胞 this.world[currentCellHash] = [1, 0]; &#125; // 更新邻居细胞并统计活邻居数 let aliveNeighBours = 0; let neighbours = [ // 左边的邻居 [x - 1, y - 1], [x - 1, y], [x - 1, y + 1], // 上下邻居 [x, y - 1], [x, y + 1], // 右边的邻居 [x + 1, y - 1], [x + 1, y], [x + 1, y + 1], ]; let counter = state ? +1 : -1; // 循环 8 个邻居 for ( let i = 0; i &lt; 8; i++ ) &#123; let [nx, ny] = neighbours[i]; // 一些世界中的约束 if ( 0 &lt;= nx &amp;&amp; nx &lt; this.column &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; this.row ) &#123; let hash = nx + ',' + ny; let oldState = this.world[hash]; // oldState[0] alive or dead, oldState[1] count of neighbour if ( oldState ) &#123; // 邻居已经存在于世界中了 oldState[1] += counter; // 更新邻居的邻居数 // 顺便统计活邻居数 if ( oldState[0] ) &#123; aliveNeighBours++; &#125; &#125; else &#123; // 边缘开拓新的细胞，肯定是死细胞 oldState = this.world[hash] = [0, 1]; &#125; // 计算邻居细胞的未来状态 switch ( oldState[1] ) &#123; case 8: case 7: case 6: case 5: case 4: case 1: case 0: this.changedState[hash] = -1; // if alive, then to be dead break; case 3: this.changedState[hash] = 1; // if dead, then to be alive break; case 2: this.changedState[hash] = 0; break; &#125; &#125; &#125; // 计算当前细胞的未来状态 this.world[currentCellHash][1] = aliveNeighBours; switch ( aliveNeighBours ) &#123; case 8: case 7: case 6: case 5: case 4: case 1: case 0: this.changedState[currentCellHash] = -1; // if alive, then to be dead break; case 3: this.changedState[currentCellHash] = 1; // if dead, then to be alive break; case 2: this.changedState[currentCellHash] = 0; break; &#125;&#125; 2) 的循环其实就是得到下一代的状态： 123456789101112131415161718192021nextGeneration () &#123; let state = Object.assign( &#123;&#125;, this.changedState ); // 复制将要改变的状态集以便清空 let changedCells = &#123; 0: [], 1:[] &#125;; // reset next state this.changedState = &#123;&#125;; // 2) 的循环 for ( let key in state ) &#123; let [x, y] = key.split( ',' ).map( x =&gt; parseInt( x ) ); if ( state[key] === 1 &amp;&amp; ( !this.world[key] || this.world[key][0] === 0 ) ) &#123; this.aliveAt( x, y ); // 会调用 _processLife( x, y, true ) changedCells[1].push( [x, y] ); // 记录重绘的细胞 &#125; if ( state[key] === -1 &amp;&amp; this.world[key][0] === 1 ) &#123; this.killAt( x, y ); // 会调用 _processLife( x, y, false ) changedCells[0].push( [x, y] ); // 记录重绘的细胞 &#125; &#125; return changedCells;&#125; 其他函数可以在 GiiHub 查看。 class Grid确定使用 HTML5 中的 Canvas 元素来绘制整个世界（棋盘），Canvas 元素的操作使用另一个类 C，后面再写。 新建 grid.js 文件，导出 Grid 类。 123456789export default class Grid &#123; constructor ( canvas, row, col, displayScheme, colorScheme ) &#123; this.view = canvas; this.canvas = new C( canvas ); this.displayScheme = displayScheme; this.colorScheme = colorScheme; &#125;&#125; 构造函数要传入 canvas DOM 元素，棋盘的长宽，显示的选项和颜色选项。 绘制单元格的主要函数。 1234567891011121314151617181920212223drawCells( redrawCells ) &#123; // draw alive cells this.canvas.setPenColor( this.colorScheme.aliveColor ); for ( let x, y, i = 0, len = redrawCells[1].length; i &lt; len; i++ ) &#123; [x, y] = redrawCells[1][i]; this.drawCellAt( x, y ); &#125; // draw dead cells this.canvas.setPenColor( this.colorScheme.deadColor ); for ( let x, y, i = 0, len = redrawCells[0].length; i &lt; len; i++ ) &#123; [x, y] = redrawCells[0][i]; this.drawCellAt( x, y ); &#125;&#125;drawCellAt ( x, y ) &#123; this.canvas.drawRect( x * ( this.displayScheme.borderWidth + this.displayScheme.cellWidth ), y * ( this.displayScheme.borderWidth + this.displayScheme.cellWidth ), this.displayScheme.cellWidth, this.displayScheme.cellWidth );&#125; drawCells 函数是用来批量画细胞的函数，同样颜色的细胞放在一起画，就不需要频繁改变画笔的颜色。 drawCellAt 函数就是找到单元格的左上角距离 Canvas 元素左上角的距离，距离左边是第 x 个细胞宽度加细胞边框宽度，距离上边也是同样道理。 其中调用的 setPenColor 和 drawRect 还没有，于是就新增一个 c.js 文件，导出 C 类。其实就是 Canvas 元素的操作的封装而已。 123456789101112131415161718export default class C &#123; constructor ( ele ) &#123; this.cxt = ele.getContext( '2d' ); this.fillStyle = '#000000'; &#125; setPenColor ( hex ) &#123; this.cxt.fillStyle = this.fillStyle = '#' + hex; &#125; drawRect ( ox, oy, width, height ) &#123; this.cxt.fillRect( ox, oy, width, height ); &#125; clear () &#123; this.cxt.clearRect( 0, 0, this.cxt.canvas.width, this.cxt.canvas.height ); &#125;&#125; class Game不复杂，直接看代码吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import Life from './life.js';import Grid from './grid.js';export default class Game &#123; constructor ( canvas, row, col, displayScheme, colorScheme, gps ) &#123; this.grid = new Grid( canvas, row, col, displayScheme, colorScheme ); this.life = new Life( row, col ); this.speed = 1000 / gps; this.enable = false; this.running = false; &#125; init ( x ) &#123; this.stop(); this.life.init( x ); this.grid.init(); this.enable = true; &#125; stop () &#123; this.running = false; this.enable = false; this.life.reset(); this.grid.claer(); &#125; pause () &#123; if ( this.enable ) &#123; this.running = false; &#125; &#125; resume () &#123; if ( this.enable ) &#123; this.run(); &#125; &#125; step () &#123; if ( this.enable ) &#123; // run algorithm let redrawCells = this.life.nextGeneration(); // redraw cells this.grid.drawCells( redrawCells ); &#125; &#125; run () &#123; if ( this.enable &amp;&amp; !this.running ) &#123; this.running = true; let _run = () =&gt; &#123; if ( this.running ) &#123; this.step(); setTimeout( _run, this.speed ); &#125; &#125;; setTimeout( _run, 0 ); &#125; &#125;&#125; 就是一些简单的动画控制方法，跟普通 JavaScript 写起来没什么不同。需要注意的是 enable 状态和 running 状态是不一样的，前者是指整个游戏的响应，后者是指动画的响应。 step 方法是迭代一步，run 方法就是用 setTimeout 来循环调用 step 了。在 run 方法中使用了箭头函数来隐含设定了 this 的值，ES6 的优势就体现出来了。 gol.js整个程序的主体是 Game 的实例，然而还是需要有人去创造一个实例出来，也就是说需要一个工厂函数。于是，新建 gol.js 文件，导出 GOL 类。里面写一个静态方法，用作创建 Game 实例的工厂方法。 123456789101112131415161718192021import Game from './game.js';export default class GOL &#123; static createGame ( canvas, row, col, options ) &#123; let param = Object.assign( &#123; displayScheme: &#123; borderWidth: 1, cellWidth: 10 &#125;, colorScheme: &#123; aliveColor: '000000', deadColor: 'FFFFFF', worldColor: 'FFFFFF', borderColor: 'FFFFFF' &#125;, gps: 15 &#125;, options ); return new Game( canvas, row, col, param.displayScheme, param.colorScheme, param.gps ); &#125;&#125; 不过在 createGame 方法上就不要用 ES6 的语法了，因为方法是要在页面上调用的，目前还没有哪个浏览器完全支持 ES6。但是在方法里面用是没问题的，因为编译器会帮我们转换好。于是可以看到方法里面直接用 Object.assign( des, src ) 的函数来合并参数，类似 jQuery 的 extends 函数。 boot.js到此还没完，回忆一下在写普通 JavaScript 库的时候，我们通常会直接包裹上一层适应各种环境的模块注册代码，本人最喜欢就是直接使用 UMD 了。 新建 boot.js 文件，执行非 ES6 形式的导出。 123456789101112131415import GOL from './gol.js';(function ( root, name, definition ) &#123; if ( typeof define === 'function' &amp;&amp; define.amd ) &#123; define( [], function () &#123; return ( root[name] = definition( root ) ); &#125;); &#125; else if ( typeof module === 'object' &amp;&amp; module.exports ) &#123; module.exports = definition( root ); &#125; else &#123; root[name] = definition( root ); &#125;&#125;)( window, 'GOL', function ( root ) &#123; return GOL;&#125;); 代码打包OK，到此代码基本写好了，然而到在浏览器上执行还是有一段距离，主要是基本没有浏览器默认支持 ES6，我们还是需要将 ES6 的代码编译一下以便能放到浏览器上运行。比较有名的编译器就是 Babel 和 Google 的 Traceur 了。在编译的同时，还需要将所有文件打包成 bundle。 在进行了各种尝试之后（包括主流的 npm / browserify / jspm 等），最后发现使用 webpack 和 Babel 的结合是比较理想的。 配置先来把需要的东西都装上。 1npm i --save-dev webpack babel babel-core babel-loader babel-preset-es2015 个人其实非常讨厌安装到本地，明明都是可以全局安装的插件和工具。而且每次开一个新的项目就要安装几十 MB 的重复东西实在无聊，npm 本身的树状依赖也是容易造成目录过深的情况。（据说新版 npm 有改善，但是不稳定）个人的解决方法是固定一个开发目录，代码随便迁移。 webpack.config.jswebpack 我就不详细解释了。直接上 webpack.config.js。 12345678910111213141516171819module.exports = &#123; entry: './src/boot.js', output: &#123; path: __dirname, filename: './dist/bundle.js' &#125;, module: &#123; loaders: [ &#123; test: /\.js$/, loader: 'babel', query: &#123; cacheDirectory: true, presets: ['es2015'] &#125; &#125; ] &#125;&#125;; 目前来说，这样写就能让 Babel 编译 ES6 的代码的同时，也运用 webpack 自己的打包功能 根据 ES6 的模块语法 将文件都打包成一个 bundle。 打包出来的代码有点大，压缩一下，再写一个 webpack.config.min.js。 123456// webpack.config.min.jsvar webpack = require("webpack");module.exports = exports = Object.create(require("./webpack.config.js"));exports.plugins = [new webpack.optimize.UglifyJsPlugin()];exports.output = Object.create(exports.output);exports.output.filename = exports.output.filename.replace(/\.js$/, ".min.js"); 就能用 webpack 自带的压缩插件压缩代码了。 添加功能算法、绘图和动画控制都写好了，但是还不够，缺少了交互，还应该允许方便的自定义世界中的活细胞。比较好的交互方式就是允许通过在世界（棋盘）点击来放置活细胞或者死细胞。 于是考虑监听 Canvas 元素的 mousedown、mousemove 和 mouseup 事件，做出类似画图那样的效果（每个细胞可以看成是一个像素点）。 grid.js先改造负责绘制的模块。 在 Grid 类中新增 drawAliveCellAt、drawDeadCellAt 函数，负责独立绘制细胞。 123456789drawAliveCellAt( x, y ) &#123; this.canvas.setPenColor( this.colorScheme.aliveColor ); this.drawCellAt( x, y );&#125;drawDeadCellAt( x, y ) &#123; this.canvas.setPenColor( this.colorScheme.deadColor ); this.drawCellAt( x, y );&#125; 新增 on、off 函数，负责绑定监听方法。 1234567on ( event, handler ) &#123; this.view.addEventListener( event, handler, false );&#125;off ( event, handler ) &#123; this.view.removeEventListener( event, handler );&#125; 新增 getXFromPixel、getYFromPixel 函数，负责将像素点转换为单元格位置。 1234567891011getXFromPixel ( pixel ) &#123; let d = this.displayScheme.borderWidth + this.displayScheme.cellWidth; let x = ~~( ( pixel - this.canvas.left ) / d ); return x % d &lt;= this.displayScheme.cellWidth ? x : -1;&#125;getYFromPixel ( pixel ) &#123; let d = this.displayScheme.borderWidth + this.displayScheme.cellWidth; let y = ~~( ( pixel - this.canvas.top ) / d ); return y % d &lt;= this.displayScheme.cellWidth ? y : -1;&#125; ~~ 是快速取整数。this.canvas.left 和 this.canvas.top 来自于类 C 的实例，因为鼠标点击事件取得的坐标点并非一定是相对于 Canvas 元素的左上角，还要减去 Canvas 元素的边框等。在 c.js 中将构造函数修改一下。 123456constructor ( ele ) &#123; this.cxt = ele.getContext( '2d' ); this.fillStyle = '#000000'; this.left = ele.getBoundingClientRect().left; this.top = ele.getBoundingClientRect().top;&#125; game.js类 Game 的修改有点复杂。先在类的构造函数中增加一个属性，负责记录鼠标状态。 12345this._mouseState = &#123; press: false, lastX: -1, lastY: -1&#125;; 再增加三个方法。 123456789101112131415_onMouseDown ( e ) &#123; this._mouseState.press = true; this._toggleCell( e.clientX, e.clientY );&#125;_onMouseMove ( e ) &#123; if ( this._mouseState.press ) &#123; this._toggleCell( e.clientX, e.clientY ); &#125;&#125;_onMouseUp ( e ) &#123; this._mouseState.press = false; this._mouseState.lastX = this._mouseState.lastY = -1;&#125; 鼠标按下，就在鼠标按下的位置改变细胞的状态，并记录鼠标状态为按下。接着如果鼠标弹起，那么就重置鼠标状态；如果鼠标移动并且状态是按下，那么就一直改变路过的细胞的状态。 _toggleCell 方法这样写： 12345678910111213141516_toggleCell ( px, py ) &#123; let x = this.grid.getXFromPixel( px ); let y = this.grid.getYFromPixel( py ); if ( x !== -1 &amp;&amp; y !== -1 &amp;&amp; ( this._mouseState.lastX !== x || this._mouseState.lastY !== y ) ) &#123; this._mouseState.lastX = x; this._mouseState.lastY = y; if ( this.life.isAlive( x, y ) ) &#123; this.life.killAt( x, y ); this.grid.drawDeadCellAt( x, y ); &#125; else &#123; this.life.aliveAt( x, y ); this.grid.drawAliveCellAt( x, y ); &#125; &#125;&#125; 大概意思就是先将鼠标的位置转化为单元格位置，再反置此单元格细胞的状态。记录下 lastX 和 lastY 是为了不会循环反置，一定要有坐标变化才反置。 接下来就是将那三个函数绑定在事件上。新增 _setupLinsteners 函数。 12345_setupLinsteners () &#123; this.grid.on( 'mousedown', e =&gt; this._onMouseDown( e ); this.grid.on( 'mousemove', e =&gt; this._onMouseMove( e ); this.grid.on( 'mouseup', e =&gt; this._onMouseUp( e );&#125; 虽然使用了箭头函数优雅地绑定了 this 的值，但是这样写并不好，因为没办法解绑了，容易造成内存泄漏。改一下。 1234567891011121314151617_setupLinsteners () &#123; this._boundMethod['_onMouseDown'] = e =&gt; this._onMouseDown( e ); this._boundMethod['_onMouseMove'] = e =&gt; this._onMouseMove( e ); this._boundMethod['_onMouseUp'] = e =&gt; this._onMouseUp( e ); this.grid.on( 'mousedown', this._boundMethod['_onMouseDown'] ); this.grid.on( 'mousemove', this._boundMethod['_onMouseMove'] ); this.grid.on( 'mouseup', this._boundMethod['_onMouseUp'] );&#125;_teardownLinsteners () &#123; this.grid.off( 'mousedown', this._boundMethod['_onMouseDown'] ); this.grid.off( 'mousemove', this._boundMethod['_onMouseMove'] ); this.grid.off( 'mouseup', this._boundMethod['_onMouseUp'] ); this._boundMethod = &#123;&#125;;&#125; 通过将匿名函数的引用保存起来就能解绑了。 最后给个 demo 吧。或者玩玩 在线 demo 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Game of Life&lt;/title&gt; &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;grid&quot; width=&quot;1000&quot; height=&quot;500&quot; style=&quot;border:1px solid&quot;&gt;&lt;/canvas&gt; &lt;button onclick=&quot;test()&quot;&gt;init&lt;/button&gt; &lt;button onclick=&quot;g.step()&quot;&gt;setp&lt;/button&gt; &lt;button onclick=&quot;g.run()&quot;&gt;run&lt;/button&gt; &lt;button onclick=&quot;g.stop()&quot;&gt;stop&lt;/button&gt; &lt;button onclick=&quot;g.pause()&quot;&gt;pause&lt;/button&gt; &lt;button onclick=&quot;g.resume()&quot;&gt;resume&lt;/button&gt; &lt;script&gt;var options = &#123; displayScheme: &#123; borderWidth: 1, cellWidth: 4 &#125;, colorScheme: &#123; aliveColor: &apos;000000&apos;, deadColor: &apos;efefef&apos;, worldColor: &apos;ffffff&apos; &#125;&#125;;var g=GOL.createGame(document.getElementById(&apos;grid&apos;), 100, 200, options);function test()&#123; g.init([[10,10],[11,10],[10,11],[13,12],[12,13],[13,13]]); g.step();&#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ECMAScript6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Understanding ECMAScript 6》笔记]]></title>
    <url>%2Funderstanding-ecmascript6-note%2F</url>
    <content type="text"><![CDATA[在线免费阅读：https://leanpub.com/understandinges6/read/ 部分代码使用原书，代码版权归原书所有 块级绑定（Block Bindings） 字符串 正则 字符串模板（template strings） 标签模板（tagged templates） 函数 对象 解构（Destructuring） Symbols 生成器（Generators） 迭代器（Iterators） 类 Promises 模块（Modules） 杂七杂八 块级绑定（Block Bindings）↑let块级{}中有效 同块级不可重复声明 没有变量提升 块级会形成暂时性死区（TDZ，Temporal Dead Zone） const基本和 let 相同，值不可修改 let 和 const 最好不要在全局下使用 字符串↑unicode 支持更好新增部分函数，支持双字节codePointAt，双字节版的 charCodeAt，得到字符 unicode fromCodePoint，双字节版的 fromCharCode，从 unicode 得出字符 includes，包含某字符串 startsWith，以某字符串开始 endsWith，以某字符串结束 repeat，重复字符串 normalize，unicode 正规化，举个例子：两个 unicode 字符合成一个 正则↑新增标志 u正则识别 unicode 字符 新增标志 ysticky，部分浏览器早就实现了 字符串模板（template strings）↑123let a = 1let b = 2let s = `$&#123;a&#125; $&#123;a + b&#125;` // '1 3' 标签模板（tagged templates）↑123456789let a = 1function tag ( strings, ...values ) &#123; console.log( strings ) console.log( values ) return values[0]&#125;let s = tag`a $&#123;a&#125;` // 'a 1'// ["a ", "", raw: Array[2]]// [1] 函数↑默认参数123function foo ( bar = 1 ) &#123; console.log( bar )&#125; 剩余参数1234567function foo ( bar, ...rest ) &#123; // ✓ ;&#125;function foo ( bar, ...rest, last ) &#123; // × ;&#125; 函数属性 name各种例子 1234567891011121314151617181920212223242526272829function doSomething() &#123; // ...&#125;console.log( doSomething.name ); // "doSomething"var doAnotherThing = function () &#123; // ...&#125;;console.log( doAnotherThing.name ); // "doAnotherThing"var doSomethingAgain = function doSomethingElse () &#123; // ...&#125;;console.log( doSomethingAgain.name ); // "doSomethingElse"var person = &#123; get firstName () &#123; return "Nicholas" &#125;, sayName: function () &#123; console.log( this.name ); &#125;&#125;console.log( person.sayName.name ); // "sayName"console.log( person.firstName.name ); // "get firstName"console.log( doSomething.bind().name ); // "bound doSomething"console.log( ( new Function() ).name ); // "anonymous" new.target避免了很多使用 new 的坑 12345678910function Foo () &#123; if ( typeof new.target !== "undefined" ) &#123; console.log( 'good' ); // using new &#125; else &#123; throw new Error( 'You must use new with Person.' ) // not using new &#125;&#125;var foo = new Foo(); // goodfoo = Foo.call( foo ); // error! 块级函数块级中可定义函数 箭头函数this, super, arguments 和 new.target 的值都在定义函数时绑定而非运行时绑定 不可 new 不可改变 this 的值 没有 arguments 跟普通函数一样拥有 name 属性 1234var foo = value =&gt; value; // input value, output valuevar foo = () =&gt; &#123;&#125;;var foo = ( x, y ) =&gt; x + y;var foo = id =&gt; (&#123; x: 'x' &#125;); 1234567891011121314151617// this 的绑定var foo = &#123; init: function () &#123; document.addEventListener( 'click', (function ( e ) &#123; console.log( e.type ); &#125;).bind( this ), false); &#125;&#125;;// ------------------------var foo = &#123; init: function () &#123; document.addEventListener( 'click', e =&gt; &#123;console.log( e.type )&#125;, false); &#125;&#125;; 立即调用函数表达式（Immediately-Invoked Function Expressions (IIFEs)）123456789let foo = function ( s ) &#123; console.log( s );&#125;( 'text' ) // text// -------------------------let foo = ( s =&gt; &#123; console.log( s );&#125;)( 'text' ) // text 新增尾递归优化 对象↑对象字面属性值简写（Property Initializer Shorthand）12345function foo ( text ) &#123; return &#123; name // name: name &#125;&#125; 对象方法简写（Method Initializer Shorthand）123var foo = &#123; bar () &#123;&#125;&#125; 计算属性名语法对象的属性可以使用中括号 [] 表示需要「被计算」，结果转换为字符串作为属性名使用。 1234567let a = function () &#123;&#125;let foo = &#123; a: 'text a', [a]: 'function a'&#125;console.log( foo['a'] ) // text aconsole.log( foo[a] ) // function a Object.is()和经典的 === 几乎一样，区别在于： 12345console.log( +0 === -0); // trueconsole.log( Object.is( +0, -0 ) ); // falseconsole.log( NaN === NaN ); // falseconsole.log( Object.is( NaN, NaN ) ); // true Object.assign()1Object.assign( target, ...source ) 读取源对象可列举的、自身的属性，将其赋值到目标对象上，覆盖旧属性，并非通常意义的复制。 复制存取器属性 此小节查询 MDN 后补充上 使用 Object.getOwnPropertyDescriptor(source, key) 读取，使用 Object.defineProperties 定义。 属性允许重复定义属性以最后一个定义的值为准 修改原型Object.getPrototypeOf，得到原型 Object.setPrototypeOf，设置原型 super用以访问对象的 prototype 解构（Destructuring）↑123456789var &#123;a, b: &#123; c, d &#125;&#125; = c( &#123;a, b: &#123; c, d &#125;&#125; = c )var [a, [b, c]] = dvar [a, , [b, c]] = d // 跳过一个function foo ( &#123; bar1, bar2 &#125; = &#123;&#125; ) &#123; ;&#125; 解构可以有默认值，但只会在需要的时候求值。 2ality 有更详细清晰的解释： 123456let &#123;prop: y=someFunc()&#125; = someValue;let x, y;[x=3, y=x] = []; // x=3; y=3[x=3, y=x] = [7]; // x=7; y=7[x=3, y=x] = [7, 2]; // x=7; y=2 Symbols（不知道如何翻译，是第七种原始类型）↑12var foo = Symbol()var foo = Symbol( 'bar' ) Symbol( &#39;description&#39; ) 生成局部 Symbol，即使 description 相同生成的 Symbol 也不一样 Symbol.for( &#39;description&#39; ) 生成全局 Symbol，description 相同则 Symbol 相同 获取对象的 Symbol 数组Object.getOwnPropertySymbols( object ) 强制转换 Symbol 为 String 原书本节未完成 有名的预定义 Symbol 原书本节大部分未完成 生成器（Generators）↑生成迭代器的函数 123456789101112131415function *createIterator() &#123; yield 1; yield 2; yield 3;&#125;var o = &#123; *createIterator ( items ) &#123; for ( let i=0; i &lt; items.length; i++ ) &#123; yield items[i]; &#125; &#125;&#125;;let iterator = o.createIterator( [1, 2, 3] ); 迭代器（Iterators）↑for-of 语法数组、字符串、映射（Map）、集合（Set）和元素数组（NodeList）都可迭代（iterable），可使用 for-of 语法 得到内置迭代器Symbol.iterator 指向得到迭代器的函数 123let values = [1, 2, 3];let iterator = values[Symbol.iterator]();iterator.next(); // 1 自定义迭代器123456let collection = &#123; items: [], *[Symbol.iterator]() &#123; yield *this.items.values(); // `yield *` 语法，委托了数组 `items` 的内置迭代器 &#125;&#125;; 对象、数组、映射、集合都具有的默认迭代器ertries()，返回键值对迭代器 keys()，返回键迭代器 values()，返回值迭代器 字符串迭代器通过 [] 的访问是 code unit 方式 通过迭代器则是字符方式（几乎是，某些 unicode 支持不足） 元素数组（NodeList）迭代器返回的是数组中的单个元素 向迭代器传参数12345678910function *foo () &#123; let bar = yield 1;&#125;let it = foo()console.log( it.next() ) // Object &#123;value: 1, done: false&#125;，执行语句 `yield 1` 然后暂停console.log( it.next( 2 ) ) // Object &#123;value: undefined, done: true&#125;，将 2 作为 `yield 1` 的返回值， // 迭代器内部继续执行语句 `let bar = 2`， // 之后执行完毕，无返回值，`value` 为 `undefined`，`done` 为 `true`console.log( it.next() ) // Object &#123;value: undefined, done: true&#125; 生成器使用 return 提前返回1234567891011function *createIterator() &#123; yield 1; return 42; yield 2;&#125;let iterator = createIterator();console.log(iterator.next()); // "&#123; value: 1, done: false &#125;"console.log(iterator.next()); // "&#123; value: 42, done: true &#125;"console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;" 委托生成器使用 yield * 12345678910111213141516171819202122232425function *createNumberIterator() &#123; yield 1; yield 2; return 3;&#125;function *createRepeatingIterator(count) &#123; for (let i=0; i &lt; count; i++) &#123; yield "repeat"; &#125;&#125;function *createCombinedIterator() &#123; let result = yield *createNumberIterator(); yield *createRepeatingIterator(result);&#125;var iterator = createCombinedIterator();console.log(iterator.next()); // "&#123; value: 1, done: false &#125;"console.log(iterator.next()); // "&#123; value: 2, done: false &#125;"console.log(iterator.next()); // "&#123; value: "repeat", done: false &#125;"console.log(iterator.next()); // "&#123; value: "repeat", done: false &#125;"console.log(iterator.next()); // "&#123; value: "repeat", done: false &#125;"console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;" 可以 yield *&quot;string&quot;，会调用字符串的默认迭代器 123456function *foo () &#123; yield * "hello"&#125;let it = foo()console.log( it.next() ) // Object &#123;value: "h", done: false&#125;console.log( it.next() ) // Object &#123;value: "e", done: false&#125; 异步任务调度以下是书中的例子，写得并不好，变量 task 的管理容易出问题： 12345678910111213141516171819202122var fs = require("fs");var task;function readConfigFile() &#123; fs.readFile("config.json", function(err, contents) &#123; if (err) &#123; task.throw(err); &#125; else &#123; task.next(contents); &#125; &#125;);&#125;function *init() &#123; var contents = yield readConfigFile(); doSomethingWith(contents); console.log("Done");&#125;task = init();task.next(); 类↑类声明12345678910class foo &#123; // 相当于构造函数 constructor ( name ) &#123; this.name = name; &#125; // 相当于 foo.prototype.bar bar () &#123; console.log( this.name ); &#125;&#125; 类的属性最好都在构造函数里面创建。 类声明本质上就是以前的函数声明，除了以下有所不同： 类声明不会像函数声明那样被提升 类内部的代码全部以 strict mode 运行 所有方法都是不可列举的，相当于使用了 Object.defineProperty() 不使用 new 会抛异常 以类名命名方法来覆盖类名会抛异常（类名对于类内部来说是以 const 定义的，对于外部则不是） 类表达式1let foo = class &#123;&#125; 1let foo = class foo2 &#123;&#125; // foo === foo2 匿名类作为参数 123456789function createFoo ( c ) &#123; return new c()&#125;createFoo( class &#123; constructor () &#123; ; &#125;&#125;) 立即调用类表达式（有点像立即调用函数表达式） 12345let foo = new class &#123; constructor ( name ) &#123; this.name = name &#125;&#125;( 'foo' ) 存取器属性12345678910111213class foo &#123; constructor ( name ) &#123; this.name = name &#125; get className () &#123; return 'class ' + this.name &#125; set className ( value ) &#123; this.name = 'class' + value &#125;&#125; 静态成员1234567891011121314151617181920class foo &#123; constructor ( name ) &#123; this.name = name &#125; // 相当于 foo.prototype.bar bar () &#123; console.log( this.name ) &#125; // 相当于 foo.staticBar static staticBar () &#123; console.log( this.name ) &#125; // get / set 也可以用 static get barName () &#123; return 'bar' &#125;&#125; 静态成员同样不可列举 派生类比起 ECMAScript5，ECMAScript6 的派生方便了很多 12345678910111213141516class Rectangle &#123; constructor ( length, width ) &#123; this.length = length; this.width = width; &#125; getArea () &#123; return this.length * this.width; &#125;&#125;class Square extends Rectangle &#123; constructor ( length ) &#123; super( length, length ); &#125;&#125; 在派生类的构造函数中，调用 super 是必须的。如果连构造函数都没有，则： 12345678910class Square extends Rectangle &#123; // 无构造函数&#125;// 相当于class Square extends Rectangle &#123; constructor ( ...args ) &#123; super( ...args ) &#125;&#125; 只能在派生类中用 super() 使用 this 前必先调用 super() 来初始化 this 只有在构造函数返回一个对象的时候才可以不用 super() 类方法覆盖、隐藏父类方法 12345678class Square extends Rectangle &#123; constructor ( length ) &#123; super( length, length ); &#125; getArea () &#123; return this.length * this.length; &#125;&#125; 仍然可以使用 super 调用父类方法 12345678class Square extends Rectangle &#123; constructor ( length ) &#123; super( length, length ); &#125; getArea () &#123; return super.getArea(); &#125;&#125; 类方法没有 [[Construct]] 这个内部方法，所以不能被 new。（什么是[[Construct]]） 静态成员相当于 ES5 中定义在构造函数上的方法（注意不是定义在构造函数的原型上），派生类显然也能调用 extends 关键字后面可以使用表达式除了 null 和生成器函数外 12345678910111213141516171819202122232425262728// 使用函数function base () &#123;&#125;class foo extends base &#123;&#125;// 使用表达式function base () &#123;&#125;function getBase () &#123; return base&#125;class foo extends getBase() &#123;&#125;// 混合模式（多继承？!）let AMinin = &#123; aF = function () &#123;&#125;&#125;let BMinin = &#123; bF = function () &#123;&#125;&#125;function mixin ( ...mixins ) &#123; var base = function () &#123;&#125; Object.assign( base.prototype, ...mixins ) return base&#125;class foo extends mixin( AMinin, BMinin ) &#123;&#125;// 内置类型class foo extends Array &#123;&#125;class foo extends String &#123;&#125; new.target能够得知类的调用状态，应用例如：阻止抽象类被实例化 1234567class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error("This class cannot be instantiated directly.") &#125; &#125;&#125; Promises↑Promise 是老朋友了，所以没有什么好记录的，就记一下语法。 1234567891011121314151617let p1 = new Promise( function ( resolve, reject ) &#123; resolve( 42 );&#125;);let p2 = Promise.resolve( 42 );let p3 = Promise.reject( 43 );let p4 = Promise.all( [p1, p2, p3] ); // 等待所有 Promise 返回let p5 = Promise.race( [p1, p2, p3] ); // 最快的一个 Promise 返回就返回p4.then( function ( value ) &#123; console.log( value );&#125;).catch( function ( value ) &#123; console.log( value );&#125;) 模块（Modules）↑ 注：本章的代码似乎有一些问题，基本参考 MDN 为准 模块中的代码自动以严格模式运行 模块中的顶层变量只是模块中顶层，并非全局顶层 顶层中的 this 的值为 undefined 代码中不允许 HTML 风格的注释 模块必须有导出的东西 基本导入导出直接使用原书代码： 12345678910111213141516171819202122232425262728293031// 导出数据export var color = "red";export let name = "Nicholas";export const magicNumber = 7;// 导出函数export function sum(num1, num2) &#123; return num1 + num1;&#125;// 导出类export class Rectangle &#123; constructor(length, width) &#123; this.length = length; this.width = width; &#125;&#125;// 导出引用function multiply(num1, num2) &#123; return num1 * num2;&#125;export multiply;// 默认导出export default function () &#123; return;&#125;// export asexport &#123; multiply as foo &#125; 除非使用 default 语法，否则函数和类都不能使用匿名 export 只能用在顶层中 as 和 default 语法的情况，给出一个来自 2ality 的表格 Statement Local name Export name export {v as x}; ‘v’ ‘x’ export default function f() {} ‘f’ ‘default’ export default function () {} ‘default‘ ‘default’ export default 123; ‘default‘ ‘default’ 可以看出，所谓的默认导出其实就是用了 default 作为名字罢了。 还能够将其他模块重新导出 Statement Module Import name Export name export {v} from ‘mod’; ‘mod’ ‘v’ ‘v’ export {v as x} from ‘mod’; ‘mod’ ‘v’ ‘x’ export * from ‘mod’; ‘mod’ ‘*’ null 导入有很多方法，基本使用到的其实只有几种，以下来自 MDN： 12345678910import name from "module-name";import * as name from "module-name";import &#123; member &#125; from "module-name";import &#123; member as alias &#125; from "module-name";import &#123; member1 , member2 &#125; from "module-name";import &#123; member1 , member2 as alias2 , [...] &#125; from "module-name";import defaultMember, &#123; member [ , [...] ] &#125; from "module-name";import defaultMember, * as alias from "module-name";import defaultMember from "module-name";import "module-name"; 最后那种导入是相当于将代码执行了一次。通常可以用来做 polyfills 和 shims。 杂七杂八↑Number.isInteger，判断整数 Number.isSafeInteger，判断是否是有效整数 Math 中加入很多函数，例如双曲正弦、双曲余弦之类的]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ECMAScript6</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mocha + chai + Travis CI + Codecov 使用流程]]></title>
    <url>%2Fmocha-chai-travis-ci-codecov-workflow%2F</url>
    <content type="text"><![CDATA[mochaa feature-rich JavaScript test framework running on Node.js and the browser chaia BDD / TDD assertion library for node and the browser that can be delightfully paired with any javascript testing framework Travis CIFree continuous integration platform for GitHub projects CodecovContinuous Code Coverage 编写测试简单来说，就是使用 mocha 作为测试框架，chai 作为断言库，将项目交给 Travis CI 做自动测试，交给 Codecov 做覆盖率测试。 以我自己的项目 simpleTemplate.js 为例。 先给项目装上 mocha 和 chai。 1npm i mocha chai --save-dev 在 package.json 文件中添加测试脚本命令行。 123"scripts": &#123; "test": "mocha"&#125; 项目根目录新建文件 test.js。 引入 chai 以及三个要测试的库。 12345var expect = require( 'chai' ).expect;var bare = require( './simpleTemplate.bare.js' ), normal = require( './simpleTemplate.normal.js' ), advanced = require( './simpleTemplate.advanced.js' ); 定义必需的数据。 12345678910111213var testData = &#123; 'text1': 'mocha tastes good, chai tastes good too.', 'html': '&lt;hr&gt;', 'list': [1, 2, 3], 'objectList': [ &#123; 'name': 'a' &#125;, &#123; 'name': 'b' &#125;, &#123; 'name': 'c' &#125; ], 'obj': &#123; 'name': 'obj' &#125;, 'boolFalse': false, 'boolTrue': true&#125; mocha 用起来其实也不复杂，常用的就是使用 describe 定义一个项目，使用 it 来执行一项测试。 123456789describe( 'bare', function () &#123; describe( 'string template', function () &#123; it( 'should output correct string', function () &#123; var template = bare( '&lt;p&gt;&#123;=text1&#125;&lt;/p&gt;' ); expect( template.fill( testData ).render() ).to.equal( '&lt;p&gt;mocha tastes good, chai tastes good too.&lt;/p&gt;' ); &#125;); &#125;);&#125;); 这里就是定义了一个 bare 项，里面再定义一个 string template 项，然后在 it 的回调函数中写断言，第一个参数可以写上断言描述。如果断言失败，测试就会失败。 OK，执行 npm test，可以看到结果输出。 123456bare string template √ should output correct string1 passing (9ms) expect(...).to.equal(...) 就是用到了 chai 了。 剩下的测试编写就不再详述了，基本都一样。 自动测试去 Travis-CI 官网使用 github 帐号登录，开启对应项目的访问权限。 然后在 package.json 同目录（根目录）下，新建文件 .travis.yml，写入如下内容。 123language: node_jsnode_js: - &quot;0.12&quot; git push 一次，再访问 Travis-CI，会发现已经给你显示出测试结果了。 那么好了，测试通过，何不贴个奖章 show off 一下呢？ 在项目旁边有一个黑色加绿色的按钮，点一下，弹框中选择 markdown 格式，将代码贴进 readme，再 git push，去 github 的项目页一看，是不是高大上起来了呢？ 代码覆盖率代码覆盖率其实也没必要到 100%，只要不是太低的值就可以了。 去 Codecov 官网使用 github 帐号登录，开启对应项目的访问权限。 然后在 package.json 同目录（根目录）下的 .travis.yml 加入如下内容。 123456env: global: - CODECOV_TOKEN: your-uuidscript: - istanbul cover node_modules/mocha/bin/_mocha - cat ./coverage/coverage.json | node_modules/codecov.io/bin/codecov.io.js your-uuid 替换成开启项目时生成的 Repository Upload Token。 继续 git push 一次，再访问 Codecov 就可以看到项目的代码覆盖率了。 照样里添加上 badge，点击右边齿轮的 badge，就可以得到 markdown 代码了。 打完收工以后每次 push，都会自动运行测试和代码率覆盖统计，去查看一下就知道代码有没有错误或者改进了。 参考文章： Basic Front End Testing With Mocha &amp; Chai 折腾 Coffee + mocha + Travis-CI 单元测试与覆盖率报告 Example Node with Codecov]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>mocha</tag>
        <tag>chai</tag>
        <tag>测试</tag>
        <tag>travisci</tag>
        <tag>codecov</tag>
        <tag>持续交付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配合 angular 和 angular-material 来开发基于 electron 的应用 · 3-- 文件组织结构和开发流程]]></title>
    <url>%2Fbuild-application-with-angular-and-ng-material-based-on-electron-3-file-structure-and-workflow%2F</url>
    <content type="text"><![CDATA[文件组织结构良好的文件组织结构不仅能帮助我们更快地定位文件，更能配合开发工具形成流畅的开发流程，从而提高编程效率。 以下的目录和文件都放在存放应用的根目录 app 下。 package.jsonElectron 应用的配置文件，经常做 node 开发的人应该很熟悉了。稍微说明一下一些字段： name: 应用的名字，本项目就是 radioit 了 description: 应用的描述 version: 应用的版本号 author: 作者名字 email: 作者的邮箱 main.jsElectron 应用的入口点，可以在 package.json 的 main 字段自定义 node_modules/node 库的目录，一般不用手动管理，而是使用 npm 来安装和卸载库。 lib/存放 node 模块的目录。 src/存放源代码的目录。 src/css/存放待编译的 css 代码，比如本项目用的 .styl 文件。 src/modules/存放浏览器端的 javascript 源代码。 因为使用 AngularJS，所以此目录的结构就照搬 AngularJS 项目的结构。 通常来说有两种：按 service / controller / directive 分目录存放，按功能模块存放。 本项目选择按功能模块存放。 src/modules/entry.js供 browserify 打包的入口点。最终浏览器端的 javascript 代码会打包成一个名为 bundle.js 的文件。 static/css/存放编译好的 CSS 文件。 static/font/存放字体文件。因为 Electron 可以访问本地文件，所以自定义字体也基本不需要考虑网络传输问题。 static/image/存放图片文件。 static/js/存放客户端的 javascript 库，比如 jQuery，underscore，AngularJS 等。 static/js/bundle.jsbrowserify 编译 javascript 代码后输出的文件。 static/view/存放 HTML 模板文件或者包含 HTML 代码的文件。 开发流程 — node 相关有关 node 的开发，跟普通的项目并没有什么两样，需要什么库就直接使用 npm 安装，然后再代码中使用 require 就可以了。 然而虽然 Electron 为 webkit 内核提供了 io.js 的运行环境，但是最好还是避免在客户端（浏览器）的 javascript 代码内混杂需要 node 依赖的代码。换句话说，最好将需要 node 依赖的 javascript 代码和平常在网页中使用的 javascript 代码分开。这样做的好处是不会搞混相关的 API 和设计模式，毕竟 node 大部分时候都是用在服务端上的。 本项目将 node 相关的代码放在 lib/ 目录下，负责应用的业务逻辑，其既有可能被主进程所用，也有可能被渲染进程所用。node 相关的代码不需要编译合并。编写时在目录下新建 xxx.js 文件，写好需要 exports 的内容，在其他文件中则使用 require( &#39;./xxx.js&#39; ) 就可以了。 开发流程 — 界面相关因为界面的渲染采用 webkit 引擎，所以 javascript 的编写和网页开发没有分别。 在 package.json 的 scripts 字段中增加一条命令： 1"build:js": "browserify src/modules/entry.js -o static/js/bundle.js" 然后在编写好 javascript 代码的时候，执行 npm run build:js 进行编译。 CSS 的编译则是加入如下： 1"build:css": "stylus -u nib src/css/app.styl -o static/css/app.css" 最后需要运行应用来测试，增加命令： 12"test": "electron main.js 2&gt;&amp;1 | silence-chromium","start": "npm run build:js &amp;&amp; npm run build:css &amp;&amp; electron main.js 2&gt;&amp;1 | silence-chromium" 需要测试的时候使用 npm run test，需要运行则使用 npm run start 进行重新编译和运行。]]></content>
      <categories>
        <category>技术</category>
        <category>编程语言</category>
        <category>javascript</category>
        <category>electron</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>angularjs</tag>
        <tag>angular-material</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次奇怪的爬虫经历]]></title>
    <url>%2Fa-weird-experience-while-using-pyspider%2F</url>
    <content type="text"><![CDATA[前言由于某些原因，我需要去爬获取一些国家旅游景点的信息。 找到国家旅游局的网站，然后找到一个 5A 风景区目录。 网址：http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=view&amp;resultType=5A 于是去 pyspider 的 demo 页新建一个项目：5stat，就去爬了。 分析页面网页比较特殊，看起来是用 dotnet 写的，翻页是按钮调用 js 代码实现的。跳转后还是同一个网址。 这里就要用到 pyspider 支持的页面载入后运行 js 脚本的功能。 先分析翻页按钮干了什么。 如下图，调用一个名为 __doPostBack 的函数。 在页面上寻找这个函数，看到函数体如下： 1234567891011var theForm = document.forms['form1'];if (!theForm) &#123; theForm = document.form1;&#125;function __doPostBack(eventTarget, eventArgument) &#123; if (!theForm.onsubmit || (theForm.onsubmit() != false)) &#123; theForm.__EVENTTARGET.value = eventTarget; theForm.__EVENTARGUMENT.value = eventArgument; theForm.submit(); &#125;&#125; 函数将 theForm 里面的 __EVENTTARGET 值设置为 PageNavigator1$LnkBtnNext 之后就提交了。 找到 theForm 对应的元素，看见有三个隐藏域， __EVENTTARGET、__EVENTARGUMENT 和 __VIEWSTATE。 附近还有一个隐藏域 __EVENTVALIDATION。看名字就觉得要提交。 于是试试只提交这三个值看看会不会报错。 在 chrome 上安装 postman 这个应用，打开。 修改方式为 POST，填上地址和三个域的值，send。 OK，返回了正确的页面，也就是可行了。 爬虫脚本嗯 pyspider 的爬虫脚本怎么写就不详述了，不会的看文档。 着重列出爬虫执行的 js 脚本的功能。 1234567function() &#123; var flag = 'y'; if ( document.querySelector('#PageNavigator1_LnkBtnNext').getAttribute('disabled') ) &#123; flag = 'n'; &#125; return document.form1.__VIEWSTATE.value + '~' + document.form1.__EVENTVALIDATION.value + '~' + flag;&#125; 如此一来在回到爬虫脚本中的时候就能得到下一页跳转的参数了。 奇怪的地方来了因为 pyspider 的文档说明对于每个项目内的相同网址会忽略，于是按照教学提示给网址加了个 #。很明显这样的网址不会改变请求的参数（使用一些其他技术的情况下除外）。 之后不再使用这个方法，因为 pyspider 判断是否同网址实质上是简单地将网址 md5 一下生成任务 id，以此来判断是否同一个爬虫任务。后来用的方法是直接重写任务 id 的生成。 然而在爬下来的数据中却发现有除了旅游地点外的酒店信息。 原来同一个页面也有五星级饭店的信息。如下图，注意最后有一个 #。 点击后跳转到一个网址：http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=hotel&amp;resultType=%u4E94 的页面。 看起来跟旅游地点差不多，新建一个项目 5hotel，直接复制粘贴之前的代码，就是改了一下网址。 期间还将任务 id 的生成重写了一下，这样即使请求同一个网址也没问题了。 然而运行的结果却失败了。 在 content 中很明显看出页面获取不全，然而代码是直接复制的，页面也是相同结构的，为什么会出现这个问题呢？ 然后我就被困扰了两天，接着就没在去管，盘算以后自己实现个爬虫再爬好了。 转机今天我再上去看，爬 5A 风景区的项目一直稳定运行。 五星级饭店的却还是无法抓取全部页面。 然后我鬼使神差地给网址加了一个 #。网址从： www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=hotel&amp;resultType=%u4E94 变成 www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx#?catalogType=hotel&amp;resultType=%u4E94 然后就能爬了！！！ shenmegui？？？！！！ 我也搞不清楚究竟是 pyspider 的问题还是 phantomjs 的问题还是 dotnet 的问题了。]]></content>
      <categories>
        <category>技术</category>
        <category>黑客</category>
        <category>杂谈</category>
        <category>编程语言</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>script</tag>
        <tag>spider</tag>
        <tag>scraper</tag>
        <tag>pyspider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配合 angular 和 angular-material 来开发基于 electron 的应用 · 2--node 库的使用和抓取代码的编写]]></title>
    <url>%2Fbuild-application-with-angular-and-ng-material-based-on-electron-2-use-node-lib-and-code%2F</url>
    <content type="text"><![CDATA[使用 nodejs 的库python 脚本的详细编写，请看之前的博文：radioit 计划——动画广播辅助脚本 radioitScript。 需要用 node 实现脚本中的某些逻辑是获取和提取广播的信息，整合成 JSON 格式的数据。 而用一些库就能轻松做到。 superagentsuperagent 是一个极其简单的 AJAX 库。 使用方法简单得令人发指。 1234567var request = require( 'superagent' );request .get( 'http://xxx.com' ) .end( function ( err, res ) &#123; // Do something&#125;); 还用介绍吗？不用了。 bluebirdbluebird 是一个 Promise 库。 凡是类似 IO 的操作，必定需要异步。经典的解决方法是回调，然而是时候用 Promise 了！ bluebird 声称拥有无与伦比的速度。其实更实用的功能是它支持能够将一些本身是不支持 Promise 的库转化为支持 Promise 的库。 然而，要配合之前的 superagent，则需要另外一个库 superagent-bluebird-promise。superagent 本身不支持 Promise，从上面的代码来看就是使用回调的方法，这个库就是将 superagent 和 bluebird 融合在一起的“融合卡”。 使用的时候只需要： 12345678910var Promise = require( 'bluebird' );var request = require( 'superagent-bluebird-promise' );request .get( 'http://xxxx.com' ) .then( function ( res ) &#123; // do something when resolved &#125;, function ( err ) &#123; // do something when rejected &#125;); 立刻就可以使用上 then 了，方便吧。 cherriocheerio 是一个语法类似 jQuery，为服务端提供 jQuery 核心功能的库。这里用到的是它的 CSS 选择器功能。 代码同样很简单，使用过 jQuery 的人会倍感亲切。 1234var cheerio = require( 'cheerio' ), $ = cheerio.load( '&lt;h2 class="title"&gt;Hello world&lt;/h2&gt;' );$( '.title' ).text(); // Hello world 使用 cheerio 有比较推荐的做法就是添加上 decodeEntities 和 lowerCaseAttributeNames 这个两个 options 配置，能避免各种 HTML 文本的奇怪问题。 1234$ = cheerio.load( HTMLtext, &#123; 'decodeEntities': true, 'lowerCaseAttributeNames': true &#125;); 综上，四个库的混合使用例子如下： 12345678910111213141516var Promise = require( 'bluebird' );var request = require( 'superagent-bluebird-promise' );var cheerio = require( 'cheerio' );request .get( 'http://xxxx.com' ) .then( function ( res ) &#123; var $, text; $ = cheerio.load( res.text, &#123; 'decodeEntities': true, 'lowerCaseAttributeNames': true &#125;); text = $( 'p' ).text(); &#125;, function ( err ) &#123; console.log( err ); &#125;); 编写逻辑 npm 安装库的过程略。 因为是信息整合，那么必定需要有一个统一的数据格式。于是先来确定数据格式。 广播站中所有广播的信息整合数据格式。 1234567891011121314151617181920212223242526// data will be formated as a json object in following structure:// &#123;// 'name': 'String, name of the channel',// 'url': 'String, url of the channel',// 'timestamp': 'Number, timestamp of this data',// 'bangumi': &#123;// 'mon': [// &#123;// 'id': 'String, id of the bangumi',// 'homepage': 'URL, homepage of the bangumi',// 'name': 'String, name of the bangumi',// 'image': 'String, image url of the bangumi, optional',// 'status': 'String, new / normal',// ...// &#125;,// &#123;...&#125;// ],// 'tue': [&#123;...&#125;,&#123;...&#125;],// 'wed': [&#123;...&#125;,&#123;...&#125;],// 'thu': [&#123;...&#125;,&#123;...&#125;],// 'fri': [&#123;...&#125;,&#123;...&#125;],// 'sat': [&#123;...&#125;,&#123;...&#125;],// 'sun': [&#123;...&#125;,&#123;...&#125;],// 'irr': [&#123;...&#125;,&#123;...&#125;],// &#125;// &#125; 单个广播的信息整合数据格式。 1234567891011121314// data will be formated as a json object in following structure:// &#123;http://hibiki-radio.jp// 'timestamp': 'Number',// 'name': 'String, name of the bangumi',// 'homepage': 'URL, homepage of the bangumi',// 'description': 'String, description of the bangumi',// 'title': 'String, title of the newest episode',// 'comment': 'String, comment of the newest episode',// 'schedule': 'String, schedule of the bangumi or the update date of the newest pisode',// 'personality': 'String, personality of the bangumi',// 'guest': 'String, guest of the newest episode',// 'images': 'String Array, array of images' url',// 'audio': 'String, url of audio'// &#125; 有了输出的数据格式，抓取信息的时候就能有的放失。 以 響 - HiBiKi Radio Station - 为例。因为在之前编写脚本的时候已经得到了页面上信息的位置，所以可以直接应用在代码中。 12345678// 一些固定的信息和变量var NAME = '響 - HiBiKi Radio Station -';var HOST = 'http://hibiki-radio.jp';var URLs = &#123; 'catalogue': 'http://hibiki-radio.jp/program', 'bangumi': 'http://hibiki-radio.jp/description/'&#125; 以下开始获取广播站的广播。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 获取信息的对象var hibiki = &#123; catalogueName: NAME, host: HOST, // 异步取得所有广播的基本信息，返回一个 promise 对象 getCatalogueAsync: function () &#123; return request .get( URLs.catalogue ) .then( function ( res ) &#123; var $, days, bangumi, data; days = 'mon tue wed thu fri sat sun irr'.split( ' ' ); $ = cheerio.load( res.text, &#123; 'decodeEntities': true, 'lowerCaseAttributeNames': true &#125;); // Extract html and structure data // 准备数据结构 data = &#123;&#125;; data.bangumi = &#123;&#125;; days.forEach( function ( el ) &#123; data.bangumi[el] = []; &#125;); // Structure daily bangumis // 一个 .hbkProgramTable 包含一天的广播 $( '.hbkProgramTable' ).each( function ( i, el ) &#123; var _; // 一个 .hbkProgramTitleNew 或 .hbkProgramTitle 为一个广播 data.bangumi[days[i]] = $( this ).find( '.hbkProgramTitleNew, .hbkProgramTitle' ).map( function ( _, el ) &#123; _ = $( this ); // 一个广播的基本信息 return &#123; 'id': _.parent().attr( 'href' ).slice( 35 ), 'homepage': _.parent().attr( 'href' ), 'name': _.text(), 'image': _.prev().children().eq( 0 ).attr( 'src' ), 'status': _.attr( 'class' ) === 'hbkProgramTitleNew' ? 'new' : 'normal' &#125;; &#125;).get(); _ = null; &#125;); // add extra data data.name = NAME; data.url = HOST; data.timestamp = Date.now(); return data; &#125;, function ( err ) &#123; console.log( 'hibiki:get catalogue error:' + err ); throw new Error( err ); &#125;); &#125;&#125; 以下开始获取某个广播的详细信息，函数定义在上面的对象中。 123456789101112131415161718192021222324252627282930313233343536373839404142getBangumiAsync: function ( id ) &#123; return request .get( url.resolve( URLs.bangumi, id ) ) .then( function ( res ) &#123; var $, data; $ = cheerio.load( res.text, &#123; 'decodeEntities': true, 'lowerCaseAttributeNames': true &#125;); // Extract html and structure data // 某个广播详细页的信息提取，信息的位置在 python 脚本中已经确定好了 data = &#123; 'timestamp': Date.now(), 'name': $( 'title' ).text().slice( 27, -5 ), 'homepage': url.resolve( URLs.bangumi, id ), 'description': $( 'table.hbkTextTable td:nth-of-type(1) div:nth-of-type(1)' ).eq( 0 ).text().trim(), 'title': $( 'table.hbkTextTable td:nth-of-type(1) div:nth-of-type(3) table:nth-of-type(1) div' ).eq( 0 ).text().trim(), 'comment': $( 'table.hbkTextTable td:nth-of-type(1) div:nth-of-type(3) table:nth-of-type(2) td' ).eq( 0 ).text().trim(), 'schedule': (function () &#123; var _, text; _ = $( 'table.hbkTextTable &gt; tr &gt; td:nth-of-type(2) &gt; div' ); if ( !( text = _.eq( -5 ).text().trim() ) ) &#123; text = _.eq( -3 ).text(); &#125; return text; &#125;)(), 'update': $( '.hbkDescriptonContents' ).eq( -1 ).prev().prev().find( 'span' ).eq( 0 ).text(), 'personality': $( 'table.hbkTextTable td:nth-of-type(1) &gt; table table td:nth-of-type(2n) a' ).map( function () &#123;return $( this ).text();&#125; ).get().join( '' ),'guest':'', 'images': $( 'table.hbkTextTable td:nth-of-type(1) div:nth-of-type(3) table:nth-of-type(2) td img' ).map( function () &#123;return $( this ).attr( 'src' );&#125;).get(), 'audio': $( 'div.hbkDescriptonContents embed' ).eq( -1 ).attr( 'src' ) &#125;; return data; &#125;, function ( err ) &#123; console.log( 'hibiki:get bangumi error:' + err ); throw new Error( err ); &#125;);&#125;, 代码看似很多，其实就是多了信息提取的部分，其他代码完全就是上一节中四个库的混合使用。 要注意的有一点，就是 promise 链中的 then( fulfilledHandler, rejectedHandler )。其中 fulfilledHandler 在最后需要使用 return data; 将数据传出去，而 rejectedHandler 也需要使用 throw new Error( err ); 重新抛出错误，不然 promise 链中下一个函数将不会得到处理好的数据或者异常（因为已经处理掉了）。 最后别忘了将对象导出。 1module.exports = hibiki; 同理，另外两个广播站的代码基本都一样，不同的只是信息提取的部分。 整合对于取数据的调用者而言，是无需理会数据从哪来的，只需要知道使用什么 API 就够了。 再者，既然有 “整合” 之名，就要行 “整合” 之实。因此要将这三个或者日后出现的更多个广播站提取代码整合起来，只提供一个调用入口。 新建目录 provider，将三个广播站的脚本都放进去。 再新建一个 provider.js 文件，写入以下代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var catalogue = &#123; 'hibiki': require( './provider/hibiki.js' ), 'onsen': require( './provider/onsen.js' ), 'animate': require( './provider/animate.js' )&#125;;var provider = &#123; /** * Get the list of catalogue * @return &#123;Array&#125; list of catalogue */ getCatalogueList: function () &#123; var arr = [], item; for ( item in catalogue ) &#123; arr.push(&#123; id: item, name: catalogue[item].catalogueName, host: catalogue[item].host &#125;); &#125; return arr; &#125;, getCatalogueAsync: function ( id ) &#123; var c; if ( !( c = catalogue[id] ) ) &#123; return; &#125; return c.getCatalogueAsync(); &#125;, getBangumiAsync: function ( catalogueID, bangumiID ) &#123; var c; if ( !( c = catalogue[catalogueID] ) ) &#123; return; &#125; return c.getBangumiAsync( bangumiID ); &#125;&#125;;module.exports = provider; 整体思路是提供一个可调用的列表，然后根据参数调用相应脚本的功能，就是一个 dispatcher 的功能。 如此，就实现了应用的一大部分主要功能了。]]></content>
      <categories>
        <category>技术</category>
        <category>编程语言</category>
        <category>javascript</category>
        <category>electron</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>angularjs</tag>
        <tag>angular-material</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配合 angular 和 angular-material 来开发基于 electron 的应用 · 1-- 分析与配置]]></title>
    <url>%2Fbuild-application-with-angular-and-ng-material-based-on-electron-1-analyze-and-configuration%2F</url>
    <content type="text"><![CDATA[应用 github 地址。github 代码和文章代码并不同步，用作预览和 PR。 目标分析一句话概述：开发的应用是一个抓取网页有用信息并重新统一排布的应用，是 之前文章 提到的 radioit 计划里脚本的 GUI 版本。 关键词：网页抓取、信息统一、信息排布、脚本的 GUI 版本 功能： 浏览某一个广播站的广播 浏览某一个广播的详细信息 下载某一个广播最新的相关图片 下载某一个广播最新的相关音频 能够通过设置代理来突破某些限制 能够离线浏览（未定） 预定周期下载任务（未定） 整合视频压制工具（未定） 业务流程： 请求特定 url 资源 对取得的 url 资源进行信息提取 信息整合成统一格式 显示信息 某些情况下执行预定命令行（未定） 技术联想： 请求特定 url 资源 -&gt; node 对取得的 url 资源进行信息提取 -&gt; node 的某些库 信息整合成统一格式 -&gt; javascript, json 显示信息 -&gt; html、css、angular、angular material 某些情况下执行预定命令行（未定） -&gt; node 技术分析技术要点： node.js(io.js)，负责网络连接，网页内容解析提取，非浏览器环境因此能够进行跨域访问 angular，MVVM 框架，自动进行数据的渲染 angular material，angular 推出的 material design UI 框架，适合作为桌面应用使用 stylus，CSS 预处理器，合理直观的 CSS 编写格式 脑内讨论 Q：为什么使用 Electron？ A：Electron 有意思地使用了 main 进程和 render 进程，render 进程产生于 main 进程中，因此可以简单地产生多个 render 进程，也就是多窗口。这是一个优势。 Q：不用 angular，用 react 是否可以？ A：可以，然而在假定选用了 react 之后，然后脑内模拟了一下编程的过程，react 似乎并不适合 html 代码经常修改的场合。而自己比较在行的是写 html 和 css，在界面设计上必定经常修改。另外在 material design 的 UI 框架上，使用配合 angular 的 angular material 显然更具操作性。当然 react 下也有 material design 的 UI 框架，但在试用之后感觉不太好用。另外就是自己翻译过一篇很长的有关 angular 的文章，对 angular 比较熟悉。日后考虑改用 Polymer 重写。 Q：material design 是必须使用的吗？ A：作为桌面应用，需要有一点时刻记住的是桌面应用跟网页是不一样的。桌面应用需要稳定的窗口，要有标题栏等清晰的组件，也不需要太花哨的特效。material design 或者受 material design 影响的一些简洁 UI 风格已经在某些桌面软件上应用开来。Electron 作为使用网页作为 GUI 表现，使用 material design 是个稳妥之举。 Q：为什么不用 SASS / LESS？ A：SASS 需要 Ruby，对非 Rubyer 是非常无理的要求，逻辑表现能力强大而无用（非常用）；LESS 语法简单，支持混写，但逻辑表现力太弱。stylus 则是既有强有力的特性，也足够简单。有时，工具够用就行。参考：Why I Choose Stylus (And You Should Too) Q：node 和页面中的 angular 如何沟通？ A：main 进程和 reander 进程有特定的模块进行通信。render 进程能通过页面中的全局变量和 angular 进行通讯。 Q：为什么要使用 node 的库来处理网页请求和内容提取？angular 自带有 $http 不是更方便？ A：如此一来，就能各自开发。node 只需要管如何得到数据，angular 只需要管如何显示数据。另外，如果需要更改 GUI，那么只需要去掉 angular，换上其他 UI 框架就可以，数据生成不受任何印象。只是如此开发需要更多的精力。 开发配置NPM 配置node.js 的安装是必须的，不多介绍。安装完自带 npm 管理工具。 用的最多的 node 命令：1234npm i xxx -gnpm i xxx --savenpm u xxx --savenpm update 第一条是全局安装 node 模块。比如一些常用工具，每一个项目都可以用到的工具等。这些模块可以写在 package.json 中的 devDependencies 字段中。 第二条是本地安装 node 模块并保存信息到 package.json 中。适合项目特定使用的模块。这些模块可以写在 package.json 中的 dependencies 字段中。 第三条是卸载本地安装的 node 模块。node 模块太多了，尝试多个选最好的。 第四条是升级 node 模块。 以下是 package.json 文件的暂时内容。 123456789101112131415161718192021222324252627282930313233// package.json&#123; "name": "Radioit", "description": "radioit desktop edition", "version": "0.1.0", "main": "main.js", "author": "exoticknight", "mail": "draco.knight0@gmail.com", "devDependencies": &#123; "jshint": "latest", "rimraf": "latest", "electron-packager": "latest", "electron-prebuilt": "latest", "silence-chromium": "latest", "mkdirp": "latest", "nib": "latest", "stylus": "latest", "uglifyjs": "latest", "browserify": "latest", "watchify": "latest", "parallelshell": "latest" &#125;, "scripts": &#123; "build:css": "stylus -u nib src/css/app.styl -o static/css/app.css", "watch:css": "stylus -u nib src/css/app.styl -o static/css/app.css -w", "test": "electron main.js 2&gt;&amp;1 | silence-chromium", "start": "npm run build:css &amp;&amp; electron main.js 2&gt;&amp;1 | silence-chromium" &#125;, "dependencies": &#123; "deepcopy": "^0.5.0", "extend": "^2.0.1" &#125;&#125; 暂时并没有太多的东西，注意要开发基于 Electron 应用，electron-packager 和 electron-prebuilt 必不可少，一个是 Electron 的打包工具，一个是 Electron 运行环境。而 silence-chromium 则是将 chromium 控制台信息输出到系统终端的工具。其他的工具都是博主开发过程中精选过的工具，还请读者自行 Google 之来学习。 如果你看过本博客之前的一篇文章：i18n.js 库的编写兼使用 npm 辅助开发，就知道博主是能用 npm 就不用 gulp / grunt 的，因此在 scripts 字段中也写上了运行的脚本。 angularjs 配置angular 的版本比较稳定，因此直接用 bower 来获取，不推荐其他包管理工具。 bower 需要先使用 npm install bower -g 来安装，也需要配置了 git 的环境。如果你使用 github for windows，那么请使用 gitshell 来运行。 angular 的安装在下一节中。 angular material 配置对于 bower 来说，angular material 跟 angular 是一样的东西，只是后者是前者的依赖。 运行 bower install angular-material， bower 会自动将依赖的的 angular、angular-aria 和 angular-animate 一并安装上。 安装完后所有文件会在项目目录下的 bower_components 中找到。 Electron 配置具体参考：Quick Start 在 package.json 中有一个 main 字段，值是 main.js。这个就指定了 Electron 启动应用的入口。 准备好文件结构。 1234app/├── package.json├── main.js└── index.html 初始程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var BrowserWindow = require( 'browser-window' ); // Module to create native browser window.var ipc = require( 'ipc' );var path = require( 'path' );// global variablevar APP_NAME = 'Radioit';var INDEX = 'file://' + path.join( __dirname, 'index.html' );// Report crashes to our server.require( 'crash-reporter' ).start();// Keep a global reference of the window object, if you don't, the window will// be closed automatically when the javascript object is GCed.var mainWindow = null;// Quit when all windows are closed.app.on( 'window-all-closed', function () &#123; if ( process.platform != 'darwin' ) app.quit();&#125;);// This method will be called when Electron has done everything// initialization and ready for creating browser windows.app.on( 'ready', appReady );function appReady () &#123; mainWindow = new BrowserWindow(&#123; 'width': 1024, 'height': 600, 'resizable': false, 'accept-first-mouse': true, 'title': APP_NAME, 'show': false &#125;); mainWindow.loadUrl( INDEX ); mainWindow.openDevTools(); // remove this mainWindow.webContents.on( 'did-finish-load', function () &#123; mainWindow.show(); &#125;); mainWindow.on( 'closed', function () &#123; mainWindow = null; &#125;);&#125; 代码好像很多，其实基本就是照抄 quick start，没有任何压力。 博主写的 main.js 和 quick start 中的有所不同。在新建 mainWindow 的时候，加入了其他参数 show: false 和 resizable: false，分别是隐藏窗口和窗口不可拉伸。也增加了一个： 123mainWindow.webContents.on( 'did-finish-load', function () &#123; mainWindow.show();&#125;); 作用是网页内容完全载入后才显示窗口，避免一些内容还没载入完就显示。 最后运行 npm run test 看看结果。 有什么问题请留言。]]></content>
      <categories>
        <category>技术</category>
        <category>编程语言</category>
        <category>javascript</category>
        <category>electron</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>angularjs</tag>
        <tag>angular-material</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配合 angular 和 angular-material 来开发基于 electron 的应用 · 0-- 前言]]></title>
    <url>%2Fbuild-application-with-angular-and-ng-material-based-on-electron-0-preface%2F</url>
    <content type="text"><![CDATA[ElectronElectron 是什么？它之前的名字是 Atom Shell，是 Github 开发的结合了 io.js 和 chromium 的跨平台桌面应用框架。Github 自己出的编辑器 Atom 以及微软出的编辑器 VSCode 都是基于这个框架。 众所周知，Google chrome 就是基于 chromium 而发展出来的一款优秀的浏览器。因其出色的体验和网页解析性能，所有国内出产的 &lt; del &gt; 山寨 &lt;/del &gt; 浏览器 / 双核浏览器，无不选用了 chrome 作为内核。所以在网页解析渲染方面，使用 chromium 是极其正确的选择。 那跟平常的桌面应用构建，使用 Electron 又有什么优势呢？ 普通的桌面应用构建，比较成熟的语言不外乎 C/C++、Java、C#、Python 等。然而 C/C++ 易学难精，即使其 GUI 框架有 MFC、Qt、KDE 等众，也是极难快速开发；Java 的 GUI 烂得不提也罢；C# 极有可能成为以后霸主，然而还在跨平台表现上有所欠缺；Python 则是个人喜好关系顺带一提，其实很少作为 GUI 主力语言被使用。（当然你可以阅读本人的另一个 有关 python 和 Qt 构建桌面应用的系列） Electron 则是使用了 Javascript 作为主力语言，并且为其加上了原生支持 html5 和 CSS3 的浏览器。从 GUI 构建来说，使用 html 和 css 的网页构建显然更加简单，成熟的工具和技术数不胜数；而作为桌面应用着重依赖的 IO、进程和网络通信模块等则由支持 ES6 的 io.js 提供，这样前端后端均采用 Javascript 语言，大大降低技术复杂性。 与 NW.js（旧名 node-webkit）的异同如果你有经常关注前端的消息，那么一定听说过一个国人开发的 GUI 框架：node-webkit。然后一看到 Electron，就会皱皱眉头：这不就是 node-webkit 嘛！ 然而，Electron 和 node-webkit 并不一样，其 github 项目上有详细的对比，链接。 就个人理解来说，NW.js 偏向网页主导，是一个加上了 node.js 的浏览器；Electron 则是 javascript 主导，是 io.js 加上了一个 chromium。 准确来说，Electron 只是选择了网页作为 GUI，并非为 GUI 绑定了 javascript。在 Electron 文档的 Quick start 中很明确地指出「It doesn’t mean Electron is a JavaScript binding to GUI libraries. Instead, Electron uses web pages as its GUI, so you could also see it as a minimal Chromium browser, controlled by JavaScript.」 在听说了 node-webkit 之后，我曾经上手把玩了一下，当时也是惊讶于其结合了浏览器内核而得到的强大表现力。因为自己在前端方面有一点技术，所以在编写界面的过程中感觉非常舒服。不过我也留意到其在软件方面的能力明显有比较大的欠缺，除了能读写文件外似乎没有什么亮点。（当然不排除在改名为 NW.js 后会加入了更多功能的可能性） 总之，NW.js 更像是将网页打包成应用，而 Electron 则是实际开发的应用。 angular 和 angular material如果要将网页设计应用到软件界面开发上，那么一些 MVC 框架或 UI 框架就比较适合。MVC 框架中比较有名的是 knockout 和 Backbone，而 UI 框架，则是 reactjs、angularjs 和 polymer 最为著名。国产的还有 avalon。 那么为什么选 angular 呢？因为 angular 的理念比较符合开发网页应用，更重要的是有 angular material 这样一个比较能使用的 UI 主题。相比之下，knockout 和 Backbone 功能太弱，reactjs 则是太激进（一开始我是选 reactjs 的，但是一番尝试之后还是放弃了），polymer 则未作深入了解。 不过，就像 Electron 只是选用了网页作为呈现 GUI 的方式，那么在编写基于 Electron 的应用的时候，GUI 框架的选择其实并非固定死的，如有必要或者个人喜好，转而使用 polymer 或者 reactjs 也未尝不可。 本系列的目的如果有看过鄙人写的 python × Qt 应用开发系列，那么一定知道本人的教程都偏向实践，喜欢实际解释代码和一定程度地搞清楚技术的细枝末节，而非跟着网上一搜一大把的英文教程或者官方文档演示一篇后以近乎翻译一般地写出所谓的 “教程”。官方文档就摆在那，谁不会 RTFM？ 在本系列中，鄙人同样会以记录一个应用的开发流程的形式来呈现成功（或者说，可行）的开发方式。有时会有大量的代码，有时又会有长篇的理论讨论，有时又会有大段的思维解释，希望读者能耐心读下去。]]></content>
      <categories>
        <category>技术</category>
        <category>编程语言</category>
        <category>javascript</category>
        <category>electron</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>angularjs</tag>
        <tag>angular-material</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python × Qt 应用开发系列目录（连载中）]]></title>
    <url>%2Fpython-with-qt-application-development-catalogue%2F</url>
    <content type="text"><![CDATA[python × Qt 应用开发 · 0 — 序 python × Qt 应用开发 · 1 — 基本界面 python × Qt 应用开发 · 2 — 界面初步设计 python × Qt 应用开发 · 2.5 — 改进软件界面 python × Qt 应用开发 · 3 — MVC 中 model 的基本实现 python × Qt 应用开发 · 4 — 数据库设计 python × Qt 应用开发 · 5 — 数据库 helper 类的编写]]></content>
      <categories>
        <category>技术</category>
        <category>编程语言</category>
        <category>python</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Qt</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i18n.js库的编写兼使用npm辅助开发]]></title>
    <url>%2Fwrite-i18n-js-with-help-of-npm-as-build-tool%2F</url>
    <content type="text"><![CDATA[近来由于开发某页面需要支持多语言切换，遂写一个切换页面语言的JS库。 编写库的既定事项写JS库也不是一两次了，当然只是小型或者微型的。不过思想和方法和大型库都是通用的。一般是直接在sublime text里打开一个JS文件，然后写下一个Self-Executing Anonymous Functions（自执行匿名函数？），接着在函数里面创造库的对象，最后将对象挂在window对象下。 Show you the code的话就是以下所示： 1234567891011(function( window, undefined )&#123;var i18n = &#123;&#125;;i18n.bar = function () &#123; return;&#125;;window.i18n = i18n;&#125;)( window ); 学得这样的写法是来源于对jQuery源代码的阅读。 通过将代码都包在一个匿名函数中，实现了一个闭包。如此一来在闭包内随便折腾，也不会污染到外部全局环境（当然是在编写可靠的代码的情况下）。 不过，随着AMD和CommonJS标准的流行开来，越来越多JS库都将自己模块化。过程也不复杂，只要遵循一定的规则就可以了。 而对于编写一个简单的JS库，将github上UMD项目给出的模板修改一下就OK。 修改后代码： 1234567891011121314151617181920;(function( root, name, definition ) &#123; if ( typeof define === 'function' &amp;&amp; define.amd ) &#123; define( [], definition ); &#125; else if ( typeof module === 'object' &amp;&amp; module.exports ) &#123; module.exports = definition(); &#125; else &#123; root[name] = definition(); &#125;&#125;)( this, 'i18n', function() &#123;var i18n = &#123;&#125;;i18n.bar = function () &#123; return;&#125;;// Return this libraryreturn i18n;&#125;); 注意最后不再需要手动将库挂载在window对象下，而是只是返回对象。挂载方式已经转交给外部函数判断。 思考多一点，代码少一点很久的以前，我曾经写过一个jQuery插件，功能是为表格添加分页和异步载入。然而在写之前并没有清晰地定下整个插件的功能和限制，导致最后写出来的插件身兼数职，连表格美化与自定义CSS等也做了进去。加进去的功能有可能只是随手实现的，也许并不适合此插件管辖，造成了“做得不好非要做”的尴尬。 另外，功能的繁琐与代码段的反复抽象提取导致了代码的凌乱不堪，进而导致测试出bug的时候完全搞不清楚问题所在。 最后代码膨胀到完全不能控制，自己写出来的代码连自己都不敢修改。 在写jQuery插件的时候，十分容易变成了写“使用jQuery的代码集合”，缺少性能和架构的考虑。这跟jQuery本身十分强大和灵活的特性有很大的关系。 写库或插件，目的应该是将通用或者复杂的逻辑实现封装起来，通过提供简洁的API来实现功能的调用。 先将手从键盘上收回，拿出纸笔，好好列出对JS库的描述。 Q1：i18n.js要做什么？ A1：对页面上的文本进行语言切换。 Q2：如何定位文本？ A2：为DOM元素增加’data-i18n’属性进行标记。 Q3：如何找到标注DOM元素？ A3：从给出的DOM元素作为根进行深度优先/广度优先遍历。 Q4：译文的来源？ A4：用户遵循某一标准自定义每一套语言的字典。 Q5：如何将译文和元素对应？ A5：对每一条文本，以唯一ID标识。凡是’data-i18n’属性的值为此ID的元素，即使用此ID对应文本。 思路是不是清晰了很多呢？可以看到核心逻辑就是一个有访问函数的DFS或BFS算法。 工欲善其事，必先利其器？近年的前端大发展，也催生了很多自动化工具。node的流行更是让很多软件管理和后端开发的思想能应用到前端开发上。 经典的前端开发不外乎就是写HTML、写CSS、写Javascript，然而在前端代码量越来越大的现在，一个自动化的构建工具则能大大提高工作效率。 如果Google一下前端构建工具，那么基本就是Grunt和Gulp。 本质上，Grunt和Gulp都是任务运行器，尝试将前端的代码生成甚至发布统合到几个甚至一个命令行中。它们本身作为npm的一个模块，并没有什么作用，真正做事的是以其为平台的大量插件。通过将各种各样的插件整合起来，Grunt和Gulp就能实现自动化的任务执行。 但是慢着，以前不是很流行什么网页三剑客的吗？甚至用DreamWrear就能做网页啊。任务运行器、插件什么的是个什么鬼？！ 是这样的，现在的前端开发，虽然最终结果还是写HTML、写CSS、写Javascript，但是过程却已经变化多端，内容也逐渐丰富。 HTML的话： 切图输出其实也已经算一种自动化。然而现在还能使用jade、HAML或者各种模板引擎生成，也就是有可能不是直接手写HTML代码了。这个就需要依赖编译了。 CSS的话： SASS、LESS和Stylus都已经存在了很久了，源代码产出CSS也是需要编译的。CSS文件也能够进行合并和版本控制，如此一来又需要额外的工具。 Javascript的话： 本身就是一个编程语言，有工具能对其语法进行排错，不能不用吧？流行又高效的模块化开发，需要工具合并吧？压缩源代码，又需要操作了吧？注释呢？文档呢？统统需要工具啊。 总结起来，HTML要编译，CSS要编译、合并、压缩和，Javascript要编译/合并、压缩甚至生成文档。最后发布还要顾及CDN或者缓存或者bug跟踪进行版本管理如果以上每一步都要自己操作，那么即使只是打命令行也是够呛。 而使用上自动化构建，则在设定好以上多种工具的使用流程之后（几乎）一劳永逸，只需要专心写好流程最开始的源代码就OK，构建工具会完全自动地生成最终结果。能少干活就少干活，那个程序员愿意做重复性工作？ 这也就是为什么自动化构建工具在一日发展千里、需求一日多改的前端如此受欢迎的原因了。 Grunt VS Gulp是个程序员总会遇到圣战的时候，或是Emacas VS Vim，或是C# VS Java，或是Python VS Ruby，或是AngularJS VS ReactJS，或是IOS VS Android…… 当然，PHP是最好的语言所以不用战争。 也有人只是选择困难症后期患者，一旦选项多于一就会头痛欲裂、浑身不自在。 那么，究竟Grunt or Gulp？ 为此很多人写过分析的文章，有中文的、英文的和另一篇英文的，总的来说就是， Grunt：插件比较多，社区成熟，风格偏配置，插件比较混乱，代码较长，过程有临时目录 Gulp：插件不够Grunt多，风格偏代码，插件功能单一专注，代码较短，流式工作无需临时目录 个人选择是Gulp，那个插件数量不够多是个伪缺点，只是不过Grunt多，其实也有上千个，还不够用？！从其他优点来看都是完胜Grunt了。 逆袭的npm那是不是选择Gulp来构建i18n.js呢？ 并不是。 如果有仔细看给出的分析文章，可以看到还有一个构建工具：npm。 众所周知npm实际上是nodejs的包管理工具，然而在其配置文件package.json里面却也可以设置一些可运行项，然后通过npm run xxx来运行。从文章来看，也是能够胜任构建的任务。 那么问题来了，从网上基本千篇一律的教程来看，Grunt和Gulp的使用都是装上了自带npm的node，然后通过npm来安装的。既然npm本身就能作为构建工具，那为啥要用Grunt和Gulp？ 注意到那篇中文的分析文章还提到“npm一般用在个人项目里,对于团队项目则不适用”，然而果真如此吗？ 使用英文搜索一下，不难发现国外也有人提出停止使用Grunt和Gulp的主张，在文中列出类似或同类构建工具的问题： Bloat Relying on plugins Separate pain in updating False Promises Bad behaviours 接着提出了使用npm的主张，并且还给出了详细方法，可以看到使用npm更易懂更简洁。 我使用Grunt和Gulp的经验并不多（实际也不是什么复杂的东西），对于文中提出的第一个问题已经深有感触。明明只是简单的工作，却要写一大堆罗嗦的配置。另外Grunt/Gulp插件使用都是local安装，于是明明只是写几个KB大小的库，却要将项目的文件夹弄成几十MB大。插件作用都很专一，更新频率很低，全局安装就好，每开一个项目就独立往项目塞一样的工具简直是闲得蛋疼，尤其npm下载插件经常由于网络原因而失败。 当然独立安装项目依赖也有其存在的意义。当将项目发布给其他人使用或者开发的时候，独立安装项目依赖可以保证环境是一样的。 所以结论是，不要为使用Grunt/Gulp而使用Grunt/Gulp，很多情况下并不需要将事情弄复杂。 package.json参考国外配置npm的文章，写好package.json。 1234567891011121314151617181920212223242526272829303132333435&#123; "name": "i18n.js", "devDependencies": &#123; "concat-cli": "latest", "jade": "latest", "jshint": "latest", "rimraf": "latest", "nodemon": "latest", "parallelshell": "latest" &#125;, "scripts": &#123; "clean:test": "rimraf test/*", "clean:dist": "rimraf dist/*", "lint": "jshint src/js/main.js", "test:html": "jade -P src/test.jade --out test", "watch:html": "jade -w -P src/test.jade --out test", "prebuild:js": "npm run lint", "build:js": "concat-cli -f src/js/wrap/prefix.js src/js/main.js src/js/wrap/suffix.js -o dist/i18n.js", "postbuild:js": "uglifyjs dist/i18n.js -o dist/i18n.min.js -m -c", "pretest:js": "npm run lint", "test:js": "concat-cli -f src/js/wrap/prefix.js src/js/main.js src/js/wrap/suffix.js -o test/i18n.js", "watch:js": "nodemon --watch src/js --exec \"npm run test:js\"", "pretest": "npm run clean:test", "test": "npm run test:js &amp;&amp; test:html", "test:watch": "parallelshell \"npm run watch:js\" \"npm run watch:html\"", "prebuild": "npm run clean:dist", "build": "npm run build:js" &#125;&#125; 清晰明了。 测试环境清理：rimraf HTML构建：jade Javascript排错：jshint Javascript合并：concat-cli（多个文件复制合并） 全部都是一句话配置，直指命令行。多个任务最终又可以汇集在test/test:watch中。 使用concat-cli构建Javascript比较少见，更多的是使用browserify配合require语法。然而i18n.js库实在太小了，真的不需要复杂的模块化管理。 编写i18n.js拆分先将原js文件拆分成三个。 12345678910// prefix.js;(function( root, name, definition ) &#123; if ( typeof define === 'function' &amp;&amp; define.amd ) &#123; define( [], definition ); &#125; else if ( typeof module === 'object' &amp;&amp; module.exports ) &#123; module.exports = definition(); &#125; else &#123; root[name] = definition(); &#125;&#125;)( this, 'i18n', function() &#123; 123456// suffix.js// Return this libraryreturn i18n;&#125;); 123456// main.jsvar i18n = &#123;&#125;;i18n.bar = function () &#123; return;&#125;; 接下来可以专心在’main.js’中写代码了。 在敲入代码之前记得使用npm run watch:js，不然配置毫无意义。 内部变量12345678910111213141516171819// Save the global object, which is window in browser / global in Node.js.var root = this;// This library and internal objectvar i18n = &#123;&#125;, _ = &#123;&#125;;// Current version.i18n.version = '0.0.1';// Internel storevar TRANSLATION_TABLE = &#123;&#125;;// Current languagevar CURRENT_LANGUAGE = '';// Save the previous value of the `i18n` variable, can be restored later// if 'noConflict' is called.var previousi18n = root.i18n; TRANSLATION_TABLE保存翻译文本，CURRENT_LANGUAGE保存当前使用的语言，_是内部使用的命名空间。另外使用root保存全局对象，previousi18n保存之前已存在的’i18n’对象。 库函数（API）12345// Restore the previous value of 'i18n' and return our own i18n object.i18n.noConflict = function () &#123; root.i18n = previousi18n; return i18n;&#125;; noConflict函数，学jQuery的。 12345// Load the translation tablei18n.load = function ( table ) &#123; TRANSLATION_TABLE = _.deepCopy( TRANSLATION_TABLE, table ); return i18n;&#125;; 载入翻译文本，使用深复制（应对多层对象）。 1234// Return the current set languagei18n.current = function () &#123; return CURRENT_LANGUAGE;&#125;; 返回当前使用的语言。 12345678910111213// Change the language, apply to all cached nodes or document.bodyi18n.use = function ( language ) &#123; var langTable = TRANSLATION_TABLE[language], nodes; if ( langTable ) &#123; nodes = _.filterNodes( root.document.body ); _.translate( nodes, langTable ); CURRENT_LANGUAGE = language; &#125; return i18n;&#125;; 切换语言。流程是匹配出语言配置，再从body开始抓取出需要翻译的DOM元素（_.filterNodes函数），然后翻译（_.translate函数），最后设置当前语言。 内部函数API函数的内容写得简单，主要是需要基于不少的内部函数。 首先是深复制。 Javascript中的赋值都是复制，因此对于基本类型（primitive value）：Undefined、Null、Boolean、Number、String来说，直接赋值就是复制。其他的复杂类型，直接赋值同样是复制——然而，复制的是引用，并不是引用的对象。 123456789101112131415161718192021222324252627282930313233343536// can handle array and nested objects, not perfect_.deepCopy = function ( des, src ) &#123; var beCopiedIsArray = false, target, name, clone, beCopied; target = des; for ( name in src ) &#123; beCopied = src[name]; if ( beCopied === src ) &#123; continue; &#125; if ( _.isObject( beCopied ) || ( beCopiedIsArray = _.isArray( beCopied ) ) ) &#123; if ( beCopiedIsArray ) &#123; beCopiedIsArray = false; clone = []; &#125; else &#123; clone = &#123;&#125;; &#125; target[name] = _.deepCopy( clone, beCopied ); &#125; else if ( beCopied !== undefined ) &#123; target[name] = beCopied; &#125; &#125; return target;&#125;; 改写自jQuery1.7内部实现的对象深复制函数，只保留了识别数组和对象的功能。因为译文文本就是JSON格式的普通对象（plain object），无需要实现太复杂的复制。核心代码的思想就是检测在当前对象的每一个属性（省略了hasOwnProperty的检测），如果是数组（_.isArray）或者普通对象（_.isObject），则实实在在创建一个数组 / 对象以供复制。 而数组 / 对象检测则是用以下代码： 123456789// figure out array_.isArray = Array.isArray || function( obj ) &#123; return Object.prototype.toString.call( obj ) === '[object Array]';&#125;;// figure out object_.isObject = function( obj ) &#123; return Object.prototype.toString.call( obj ) === '[object Object]';&#125;; 而库的核心，一个带访问函数的DFS。DOM操作自带取子元素和兄弟元素，写起来很简单。 12345678910111213141516// Walk the DOM, call the visit_.walkDOM = function ( dom, visit ) &#123; var node; // nodeType === 1 means element // nodeType === 11 means DocumentFragment if ( dom &amp;&amp; 1 === dom.nodeType || 11 === dom.nodeType ) &#123; visit( dom ); // 访问当前DOM元素 node = dom.firstChild; // 取当前DOM元素的第一个子元素 while ( node ) &#123; _.walkDOM( node, visit ); // 对此子元素递归调用 node = node.nextSibling; // 从此子元素返回，处理下一个兄弟元素 &#125; &#125;&#125;; 通过查看元素的属性来筛选出将要翻译的元素。 12345678910111213// Returns array of elements that have attribute 'data-i18n'_.filterNodes = function ( root ) &#123; var nodes = []; // traverse DOM tree and collect elements with 'data-i18n' attribute _.walkDOM( root, function ( ele ) &#123; if ( _.hasAttr( ele, 'data-i18n' ) ) &#123; nodes.push( ele ); &#125; &#125;); return nodes;&#125;; 上一个函数中用到的’_.hasAttr’，特别实现是因为IE的取属性方式跟其他浏览器不一样。 1234// Return true if ele has attribute otherwise false_.hasAttr = function ( ele, attr ) &#123; return ele.hasAttribute ? ele.hasAttribute( attr ) : ele[attr] !== undefined;&#125;; 接下来是改变元素的文本。代码很简单，做的事情就是遍历DOM元素数组，取属性’data-i18n’的值作为key值，在译文表格中查询value值（_.getTranslatedText），最后改变元素的文本（_.setText）。 12345678910111213141516// Translate each node in array with given language table_.translate = function ( nodes, table ) &#123; var key, text, i, length; for ( i = 0, length = nodes.length; i &lt; length; i++ ) &#123; key = nodes[i].getAttribute( 'data-i18n' ); if ( key ) &#123; text = _.getTranslation( key, table ); if ( typeof text === 'string' ) &#123; _.setText( nodes[i], text ); &#125; &#125; &#125;&#125;; _.getTranslatedText 支持使用点记法，代码直接用以前写过的。参考 12345678910111213141516// get translation via path, support dot_.getTranslatedText = function ( path, json ) &#123; var fieldPath = path.split( '.' ), data = json, index, indexLength; for ( index = 0, indexLength = fieldPath.length; index &lt; indexLength; index++ ) &#123; data = data[fieldPath[index]]; if ( !data ) &#123; return ''; &#125; &#125; return data;&#125;; _.setText 函数就是用’innerText’或’textContent’来设置元素文本。 12345678910// cross-browser set text_.setText = function ( ele, text ) &#123; var nodeType = ele.nodeType, textAttr; if ( nodeType &amp;&amp; 1 === nodeType ) &#123; textAttr = ( 'innerText' in ele ) ? 'innerText' : 'textContent'; ele[textAttr] = text; &#125;&#125;; 测试看起来大概写完了，来写一些测试。 实际上应该先写测试，再写代码。但是一来库很小，二来我不太懂，所以……不过之后写比较大型的库的时候要好好地用mocha等的测试框架。 用jade语法写一个HTML文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051doctype htmlhtml head meta(charset=&quot;UTF-8&quot;) title test script(src=&quot;i18n.js&quot;) body select#language(name=&quot;language&quot;,onchange=&quot;toggle()&quot;) option(value=&quot;en&quot;) English option(value=&quot;zh&quot;) 中文 option(value=&quot;jp&quot;) 日本語 h1(data-i18n=&quot;TITLE&quot;) Title p(data-i18n=&quot;p.text&quot;) This is test text. button(data-i18n=&quot;BUTTON_TEXT&quot;) change button(data-i18n=&quot;BUTTON_ADD&quot;,onclick=&quot;add()&quot;) add script. i18n.load(&#123; &apos;en&apos;: &#123; &apos;TITLE&apos;: &apos;Title&apos;, &apos;BUTTON_TEXT&apos;: &apos;change&apos;, &apos;BUTTON_ADD&apos;: &apos;add&apos;, &apos;p&apos;: &#123; &apos;text&apos;: &apos;This is test text.&apos; &#125; &#125;, &apos;zh&apos;: &#123; &apos;TITLE&apos;: &apos;标题&apos;, &apos;BUTTON_TEXT&apos;: &apos;变&apos;, &apos;BUTTON_ADD&apos;: &apos;添加&apos;, &apos;p&apos;: &#123; &apos;text&apos;: &apos;这是测试文本。&apos; &#125; &#125;, &apos;jp&apos;: &#123; &apos;TITLE&apos;: &apos;タイトル&apos;, &apos;BUTTON_TEXT&apos;: &apos;変更&apos;, &apos;BUTTON_ADD&apos;: &apos;追加する&apos;, &apos;p&apos;: &#123; &apos;text&apos;: &apos;これはテストテキストです&apos; &#125; &#125; &#125;); function toggle () &#123; var ele = document.getElementById( &apos;language&apos; ), value = ele.value; i18n.use( value ); &#125; 控制台运行npm run test:html生成HTML文件，用浏览器打开，切换一下语言，没问题。 继续开发应用i18n.js的多语言页面，是有可能动态添加DOM元素的（AJAX拉取数据之类的操作），所以i18n.js库也需要将添加的DOM元素翻译一下。于是再添加一个名为’translate’的API好了。 由于需要同时修改jade文件和js文件，所以使用npm run test:watch，同时监视jade文件和js文件的变化。 1234567891011121314151617181920// Translate nodesi18n.translate = function ( eles ) &#123; var langTable, nodeList, i, index, nodes; langTable = TRANSLATION_TABLE[CURRENT_LANGUAGE]; if ( langTable ) &#123; nodeList = Object.prototype.toString.call( eles ) === '[object NodeList]' || 'length' in eles ? eles : [eles]; for ( i = 0, index = nodeList.length; i &lt; index; i++ ) &#123; nodes = _.filterNodes( nodeList[i] ); _.translate( nodes, langTable ); &#125; &#125; return nodes;&#125;; 做的事其实和use大同小异，只是目标DOM元素不一样。 修改一下测试文件，增加一点代码。 在 body 中添加两个按钮。 12button(data-i18n=&quot;BUTTON_ADD_1&quot;,onclick=&quot;add(1)&quot;) add onebutton(data-i18n=&quot;BUTTON_ADD_2&quot;,onclick=&quot;add(2)&quot;) add two 在数据中增加按钮的文本。 12345678'BUTTON_ADD_1': 'add one line','BUTTON_ADD_2': 'add two line',/* ... */'BUTTON_ADD_1': '添加一行','BUTTON_ADD_2': '添加两行',/* ... */'BUTTON_ADD_1': '1行を追加する','BUTTON_ADD_2': '2行を追加する', 在脚本中增加一个函数，用作模拟动态添加DOM元素。可以添加一个或多个DOM元素。 12345678910111213141516171819function add ( num ) &#123; var p = document.getElementsByTagName( 'p' ) , newP = document.createElement( 'div' ) , i , node , fragment; fragment = document.createDocumentFragment(); newP.innerHTML = '&lt;p data-i18n="p.text"&gt;This is test text.&lt;/p&gt;'; for ( i = 0; i &lt; num; i++ ) &#123; node = newP.firstChild.cloneNode( true ); fragment.appendChild( node ); &#125; i18n.translate( fragment ); p = p[p.length-1]; p.parentNode.insertBefore( fragment, p.nextSibling );&#125; 再使用浏览器测试一下，同样没问题了。 再拆分一下现在main.js文件看起来比较复杂，可以再分别拆分成var.js，存放顶层变量；util.js，包含内部的函数；api.js，包含库的API。 稍微修改一下package.json文件，相关位置改成拆分后的文件。 12345 "lint": "jshint src/js/var.js &amp;&amp; jshint src/js/util.js &amp;&amp; jshint src/js/api.js",/* ... */ "build:js": "concat-cli -f src/js/wrap/prefix.js src/js/var.js src/js/util.js src/js/api.js src/js/wrap/suffix.js -o dist/i18n.js",/* ... */ "test:js": "concat-cli -f src/js/wrap/prefix.js src/js/var.js src/js/util.js src/js/api.js src/js/wrap/suffix.js -o test/i18n.js", 最后运行npm run build将js库编译出来并压缩。]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>i18n</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[radioit 计划——动画广播辅助脚本 radioitScript]]></title>
    <url>%2Fradioit-plan-animate-radio-script-radioitscript%2F</url>
    <content type="text"><![CDATA[在 这篇文章 的实践基础和 这篇文章 的代码基础上，我重新将代码整理一下，并添加了一些功能，将原来三个脚本的共同点提炼，写成一个网络广播查看和获取的框架。继而在这个框架上，写出对应三个广播站的脚本的 ver 2.0。 原来的脚本的功能就不再详述了，来说说一下新版脚本三大功能，分别是：探索广播、下载广播和查看广播。 探索广播是指能够列出某一个广播站上所有的 / 当天的 / 星期 x 的 / 最新的广播，旨在能够帮助使用者发现自己喜欢的广播和新推出的广播。 下载广播是指能提取出广播音频 / 图片的地址，供第三方播放器播放或保存。 查看广播是指能够列出某广播的主要信息：包括更新日期、最新一期的内容、主持人等。 基本可以说，有了新版的脚本，基本就不需要用浏览器浏览广播站的网页了。并且，因为脚本只是需要抓单个页面和将网页内容整理好再输出，所以对比起网页，能更快更高效地呈现有用的信息。 子命令对比旧版，新版脚本的一大改进是引入了子命令。最直观的反映就是，调用方式的不同。 旧版1python www.py -x -y zzz 新版1python www.py xxx -y zzz 就是类似 git 命令行的那样，argparse 库非常给力地支持这种方法。 重点是使用 add_subparsers 函数和 add_parser 函数，详细使用看 文档 和github 上的代码。 多亏了能够这样嵌套命令，即使再多的功能也能变得清晰分明。 整体框架ver 2.0 的起点是一个脚本框架，承载参数的解释和自定义函数调用的重要功能。 脚本的一次执行基本流程是： 入口 → 解析参数 → 调用自定义函数 → 执行自定义函数 前三个都能够定下来，不同的广播站只需要各自填充自定义函数就可以了。 最简框架代码如下： 123456789101112131415161718192021222324252627282930313233"""自定义函数"""def foo(): pass"""子命令和参数跳转"""def process(option): if option.sp_name == "www": if option.xxx: foo()"""入口"""if __name__ == "__main__": parser = argparse.ArgumentParser(version="2.0") # 子命令 sp = parser.add_subparsers(title="commands", description="support commands", help="what they will do", dest="sp_name") # 添加子命令 sp_www = sp.add_parser("www") # 添加子命令参数 sp_www.add_argument("-x", "--xxx", action="store_true", dest="xxx") try: args = parser.parse_args(sys.argv[1:]) except argparse.ArgumentError, e: print("bad options: &#123;0&#125;".format(e)) except argparse.ArgumentTypeError, e: print("bad option value: &#123;0&#125;".format(e)) else: process(args) 自定义函数骨架框架还基于库 urllib、urllib2、argparse 和 bs4，制定了自定义函数的骨架。 脚本做的事情，无非就是获取网页资源，接着在 html 结构中筛选有用信息，然后格式化成文本输出。因此，自定义函数也可以制定出骨架，不同的广播站就只需要指定筛选的规则就行了。 1234567891011121314151617# 获取网页try: soup = BeautifulSoup(urllib2.urlopen(u"http://url", timeout=60)) # 1except Exception, e: handle_error(e, "Network Error.") return# 筛选content = soup.select("html") # 2# 组织内容table = [(u"ID", u"Name")] + [a for a in content] # 3# 格式化文本text = prettify_table(table)# 输出print(text.encode("gb18030")) 虽说骨架是定下来了，但在特殊函数比如下载函数就需要另外编写。 总结虽然新版脚本框架是为了 radioit 计划而写的代码，但是其中 argparse 模块的使用的代码也是能被借鉴在其他需要带参数运行的 python 脚本中。 新版对比旧版，增加了功能，但是也增加了使用的复杂度和代码的长度。旧版还是可以保留下来，供日常快速使用。]]></content>
      <categories>
        <category>技术</category>
        <category>黑客</category>
        <category>编程语言</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>radioit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python × Qt 应用开发 · 2.5 -- 改进软件界面]]></title>
    <url>%2Fpython-with-qt-application-development-2-5-developing-gui%2F</url>
    <content type="text"><![CDATA[上一篇文章 完成基本的界面，但是应用看起来并不算特别好看。 主要是因为软件的界面使用默认的样式和普通的窗口框架。接下来从这两个方面出发，尝试改进软件界面。 自定义样式Qt 给控件的样式化提供了一定的自由度，包括背景色、边框和特定控件的自定义，使用类似 CSS 的语法。这要求编写软件的人了解基础的 CSS 语法。各种控件和详细例子：点这里 要改变一个控件的样式，可以在属性编辑器中找到 styleSheet 属性，将 CSS 代码写进去。 这里以中间栏的输入框作为例子。 选择输入框，在属性编辑器中找到 styleSheet，输入以下 CSS 代码。 123456789101112QLineEdit&#123;border-radius: 10px;padding: 5px 10px;margin: 0 10%;background-color: white;border: 1px solid #c9c9c9;color: #1b1b1e;&#125;QLineEdit:hover&#123;background-color: white;border: 1px solid #969696;&#125; 结束编辑，立刻可以看到效果。 修改前： 修改后： 给 widget 加上背景颜色。 123QWidget&#123;background-color:#xxx;&#125; 消除控件的自带边框。在属性编辑器中找到 frameShape，设置值为 NoFrame；找到 frameShadow，设置值为 Plain；找到 lineWidth，设置值为 0。 自定义按钮样式。 1234567QPushButton&#123;background-color: transparent;border-style:outset;border-width: 0px;padding: 5px 0;color: #fff;&#125; 其他细节都是类似的修改。 使用无框架窗口必须要在代码中实现。 回忆本系列第一篇文章，使用 QtDesigner 做出来的知识 view 而已，controller 是需要在 MainWindow.py 中实现的。这里不再累述。 找到 initUI(self) 函数，加入如下代码： 12# no frame windowself.setWindowFlags(QtCore.Qt.FramelessWindowHint) 没有了系统默认的框架，好看的同时也失去了三个系统提供的便捷功能：功能按钮、窗口拉伸和窗口移动。 下面来解决。 功能按钮在最上面加上一个控件，充当窗口的标题栏和关闭按钮的容器。 在控件里面简单地拖进一个标签控件作为标题，一个按钮作为关闭按钮。控件设置为蓝色。 运行（非预览）之后发现背景色没有完全填充，如下图。 这个要在代码里面修复。 找到 initUI(self) 函数，加入如下代码： 12self.ui.widgetHead.setAttribute(QtCore.Qt.WA_StyledBackground, True)self.ui.widgetLeft.setAttribute(QtCore.Qt.WA_StyledBackground, True) 具体来说就是在控件上调用 setAttribute(QtCore.Qt.WA_StyledBackground, True)。 窗口拉伸需要使用到一个名为 QSizeGrip 的类，只是这个类不能在 QtDesigner 中直接拖入，需要在代码中手动添加。 找到右边栏 widget 的 layout，更名为 verticalLayoutRight。然后在 initUI(self) 函数中添加如下代码： 1self.ui.verticalLayoutRight.addWidget(QtGui.QSizeGrip(self), 0, QtCore.Qt.AlignBottom | QtCore.Qt.AlignRight) 窗口移动窗口移动的功能是设置在窗口的标题栏上的，自实现的标题栏也要实现此功能。 在 MainWindow 类下，直接贴入以下函数即可： 1234567891011def mousePressEvent(self, event): """override mouse press event""" self._postion = event.globalPos() - self.pos()def mouseMoveEvent(self, event): """override mouse move event""" self.move(event.globalPos() - self._postion)def closeEvent(self, event): """override close event""" event.accept() 原理很简单，自己处理鼠标点击和拖动事件。 最终形态。]]></content>
      <categories>
        <category>技术</category>
        <category>编程语言</category>
        <category>python</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Qt</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旅游照——杭州 [21p]]]></title>
    <url>%2Ftour-photo-hangzhou%2F</url>
    <content type="text"><![CDATA[第一天的上海 第二天的苏州和乌镇晚上 第三天的乌镇和杭州 这次的重点不在杭州，所以西湖根本游不完。天气也很差，有雾，拍出来灰蒙蒙的。后期也不怎么会，将就着看吧。]]></content>
      <categories>
        <category>生活</category>
        <category>摄影</category>
        <category>旅游</category>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>photograph</tag>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旅游照——乌镇 & 杭州 [53p]]]></title>
    <url>%2Ftour-photo-wuzhen-hangzhou%2F</url>
    <content type="text"><![CDATA[第一天的上海 第二天的苏州和乌镇晚上 第三天早上在乌镇。早早起来拍摄。 不太会后期，都是相机 jpg 直出了。 冷到有霜。 早晨的乌镇真是美极了。 住的酒店叫做昭明书社。在外面拍完照回到房间，刚好看到窗边的一缕阳光照到盒子上面。 团里的两个女孩子，广大的。 到了河坊街。 晚上去了宋城。其实只是个古代主题的现代游乐园而已。]]></content>
      <categories>
        <category>生活</category>
        <category>摄影</category>
        <category>旅游</category>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>photograph</tag>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旅游照——苏州 & 乌镇晚上 [44p]]]></title>
    <url>%2Ftour-photo-suzhou-wuzhen-night%2F</url>
    <content type="text"><![CDATA[第一天的上海 第二天去苏州。 苏州的园林真的很好看，进去之后怎么看都有意思。亭台楼阁，池鱼树石，皆有情趣。 晚上在乌镇住，室外温度到了零下，拍了一晚手都弯不了。 七里山塘古街。 其实两岸和水都挺脏的，因为两岸仍然有人住。 团里的两对情侣。 这个拿着单反的人后来要我帮他拍两张，手中的 rx100 顿时被比了下去。 然后去了某个园林。 偷拍到某只黑猫。 古代和现代。 接下来去留园。 导游在买票。 团里两个小萝莉。 晚上入住乌镇。]]></content>
      <categories>
        <category>生活</category>
        <category>摄影</category>
        <category>旅游</category>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>photograph</tag>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旅游照——上海 [20p]]]></title>
    <url>%2Ftour-photo-shanghai%2F</url>
    <content type="text"><![CDATA[之前去了 4 天旅游，挑一点旅游照放上来。行程挺紧的，没什么时间好好拍。 第一天，上海。]]></content>
      <categories>
        <category>生活</category>
        <category>摄影</category>
        <category>旅游</category>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>photograph</tag>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[simpleTemplate.js 的三版本分化和新功能编写]]></title>
    <url>%2Fsimpletemplatejs-three-versions-and-new-features%2F</url>
    <content type="text"><![CDATA[考研之后终于有时间将拖了很久的simpleTemplate.js给写完了。 三版本和新功能写这篇文章的时间离同主题的上一篇文章已经太远了。距离上次大概实现了基本功能之后，又发生了很多事情，也对这个js库思考了不少，最后决定将这个库拆成三个版本，分别是bare版、regular版和advanced版。三个版本的功能是逐渐增加的，而各版本又在各自功能的要求上尽量做到完善和小型化。 例如bare版只有数据输出的功能，被我用来在之前某个chrome插件中使用。 回看以前自己写下的文字和代码，总有种陌生的熟悉感。然而新旧代码看似已经不同，实际要表达的思想却是一脉相承的，新的代码并不是重写，而是继承、改进和发展旧的代码。没有以前写下的代码就没有现在写出的代码，没有以前思考的基础就没有现在思考的凭依。因此这添加的新功能其实在旧功能写成之时，便拥有了出现的需求和生长的土壤。 然，新功能要出来，代码是会膨胀的，在某些用不上新功能的情况下，代码就成了冗余。故，分化出三个版本分别应付不同的情况。新功能就是出现三版本的原因。 新功能一：过滤器此功能的想法是结合了对输出数据的二次处理和判断的拓展。 在regular版中，数据输出只有纯输出功能，明显是不够的；判断只能判断数据域是否存在数据，或者数据是否为真，明显也是不够的。（代码中体现为简单的if (!data)）。 那么数据域允许形如javascript语句的语法如何？判断使用形如a &gt; b、a == b的语法如何？ 当然是可以的，但是这样实在没必要，那还不如直接eval罢？ 我思来想去，发现其本质其实都是对数据进行一连串的操作，每一个操作通过将上一个操作的输出作为输入而串起来，即使判断，例如大于判断，也可以理解成将上一个操作的结果作为左值传入进一个”大于”函数，输出了布尔值而已。 于是这样一来所有存在数据域的地方都可以统一配套上过滤器们就解决问题了。 ok，梳理一下。原来整个流程是这样的： 解析模板 -&gt; 生成模板对象 -&gt; 填充数据 -&gt; 渲染 现在需要增加一个执行过程： 解析模板 -&gt; 生成模板对象 -&gt; 填充数据 -&gt; 执行语句 -&gt; 渲染 另外解析模板也要改进以适合对新语法的解析。 过滤器语法形如：{=data | filter1 | filter2 1 | filter3 string &quot;string | &quot; } 解析语法变得太复杂，不考虑使用正则匹配了，尤其是需要分别识别引号内外的|和空格，太鬼畜了。 于是很感谢在大学的时候选修了编译原理，不然真不知道如何解决了。凭着半桶水的记忆和知识，写了一个简单的词法分析函数，把整串字符串扔进去就切出数据域和过滤器们以及参数了。具体代码有点长，也写得烂，就不贴出来了，请移步github查看，在parseStatement函数中。 但是仍然需要将需要解析的语句从最原始的模板文本中分离出来，这里就可以用正则了。离远一点看那个语法的形式，其实就是分成了有引号括住的字符和没有引号括住的字符，以及最开头有特定的符号。 于是正则就成这样：/\{\s*([&gt;|&lt;|!|@|=|#])(?:&quot;[^&quot;]*&quot;|[^\{\}&quot;]+)*\s*\}/g 执行执行写起来比解析容易多了，因为已经有既定的数据结构了。需要在这里稍微记录一下的就是串联执行过滤器的过程。 以下是只为了展示思路的精简代码。 123456789101112/*data structure：[ ['filter1'], ['filter2', 'arg21'], ['filter3', 'arg31', 'arg32']]*/for ( i = 0; i &lt; filterCount; i++ ) &#123; result = [result].concat( filters[i].slice( 1 ) ); result = func.apply( scope, result );&#125; 新功能二：错误提示写这么一个函数： 123456789101112131415161718var error = function ( level, type, location, message ) &#123; /* * @param level int, &#123;0:statement, 1:field, 2:runtime&#125; * @param type string * @param location &#123;string, int&#125; * @param message string */ throw ( 'Error\n' + '[Level]\n' + ['statement', 'field', 'runtime'][level] + '\n\n' + '[Type]\n' + type + '\n\n' + '[Location]\n' + location + '\n\n' + '[Message]\n' + message );&#125; 凡是在生成模板，渲染模板的时候遇到什么问题，直接调用这个函数。 所以其实没什么好说的，只是约定好错误提示的一些格式就可以了。 End.]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>string-template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深圳 EVA EXPO 2.0 相片选 [97p]]]></title>
    <url>%2Feva-expo-2-photos%2F</url>
    <content type="text"><![CDATA[这个展在深圳举办，持续一个月到 1.3。刚好我考研结束，于是就去咯。 由于我又不是宅男，所以没有加入什么宅的 QQ 群啊豆瓣小组什么的，于是只能自己盘算怎么去。最后是我爸和我一起去了。 本来深圳并不远，想去的话难度并不大，实际上我只是想顺便熟悉一下新买的 SONY RX100 的操作，刚好也觉得 EVA 这作品不错…… 废话不多说，下面基本都是图了。本来照了近二百六十张，就选了 97p 出来，再缩小了一下方便大家看。 不知道是不是因为非节假日，会场门可罗雀。 门口标志性的初号机头。 可爱的灯饰？ 进场内了。 展示的一些原画。 女神叫你喝，不喝还是人？！喝喝喝！ 书柜，丽战斗服 ver，手办 分镜～ 香香叫你买，不买还是人？！买买买！ 上二楼 实际上最后我什么都没有买 初号机和第三使徒水天使 游客的…… 寄语？ 各种奇怪海报 二楼的中间地方都是放手办和周边，多到离谱。 亚当？ 妹子也来照。 极其罕见的裸渚薰。 可爱系。 可爱的 penpen！ 继续无穷无尽的手办。 插入栓。 其实 EVA 里面我最喜欢的角色是明日香。 这 EVA 是哪个？ 看这可怜的小眼神。 LCL 咖啡…… 乱七八糟的周边。 下面六张女神照满足你们。 4 张二号机。 其他。 腐女都喜欢的渚薰。 三楼有点比较大型的东西。 司令模特是我爸 XD 诶那我不就变成真嗣了？！ 真希波人像。 明日香人像。 三楼有一个什么 3D 投影，其实没什么意思，就是将破中 3EVA 机对付空天使的奔跑的片段播放一遍。 然后是直接从三楼下去负一层看电影，其实就是将序播放一次，音效很差，我看了一会就走了。 出口。 总的来说还是不错的。]]></content>
      <categories>
        <category>摄影</category>
        <category>展览</category>
      </categories>
      <tags>
        <tag>photograph</tag>
        <tag>exhibition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顾自地对 simpleTemplate.js 进行优化]]></title>
    <url>%2Foptimize-simpletemplatejs-by-myself%2F</url>
    <content type="text"><![CDATA[simpleTemplate.js 的功能已经实现得差不多了，看能不能给它做一点优化。 测试框架随手写一个记录运行前后时间的。 12345678910111213141516171819202122232425262728293031323334&lt;script id=&quot;t_1&quot; type=&quot;x-tmpl-simpleTemplate&quot;&gt;&#123;@list&#125;&lt;p&gt;&#123;*&#125;&lt;/p&gt;&#123;-list&#125;&lt;/script&gt;&lt;script&gt;var template = simpleTemplate( document.getElementById( &apos;t_1&apos; ).innerHTML );var startTime, endTime, text, loop, loopLength, times, totalCount;totalCount = 0;for ( times = 0; times &lt; 10; times++ ) &#123; startTime = new Date().getTime(); // testfor ( loop = 0, loopLength = 10/*100/1000*/; loop &lt; loopLength; loop++ ) &#123; text = template.fill(&#123; // data &#125;).render();&#125; // end test endTime = new Date().getTime(); totalCount += ( endTime - startTime );&#125; // end tests forconsole.log( totalCount / 10/*100/1000*/ );&lt;/script&gt; 缓存数组长度说的是将以下代码： 1for ( var i = 0; i &lt; arr.length; i++ ) 改成： 1for ( var i = 0, length = arr.length; i &lt; length; i++ ) 从查阅网上的资料来看，这样改是有效的。这里 我用上面自己写的代码来测试。用一个随便生成的 1000 个元素的随机数数组来填充，然后渲染 100 次。以此作为一次测试，进行十次，再取平均数。 从测试来看，效果都不怎么样，没有多大提升的感觉。 字符串拼接老生常谈了。在写代码的时候我觉得使用数组的 push 最后 join 会比较快，但是网上说现代浏览器下用 += 更快，真是神奇了，通常感觉 += 都会比较慢的。 于是我去试了试，结果让人惊讶。在 chrome/IE78910 下都有性能提高，尤其是 chrome。 IE6789 的测试我是用 IE10 里面的开发人员工具切换模式来测试的，文档模式都是用 “标准”。 看图。1000 个数组数据，渲染 100 次，测试 10 次取平均。 IE 下的字符串之前为了绕开 IE8 以下的 split 函数 bug，我已经将代码重写了一次，利用了 lastIndex 属性。没想到这个 lastIndex 属性在 IE 下还是跟其他浏览器不一样，测试了一下似乎是在处理换行上有点问题，简直神烦。 于是我就将模板中所有的回车换行统统搞掉算了。 1return new Template( templateStr.replace( /[\r\n]/gm, '' ) );]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>string-template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[simpleTemplate.js 中列表渲染的改进]]></title>
    <url>%2Fimprove-list-feature-simpletemplatejs%2F</url>
    <content type="text"><![CDATA[无关痛痒的碎碎念在写上一篇博文的时候，我一边写文字一边看代码，同时将编写代码的思维写进博文。这个过程显然让我从跟编程时不同的角度来审视代码，由此也能发现代码中新的bug。由此可见，写博文对于重新理清思路，理解代码有非常大的帮助，是另一种意义上的“代码审查”。 另外在解释一些代码的时候，本以为自己是明白为何这样写的，但是一旦将这个“为何”形成文字，再看一遍，顿时就觉得其实并不是真的“懂”了，而是只是脑子里觉得“啊差不多是那个样子”，手就自然出代码了。然而一旦要解释给别人，要不就错漏百出要不就哑口无言。 也不知道现在搞技术的人有多少能写出详细的文章出来了，似乎很多理工科人都非常讨厌一直以来的语文教育，进而讨厌写文章，于是更不可能写出长篇幅、细致的文章来。 开始正文吧在上一篇文章中，simpleTemplate.js已经得到了极大的改造，能够识别和渲染标志位和列表。在文章的最后提到了实际上列表的渲染还没有完成，充其量只是实现了一个循环而已，于是本文就来继续完善。 要解决什么问题如何在列表渲染中得到跟本次渲染相关的临时数据。 在渲染，也就是执行_render函数的时候，可供渲染的数据源是指向固定但是内容未知的。数据源的指向取决于第一次执行_render时传入的参数（形参是scope），在函数内部递归调用的时候也是将这个数据传递给下一次调用执行。 然而，当在渲染列表的时候，渲染函数是已经确切得到了数据源的某一个数组型数据的（不然就无法根据这个数组进行递归），因此是绝对有能力提供这个数组的临时数据的。 什么是临时数据？这个名词是我自己编的。其实就是指遍历数组的过程中所产生的下标和下标所对应的数据。并不是什么很复杂的东西。 很简单，举个例子。比如有这么一个数据： 123&#123; name: ['Ada', 'Brown', 'Cindy']&#125; 配合这么一个模板： 1234567&lt;ul&gt;&#123;@name&#125; &lt;li&gt; &lt;/li&gt;&#123;-name&#125;&lt;/ul&gt; 如果要求是输出数组name中的所有名字，那么&lt;li&gt;和&lt;/li&gt;之间应该写什么？ 好吧实际上什么也写不了。 注意到在列表渲染的过程中，调用函数进行递归的时候，传入的数据跟当前正在执行的函数被调用时传入的数据是一样的，临时产生的数据根本就不能传过去。这难道就是世界上最遥远的距离？ 怎么给原始的数据添加进临时数据呢？ 首先想到也是立刻抛弃的想法就是直接在原始数据源中添加，因为之前也说过了，原始数据源是未知的。无论新添加的数据取什么样的键值（原始数据源是一个对象），都有可能会覆盖原来已经存在的数据。 将原始数据源和临时数据包装起来成一个新的数据，如何？ 且不论这样会大大增加渲染函数的复杂性，若是出现列表多层嵌套，这数据都成卷心菜了…… 作用域其实这个功能的实现的确有点像作用域。 在循环的外部，是一个作用域，称为A；在循环的内部，是另一个作用域，称为B。B可以访问A内定义的变量（数据），而A不应该访问B内定义的变量（数据）。 于是这里就是javascript中的原型链大显身手的时候了。（其实我也是借用了AngularJS中$scope的实现思路。） 将A作用域中的变量（数据）作为B作用域中的变量（数据）的原型（prototype），那么B中建立的数据就不会实质改写A中的数据（注意，只是大部分情况下。有某些特殊情况还是可以改写的），而在B中也能够读取到A中的数据。 强烈建议不明白原型链的人好好去了解一下。这个跟OOP中的继承是不同的概念，很多人可能会混淆了。 如何构造这个关系？让我们来站在巨人的肩膀上，使用大师Douglas Crockford的代码。 12345678// Thank you, Douglas Crockford.if ( typeof Object.create !== 'function' ) &#123; Object.create = function ( o ) &#123; function F() &#123;&#125; F.prototype = o; return new F(); &#125;;&#125; 经典的一段代码，出现在大师这篇文章。 简单来说，用法是这样的A = Object.create( B )，这样B就成为了A的原型。 在代码中的顶层空间中添加上大师的代码后，在渲染函数内找到渲染列表的代码中加入两行： 123456789101112131415case '@': // begin of listif ( Object.prototype.toString.call( data ) === '[object Array]' ) &#123; for ( var loopIndex = 0; loopIndex &lt; data.length; loopIndex++ ) &#123; // expend scope newScope = Object.create( scope ); newScope['*'] = data[loopIndex]; // recursively render tempFragment.push( _render.call( this, newScope, i + 1, functions['loop'][i]) ); &#125;&#125;// reset indexi = functions['loop'][i];break; 在新建的数据源newScope中，使用一个原则上不太可能会用来作为键值的*符号作为临时数据的键值。 于是之前的模板写成这样就达到要求。 1234567&lt;ul&gt;&#123;@name&#125; &lt;li&gt; &#123;*&#125; &lt;/li&gt;&#123;-name&#125;&lt;/ul&gt; 别忘了修改用于识别的正则表达式！ 1/\&#123;\s*([@|\-|!]?)(([\w\d]+|\*)(\.[\w\d]+)*)\s*\&#125;/gm 或许这里可能有人会吐槽说，如果原始的数据源中有一个键值是*的数据怎么办？这样不就被循环中的新数据源覆盖了吗？关于这点我想说的是如果产生原始数据源的程序员使用了这么奇怪无意义的键值，就真是脑残了。这个问题基本可以不讨论。]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>string-template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[simpleTemplate.js 中列表和标志位的功能的实现]]></title>
    <url>%2Fimplements-list-and-flag-in-simpletemplatejs%2F</url>
    <content type="text"><![CDATA[在上一篇文章中，为了一些实际需求，我写了一个非常理想化而基础的模板渲染js代码。但当我尝试将其实际使用的时候，却发现代码中不但问题不少，而且功能也不够，于是就只能继续改进。 文中所有代码都截取自js文件，稍有修改。你可以到github项目上找到完整代码，边对比边看本文。 绕开split函数在上一篇文章的更新里面提到，split函数在IE下有问题，只能放弃使用。 其实在使用正则匹配数据域（field，在模板中的形式是{field}）的时候，是能够同时获得最近一次匹配到的数据域的位置的。比如： 123var re=/\&#123;t\&#125;/g;re.exec('test&#123;t&#125;'); // ["&#123;t&#125;"]re.lastIndex; // 7 或者去看MDN加深了解。 于是这个lastIndex减去匹配出的数据域长度就可以确定数据域前一小节模板文本的结尾，然后对原始模板字符串使用slice函数切割出此一小节模板文本。下面是大概的代码。 1234567891011121314151617var lastIndex = 0;while ( ( mark = fieldRe.exec( str ) ) !== null ) &#123; /* other code... */ templateText.push( str.slice( lastIndex, fieldRe.lastIndex - mark[0].length ) ); lastIndex = fieldRe.lastIndex; /* other code... */&#125;if ( lastIndex &lt; str.length ) &#123; templateText.push( str.slice( lastIndex, str.length ) );&#125; 最后记得要检查一下完成匹配后的lastIndex值，因为有可能在最后一个数据域后还有一小段模板文本。 好了，现在已经绕开了split函数来将模板分成“文本”和“数据域”两个数组了。 .表示法原来的js代码中，作为field的命名，只能使用一般的命名，也就是带_的英文字母和数字的混合，但是用以填充的json数据不一定是“扁平化”的，换言之有可能是嵌套的，比如{&#39;a&#39;:{&#39;b&#39;:1}}。普通js代码中用a.b就能访问b的值。在模板解析中，我思考了这么一个方法来实现（如果有更好的方法请告诉我！） 将访问的路径用.分开，再逐层赋值，写成代码就是如下： 1234567891011121314151617var _getDataViaPath = function( path, json ) &#123; var fieldPath = path.split( '.' ), data = json, index; for ( index = 0; index &lt; fieldPath.length; index++ ) &#123; data = data[fieldPath[index]]; if ( data === undefined ) &#123; return ''; &#125; if ( data === null ) &#123; return index + 1 &lt; fieldPath.length ? '' : null; // maybe not necessary &#125; &#125; return typeof data === 'function' ? data.call( json/* maybe better than 'data' */ ) : data;&#125;, 在通过路径访问数据的时候，如果： 路径不存在，返回空字符串 路径存在，返回数据 第二行，以.为分割符将访问路径拆成数组。 第六行，通过遍历数组来逐层访问数据，如果途中遇到undefinded，即路径不存在，那么就直接返回空字符（如果直接返回undefined，那么在拼合字符串的时候，调用toString方法会返回字符串undefined，显然不是我们想要的）。 然而，路径存在的情况下，数据有可能为null，而null是不能再读取属性的，于是就看看是不是最后一个路径，不是就返回空字符（因为再走下去路径也不存在了），是就返回数据null。这里可能有点绕，并且其实空字符和null最后渲染出来的效果是一样的，似乎也没必要这么深究，但还是谨慎地区分一下比较好。 最后，返回数据的时候如果发现数据是函数，那么就执行了之后再返回。执行函数的时候总是要留意这个函数执行的context（上下文），这里给它绑定最顶层的数据好了，在函数体里面它喜欢访问哪个嵌套的数据都行。 使用.call()来调用函数，第一个参数是函数的context（上下文）。 然后问题来了，之前识别数据域的正则在加入.表示法功能后就不适用了。重写一下。 1/\&#123;\s*(([\w\d]+)(\.[\w\d]+)*)\s*\&#125;/gm 这样就既能匹配{field}，也能匹配{field.field}了。 标志位 &amp; 列表模板设计嗯，不知道这里说“标志位”是否准确，或者大家是否明白我要表达的意思，可能说“flag”会更容易理解？ 这里的标志位起这么一个作用，渲染的时候查看这个标志位，根据值（真/假）来决定是否渲染某一小段模板。 看代码： 123&lt;p&gt;&#123;!flag&#125;&lt;/p&gt;&lt;p&gt;&#123;field&#125;&lt;/p&gt;&lt;p&gt;&#123;!flag&#125;&lt;/p&gt; 这里的{!flag}表明渲染的时候先查看一下flag的值，如果结果为假，那么两个{!flag}所包围着的一小段模板就不渲染了。 至于列表，这样： 123&lt;p&gt;&#123;@list&#125;&lt;/p&gt;&lt;p&gt;&#123;something&#125;&lt;/p&gt;&lt;p&gt;&#123;-list&#125;&lt;/p&gt; 跟标志位类似，{@list}表明渲染的时候遍历list列表，每次循环都将{@list}和{-list}之间的模板渲染一次。 为什么使用@和-两个不同的符号？因为要支持嵌套，循环的头尾用不同符号便于配对。 12345&lt;p&gt;&#123;@list&#125;&lt;/p&gt; &lt;p&gt;&#123;@list1&#125;&lt;/p&gt; &lt;p&gt;&#123;something&#125;&lt;/p&gt; &lt;p&gt;&#123;-list1&#125;&lt;/p&gt;&lt;p&gt;&#123;-list&#125;&lt;/p&gt; 修改正则识别再次修改识别数据域的正则表达式： 1/\&#123;\s*([@|\-|!]?)(([\w\d]+)(\.[\w\d]+)*)\s*\&#125;/gm 编写渲染过程接下来是渲染的过程。先回顾一下一个生成好的模板对象的结构： 12345template = &#123; templateText: [], // 模板文本数组 fields: [], // 数据域数组 data: &#123;&#125; // 数据对象&#125; 所以模板对象 = 模板文本数组 + 数据域数组 + 数据对象。 我们稍微修改一下数据域数组的结构。 从类似[&#39;field1&#39;, &#39;field2&#39;, &#39;field1&#39;] 改成[[&#39;!&#39;, &#39;field1&#39;], [&#39;&#39;, &#39;field2&#39;], [&#39;!&#39;: &#39;field1&#39;]] 也就是说在每一个数据域中添加一个标识，用来辨别此数据域是否有特殊功能。这在生成模板的时候并不难实现。 当渲染进程遇到一个特殊功能的数据域，那么就应该去定位配对的下一个特殊数据域，两个特殊数据域中间的模板和数据域就需要特殊处理。 我们可以在生成时就记录好这个信息。在模板对象中增加一个functions对象，结构如下： 1234functions: &#123; loop: &#123;&#125;, flag: &#123;&#125;&#125; 循环/标记位的首尾就以键值对的方式记录在loop/falg中，这样在渲染时一查就行。 所以模板对象 = 模板文本数组 + 数据域数组 + 数据对象 + functions对象。 先将渲染函数独立出来成一个内部函数： 123456789101112131415161718192021222324252627282930313233_render = function( scope, start, end ) &#123; var tempFragment = [], strings = this.getTemplateText(), fields = this.getFields(), functions = this.getFunctions(), field, data, i; for ( i = start; i &lt; end; i++ ) &#123; tempFragment.push( strings[i] ); field = fields[i]; data = _getDataViaPath( field[1], scope ); switch ( field[0] ) &#123; case '': // normal data tempFragment.push( data ); break; case '@': // begin of list break; case '!': // begin of flag break; default: &#125; &#125; tempFragment.push( strings[i] ); // dont forget the last of strings return tempFragment.join( '' );&#125; 我来慢慢解释。 _render函数定义为传入数据、待渲染数据域开头的下标和待渲染数据域结尾的下标，会返回数据域数组两下标段间（包括开头不包括结尾）的渲染结果（一个字符串）。 开头各种变量定义自不用解释，主体部分是一个遍历，最后返回字符串。 要注意，因为分割原始模板字符串使用的分隔符是不同的数据域，所以分割出来的模板文本总是比匹配到的数据域数量多1。 举个例子，&#39;sgewgwgw,,seyer,jhrepbo,&#39;.split(/,/g)，匹配到的分隔符数量为4，分割后文本的数量为5。而任意两个分隔符之间的字符串也可以单独又看作一个待分割的字符串，继续分割后也跟整个字符串具有同样的性质。 画出图来的话就是如下： 整个函数执行过程看下图： 可以看到，循环要做的第一件事是压入模板文本，对应循环体内第一条语句tempFragment.push( strings[i] );。剩下的全是在处理数据，可以看到之前写的_getDataViaPath函数在这里用上了。最后在循环外压入最后一个模板文本，对应结束循环之后第一条语句tempFragment.push( strings[i] );。 来编写数据处理中遇到标志位的情况，对应switch语句中case &#39;!&#39;： 12345678case '!': // begin of flagif ( data ) &#123; tempFragment.push( _render.call( this, scope, i + 1, functions['flag'][i]));&#125;// reset indexi = functions['flag'][i];break; 十分简单，按照要求，判断值，再决定是否渲染两标志位间的模板。新加入的functions对象就在这里起重要作用了。 最后的i = functions[&#39;flag&#39;][i];是为了重置当前循环处理的位置（注意这个位置是整个数据域数组中的位置）。这里无需考虑超出下标的问题。 为什么不考虑？functions对象中指示的位置必须是正确，否则整个渲染过程就毫无运行的必要。 如果遇到列表： 123456789101112case '@': // begin of listif ( Object.prototype.toString.call( data ) === '[object Array]' ) &#123; for ( var loopIndex = 0; loopIndex &lt; data.length; loopIndex++ ) &#123; // recursively render tempFragment.push( _render.call( this, scope, i + 1, functions['loop'][i]) ); &#125;&#125;// reset indexi = functions['loop'][i];break; 这里需要先判断数据是否为数组，然后遍历数组，循环中渲染两个列表标志间的模板。其实跟标志位的过程差不多。 如果遇到普通数据： 123case '': // normal datatempFragment.push( data );break; 直接压入即可。 编写解析模板的过程嘿，先别高兴得太早了，虽然编写好了渲染过程，但是渲染是要基于已经生成好的模板的！ 别忘了在渲染中指路的重要的functions对象是还没有生成出来的！我们刚才只是在假设它已经能工作的前提下编程的！ 回到本文一开头切割原始模板字符串的代码中，我们需要在那里为以后的一切铺路。还记得那个处理正则匹配的while语句吗？ 前方代码高能注意。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var templateText = [], fields = [], lastIndex = 0, functions = &#123; 'loop': &#123;&#125;, 'flag': &#123;&#125; &#125;, flags = [], // flag stack loops = [], // loop stack flag, loop, mark;// initial data and indexthis.data = &#123;&#125;;while ( ( mark = fieldRe.exec( str ) ) !== null ) &#123; /* * mark[0] = '&#123;@fo.fo&#125;' * mark[1] = '@' * mark[2] = 'fo.fo' * mark[3] = 'fo' * mark[4] = '.fo' */ fields.push( [mark[1], mark[2]] ); templateText.push( str.slice( lastIndex, fieldRe.lastIndex - mark[0].length ) ); lastIndex = fieldRe.lastIndex; switch ( mark[1] ) &#123; case '@': loops.push( [mark[2], fields.length-1] ); break; case '-': if ( loops[loops.length-1] &amp;&amp; loops[loops.length-1][0] === mark[2] ) &#123; loop = loops.pop(); functions['loop'][loop[1]] = fields.length - 1; &#125; else &#123; return; &#125; break; case '!': if ( flags[0] &amp;&amp; flags[0][0] === mark[2] ) &#123; flag = flags.pop(); functions['flag'][flag[1]] = fields.length - 1; &#125; else &#123; flags.push( [mark[2], fields.length-1] ); &#125; break; default: &#125;&#125;if ( lastIndex &lt; str.length ) &#123; templateText.push( str.slice( lastIndex, str.length ) );&#125;if ( flags.length !== 0 || loops.length !== 0 ) &#123; return;&#125; 我们最后使用正则表达式是 1/\&#123;\s*([@|\-|!]?)(([\w\d]+)(\.[\w\d]+)*)\s*\&#125;/gm 在执行了exec之后，每一次匹配出来的结果都是一个数组，在注释当中我已经明确地指出每一个位置上的内容了。好好记住，开始解释代码。 首先第一句，生成数据域数组。在编写渲染过程一节中我已经说过了这个的数据结构已经改为每一个元素都是“特殊功能符号”和“数据路径”了。这一句非常好理解。 接着的两句就是熟悉的模板文本数组生成，是由于要绕开split函数所写。继续看下去。 好了，数据域数组和模板文本数组处理好了，模板对象 = 模板文本数组 + 数据域数组 + 数据对象 + functions对象，接下来是functions对象。 这里使用栈来检查特殊功能数据域是否匹配。 查看一下数据的特殊功能符号，如果遇到的一个列表的头： 123case '@':loops.push( [mark[2], fields.length-1] );break; 暂时先将它和它的位置压入栈loops。 如果遇到一个列表的尾： 12345678case '-':if ( loops[loops.length-1] &amp;&amp; loops[loops.length-1][0] === mark[2] ) &#123; loop = loops.pop(); functions['loop'][loop[1]] = fields.length - 1;&#125; else &#123; return;&#125;break; 检查栈loops中最近一次压入的数据，不存在或者不等于这个列表尾的情况都属于模板格式错误，直接退出。 否则就是匹配成功了，将列表头的位置作为键，列表尾的位置作为值放入functions对象的loop属性中。 如果遇到标志位： 12345678case '!':if ( flags[0] &amp;&amp; flags[0][0] === mark[2] ) &#123; flag = flags.pop(); functions['flag'][flag[1]] = fields.length - 1;&#125; else &#123; flags.push( [mark[2], fields.length-1] );&#125;break; 查找栈flags中最近一次压入的数据，跟本次标志位相等即匹配成功，不相等继续压入。 好了最后再检查一下两个栈是否为空，不为空则有些数据域没有匹配成功，也就是模板格式错误，打回。 123if ( flags.length !== 0 || loops.length !== 0 ) &#123; return;&#125; 呼！写到这里，我都怀疑是不是说得太罗嗦了。画公仔都画出肠了。 还没完！其实在渲染列表的时候，只是循环是没有多大意义的。更多时候，我们想输出的是列表中的内容。然而每次循环中需要输出的数据都不一样，怎么破？ 再写下去我估计你也不想看了，这个问题在下一篇文章中详细解释。]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>string-template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一段简单的js模板渲染代码]]></title>
    <url>%2Fa-piece-of-simple-javascript-for-template-render%2F</url>
    <content type="text"><![CDATA[前言在为一些页面写 javascript 的时候，发现经常出现如下的一种使用情况：通过AJAX请求数据，然后将数据填入 HTML 的模板中，最后将这段 HTML 插入或者替代到原网页中。 看到这样的使用情况，有所了解的人可能说直接上 jQuery 啦，用 $.get 之类的函数取到数据后再各种 DOM 操作，easy 啦～或者也有人说“嗯，这样的情况用 AngrularJS 或者 React 吧，国产的 AvalonJS 也不错哦”。嗯都说的没错，其实自己喜欢用哪个就用那个，顺手就好。 不过嘛，jQuery虽然厉害，但是在一些简单页面中带上一个压缩了也近 100k 的大库总感觉得不偿失（当然本身整个网站需要的话论外），而且实际用到的功能很少。 加上一些插件，jQuery 也有模板渲染功能啦。jQuery 本身也有 tmpl() 和 template()。 然后 AngularJS 之流嘛，好用是好用，只是有大材小用之感。 于是，勇敢的少年快起床找**勇敢的少年来写原生js吧！ 真实用例描述在做某个博客的一个页面的时候，需要拉取 github event 来展示。然而因为博客本身搭建在github上，只依靠github提供的Jekyll引擎渲染，毫无后端可言，因此不能直接生成带有数据的页面。于是就只能捎上个 AJAX 库（墙裂推荐jx，谁用谁知道），在页面载入后再请求 github 的数据。 看了看 github api 返回的内容，一个 event 的基本结构如下： 1234567891011121314151617181920212223242526272829303132333435&#123;"id": "2338198221","type": "PushEvent","actor": &#123; "id": 1171407, "login": "exoticknight", "gravatar_id": "", "url": "https://api.github.com/users/exoticknight", "avatar_url": "https://avatars.githubusercontent.com/u/1171407?"&#125;,"repo": &#123; "id": 24838315, "name": "scau-sidc/scau-sidc.github.io", "url": "https://api.github.com/repos/scau-sidc/scau-sidc.github.io"&#125;,"payload": &#123; "push_id": 472403458, "size": 1, "distinct_size": 1, "ref": "refs/heads/master", "head": "5a20542ff0ccd9b3b71dc393eeb45bb74b5f40dc", "before": "fb9144e0910813529f234cd00b24c4b0b21b67a2", "commits": [ &#123; "sha": "5a20542ff0ccd9b3b71dc393eeb45bb74b5f40dc", "author": &#123; "email": "draco.knight0@gmail.com", "name": "exoticknight" &#125;, "message": "037", "distinct": true, "url": "https://api.github.com/repos/scau-sidc/scau-sidc.github.io/commits/5a20542ff0ccd9b3b71dc393eeb45bb74b5f40dc" &#125; ]&#125;, 数据存在于各种路径中…… 然后是HTML模板： 123456&lt;div class=&quot;board-card mb4 p-responsive&quot; data-id=&quot;&#123;cid&#125;&quot;&gt; &lt;a alt=&quot;&#123;uname&#125;&quot; title=&quot;&#123;uname&#125;&quot; class=&quot;card-avatar&quot; target=&quot;_blank&quot; href=&quot;&#123;uurl&#125;&quot;&gt;&lt;img class=&quot;animated&quot; src=&quot;&#123;aurl&#125;&quot; alt=&quot;avatar&quot; /&gt;&lt;/a&gt; &lt;span class=&quot;card-type&quot;&gt;&#123;ctype&#125;&lt;/span&gt; &lt;small class=&quot;card-commits&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;&#123;curl&#125;&quot;&gt;&#123;chash&#125;&lt;/a&gt;&lt;/small&gt; &lt;p&gt;&#123;csummary&#125;&lt;/p&gt;&lt;/div&gt; 其实 HTML 模板代码是怎样没所谓，留意其中用 { 和 } 括住的东西就是了。那是 field name，{field} 最终会被替换成数据。 当我只想先快速解决的时候……直接一个replace了事…… 1234var fillTemplate = function( template, field, data ) &#123; re = new RegExp( '\\&#123;\\s*' + field + '\\s*\\&#125;', 'g' ); return template.replace( re, data || '' );&#125; 缺点也是简单易见的，因为只是替换了字符串再返回，所以如果替换了后的字符串（通常是数据）也包含 {field}，而下一次替换的 field name 刚好符合，那么最后生成出来的东西显然是错误的。 但是写起来快( ～’ω’)～ 当我有时间折腾的时候……来写一个容易让别人使用的js库吧。 先来想想自己究竟想要怎么用这个库开始。 我设想我将像如下那样的使用这个库： 123456789101112131415// 生成一个template对象var template = simpleTemplate( '&lt;div class="board-card mb4 p-responsive" data-id="&#123;cid&#125;"&gt;&lt;a alt="&#123;uname&#125;" title="&#123;uname&#125;" class="card-avatar" target="_blank" href="&#123;uurl&#125;"&gt;&lt;img class="animated" src="&#123;aurl&#125;" alt="avatar" /&gt;&lt;/a&gt;&lt;span class="card-type"&gt;&#123;ctype&#125;&lt;/span&gt;&lt;small class="card-commits"&gt;&lt;a target="_blank" href="&#123;curl&#125;"&gt;&#123;chash&#125;&lt;/a&gt;&lt;/small&gt;&lt;p&gt;&#123;csummary&#125;&lt;/p&gt;&lt;/div&gt;' );// 填充数据template.fill(&#123; 'cid': '1234567', 'uname': 'exo', 'uurl': 'http://test.com/test', 'aurl': 'http://test.com/test'&#125;).fill(&#123; 'csummary': '测试咯'&#125;);// 渲染var html = template.render(); 于是大概框架出来了。 1234567891011121314151617181920(function ( window, document, undefined ) &#123;var simpleTemplate = function( templateStr , prefix, suffix ) &#123; var template = function( str ) &#123; &#125; template.prototype.fill = function( jsonObj ) &#123; return this; &#125; template.prototype.render = function() &#123; &#125; return new template( templateStr );&#125;window.simpleTemplate = simpleTemplate;&#125;)( window, document ) 模板的处理思路，我思考了这么一个方法。 假设模板为 &lt;p&gt;{field1}&lt;/p&gt;&lt;p&gt;{field1}&lt;/p&gt;&lt;p&gt;{filed2}&lt;/p&gt;。 先将模板字符串使用 field 作为分隔符，使用 split() 来切分。（split() 支持正则真是太好了）因为 split 函数在IE中有比较严重的问题，IE8 中还没有改过来，所以在新版中只能换一个思路了，详情见下面的更新。 则得到一个字符串数组 text = [&quot;&lt;p&gt;&quot;,&quot;&lt;/p&gt;&lt;p&gt;&quot;,&quot;&lt;/p&gt;&lt;p&gt;&quot;,&quot;&lt;/p&gt;&quot;]，这个作为最后合成所需的数组之一。 12var splitRe = new RegExp( fieldPrefix + '\\s*\\w[\\w\\d]*\\s*' + fieldSuffix, 'g' )var templateText = str.split( splitRe ) 再对原模板字符串逐一匹配出 field，也组合成一个数组 indexs = [&quot;field1&quot;,&quot;field1&quot;,&quot;filed2&quot;]。这个数组的作用是标记 field 的位置。 在匹配中也将 field 编成一个字典，用来存储数据。这里就是{&#39;filed1&#39;:&#39;&#39;,&#39;field2&#39;:&#39;&#39;}。 1234while ( result = indexRe.exec( str ) ) &#123; this.data[result[1]] = ''; fieldIndexs.push( result[1] );&#125; 这样准备工作就完成了。 填充数据的工作就是简单的将数据存储进那个 field 作为 key 的字典。 12345for ( var name in jsonObj ) &#123; if ( this.data.hasOwnProperty( name ) ) &#123; this.data[name] = jsonObj[name]; &#125;&#125; 最后渲染，简单易懂就直接上代码吧。 1234for ( i = 0; i &lt; text.length; i++ ) &#123; temp.push( text[i] ); temp.push( this.data[indexs[i]] );&#125; 接着 temp.join(&#39;&#39;) 就可以生成最终的内容了。 这个方法因为将模板分割成小段字符串，所以不会存在重复渲染的问题。 应用的实例可以到这里查看。 代码还没有 push 上 github，所以以下贴完整代码，满足只看代码星人。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970(function ( window, document, undefined ) &#123;var simpleTemplate = function( templateStr , prefix, suffix ) &#123; var fieldPrefix = prefix ? '\\' + prefix : '\\&#123;', fieldSuffix = suffix ? '\\' + suffix : '\\&#125;', splitRe = new RegExp( fieldPrefix + '\\s*\\w[\\w\\d]*\\s*' + fieldSuffix, 'g' ), indexRe = new RegExp( fieldPrefix + '(\\s*\\w[\\w\\d]*\\s*)' + fieldSuffix, 'g' ); var template = function( str ) &#123; var templateText = str.split( splitRe ), fieldIndexs = []; // initial data and index this.data = &#123;&#125;; var result; while ( result = indexRe.exec( str ) ) &#123; this.data[result[1]] = ''; fieldIndexs.push( result[1] ); &#125; // getters this.getTemplateText = function() &#123; return templateText; &#125; this.getFieldIndexs = function() &#123; return fieldIndexs; &#125; &#125; template.prototype.fill = function( jsonObj ) &#123; for ( var name in jsonObj ) &#123; if ( this.data.hasOwnProperty( name ) ) &#123; this.data[name] = jsonObj[name]; &#125; &#125; return this; &#125; template.prototype.resetData = function() &#123; for ( var i in this.data ) &#123; this.data[i] = ''; &#125; &#125; template.prototype.render = function() &#123; var temp = [], text = this.getTemplateText(), indexs = this.getFieldIndexs(), i; // merge text array &amp; data array for ( i = 0; i &lt; text.length; i++ ) &#123; temp.push( text[i] ); temp.push( this.data[indexs[i]] ); &#125; // clean this.resetData(); return temp.join(''); &#125; return new template( templateStr );&#125;window.simpleTemplate = simpleTemplate;&#125;)( window, document ) 2014.11.06更新在IE678中，split 函数如果使用正则匹配作为参数，那么结果中的空字符会被“吞”掉。 看代码 123','.split(/,/g).length === 2; // true in non-IE','.split(/,/g).length === 0; // true in IE678 那么很明显如果我使用 split 函数的话，如果模板中出现 {field}{field} 的话，}{ 中的空字符就会没了，模板文本和数据域的位置会打乱。 于是就只能避免使用 split 函数，另辟蹊径。在解决这个问题的同时，我也在加上新的功能，简要来说就是支持列表循环和标志位了。最新的一个版本可以上github项目查看，算是本文中 js 的进化版。改进的思路我之后再写一篇博文来记录吧。]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>string-template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拔牙]]></title>
    <url>%2Fdental-extraction%2F</url>
    <content type="text"><![CDATA[身体放平躺在手术台，双手交叉轻放小腹，闭上双眼，缓慢呼吸两次，眉头难得地放松，往事便像歌剧一般在眼前上演。 “痛？” “嗯。” “给你打多点麻醉。” 对于习惯性麻醉自己的人，麻醉剂是不够的。 “开始拔了。” 器械在里面费力的扭动。我好像感受到什么但什么感觉都没有。 “好，拔完。” 当。 哪里传来清脆的金属撞击声，昭示着身体的一些东西被剥离了出来。 “咬紧。” 尽力让自己咬牙切齿，但似乎很难，不习惯做这种愤怒的表情。真是个善良的可怜虫。 然后以棉花代替了的那个部位开始清晰而又稳定地传来无法以想像来减轻的疼痛信号——如果脱了真能损伤智慧，那么原因一定是这噬心吮骨的失恋般的幽痛。 习惯性摸出手机打算拍一下那颗石头一般粘着血的东西，转念一想还是算了，往日之日不可留。 而且—— 还有三次。]]></content>
      <categories>
        <category>生活</category>
        <category>杂</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoolShell puzzle game 攻略]]></title>
    <url>%2Fcoolshell-puzzle-game-walkthrough%2F</url>
    <content type="text"><![CDATA[coolshell出了个游戏，网址点这里，奉上攻略。 第0关brainfuck语言，很久以前就觉得有意思。 自己看就算了，直接网上执行一次。点这个或这个或这个都可以。 得出是welcome.html。 第1关2, 3, 6, 18, 108, ? 2×3=6，3×6=18，6×18=108，18×108=1944 输入1944.html知道x=1944。 “生命、宇宙以及任何事情的终极答案”，42。输入42.html知道y=42。 1944×42=81648 得81648.html。 第2关那个键盘排布是dvorak方案，不同于我们平常的QWERT键盘方案。 直接上网找转换，那串字符转过来就是 main() { printf(&amp;unix[&quot;\021%six\012\0&quot;],(unix)[&quot;have&quot;]+&quot;fun&quot;-0x60);} 看起来就是C++语言。继续在线编译运行。运行出错，好吧。 按照collshell好像很喜欢IOCCC的尿性，用Google搜一些关键字，比如奇怪的&quot;&amp;unix&quot;，记得加上双引号。找到一个比较有用的解释。 学以致用，得出答案：unix 第3关扫描QR Code，得[abcdefghijklmnopqrstuvwxyz] &lt;=&gt; [pvwdgazxubqfsnrhocitlkeymj]。简单的字符替换。 在线解析QR code也可以，网址。 因为在浏览器下，直接用javascript写脚本了。OK……注意是后一个的字母替换前一个。 12345678910111213141516171819function decode(text) &#123; var newText=''; for (i=0;i&lt;text.length;i++) &#123; if (dict[text[i]]) &#123; newText += dict[text[i]]; &#125; else &#123; newText += text[i]; &#125; &#125; return newText;&#125;;dict=&#123;&#125;;ciper='abcdefghijklmnopqrstuvwxyz';alphe='pvwdgazxubqfsnrhocitlkeymj'for (i=0;i&lt;alphe.length;i++) &#123; dict[alphe[i]]=ciper[i];&#125;rawText='Wxgcg txgcg ui p ixgff, txgcg ui p epm. I gyhgwt mrl lig txg ixgff wrsspnd tr irfkg txui hcrvfgs, nre, hfgpig tcm liunz txg crt13 ra "ixgff" tr gntgc ngyt fgkgf.';console.log(decode(rawText)); 得到一段话：Where there is a shell, there is a way. I expect you use the shell command to solve this problem, now, please try using the rot13 of &quot;shell&quot; to enter next level. 就是说要用ROT13来转换shell这个字符串，得出是furyy 第4关左边就是告诉我们提取字符的模式： 每5个字符，看前两个和后两个，必须满足： 必须含一个大写字母和一个数字 是回文 而提取的字符则必须是小写字母。 The answer has been lost in the source则是说密文在源代码里面。有好一大串。 用正则吧，写出来就是([A-Z])([0-9])[a-z](\2)(\1)|([0-9])([A-Z])[a-z](\6)(\5)。 抱歉，更高级的写不出来了。 直接开sublime text 2，复制那段大串字符进去，搜索开启正则模式和区分大小写，得： 123456789E1v1E4FaF49XrX9O3i3O0MaM04GbG4M5l5M0WeW0Y0s0Y 取中间的variables就是答案。 第5关点图片，按后跳转，得一串数字，复制到地址栏，又是一串，好吧这模式都太无聊了。而且页面没有jQuery，先引入。 1234var jq = document.createElement('script');jq.src = "https://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js";document.getElementsByTagName('head')[0].appendChild(jq);jQuery.noConflict(); 接着模仿我之前写过的另外一个攻略里面的做法。 12345678url = 'http://fun.coolshell.cn/n/';urlreal=url + '32222';function g() &#123; $.get(urlreal, function(data)&#123; urlreal = url + data; console.log(data); &#125;)&#125; 之后就不断执行g()吧，最后答案是tree。 第?关最后tree.html跳回一开始了，不知道是不是我太渣已经过时了…… 突然想到可能会看reference，于是访问了一下前一个地址：fun.coolshell.cn/n/20446，再回头访问tree.html，可以了。 第6关算法……我等只会Google的渣渣就棘手了。 好歹用python写了还原树结构的代码，但是它说找deepest path就不懂了，看看有什么人有解释…… 最后还是得靠自己画树……借助python代码将节点关系打出来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/env python# -*- coding: utf-8 -*-__author__ = 'draco'class Node: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = rightdef binaryTreeFromInPostOrder(in_order, post_order): if len(in_order) == 0 or len(post_list) == 0: return None node = Node(post_order[-1]) node_index = in_order.index(node.value) node.left = binaryTreeFromInPostOrder(in_order[:node_index], post_order[:node_index]) node.right = binaryTreeFromInPostOrder(in_order[node_index+1:], post_order[node_index:-1]) return nodedef printLevel(q): global tree_structure next_level = list() this_structure = list() while len(q) != 0: node = q.pop(0) this_structure.append((node[0], node[1].value)) if node[1].left: next_level.append((node[1].value + "-l", node[1].left)) if node[1].right: next_level.append((node[1].value + "-r", node[1].right)) tree_structure.append(this_structure) return next_leveldef printTree(tree): current_level = list() n = 0 current_level.append(("None", tree)) while n &lt; 14: current_level = printLevel(current_level) n += 1in_list = "T b H V h 3 o g P W F L u A f G r m 1 x J 7 w e 0 i Q Y n Z 8 K v q k 9 y 5 C N B D 2 4 U l c p I E M a j 6 S R O X s d z t".split(" ")post_list = "T V H o 3 h P g b F f A u m r 7 J x e w 1 Y Q i 0 Z n G L K y 9 k q v N D B C 5 4 c l U 2 8 E I R S 6 j d s X O a M p W t z".split(" ")tree_structure = list()tree = binaryTreeFromInPostOrder(in_list, post_list)printTree(tree)for i in tree_structure: print(i) 输出结果： 1234567891011121314[('None', 'z')][('z-l', 'W'), ('z-r', 't')][('W-l', 'b'), ('W-r', 'p')][('b-l', 'T'), ('b-r', 'g'), ('p-l', '8'), ('p-r', 'M')][('g-l', 'h'), ('g-r', 'P'), ('8-l', 'L'), ('8-r', '2'), ('M-l', 'I'), ('M-r', 'a')][('h-l', 'H'), ('h-r', '3'), ('L-l', 'F'), ('L-r', 'G'), ('2-l', '5'), ('2-r', 'U'), ('I-r', 'E'), ('a-r', 'O')][('H-r', 'V'), ('3-r', 'o'), ('G-l', 'u'), ('G-r', 'n'), ('5-l', 'v'), ('5-r', 'C'), ('U-l', '4'), ('U-r', 'l'), ('O-l', 'j'), ('O-r', 'X')][('u-r', 'A'), ('n-l', '0'), ('n-r', 'Z'), ('v-l', 'K'), ('v-r', 'q'), ('C-r', 'B'), ('l-r', 'c'), ('j-r', '6'), ('X-r', 's')][('A-r', 'f'), ('0-l', '1'), ('0-r', 'i'), ('q-r', 'k'), ('B-l', 'N'), ('B-r', 'D'), ('6-r', 'S'), ('s-r', 'd')][('1-l', 'r'), ('1-r', 'w'), ('i-r', 'Q'), ('k-r', '9'), ('S-r', 'R')][('r-r', 'm'), ('w-l', 'x'), ('w-r', 'e'), ('Q-r', 'Y'), ('9-r', 'y')][('x-r', 'J')][('J-r', '7')][] 然后手动画树！最后得到最深路径是zWp8LGn01wxJ7。 Linux下执行： echo U2FsdGVkX1+gxunKbemS2193vhGGQ1Y8pc5gPegMAcg=|openssl enc -aes-128-cbc -a -d -pass pass:zWp8LGn01wxJ7 得到nqueens。终于过了。 第7关好吧八皇后。说实话我从来都不太想在做类似的游戏时写算法，又不是什么ACM做题，唉。直接Google N皇后算法的python算法，解出N=9的所有解，352个解，是时候用暴力手段了。 只是它这个code和通常表示八皇后解的数字不一样，正常是从上到下从左到右记录，它这个是从下到上从右到左记录…… 暴力出全部解之后其实都一样啦。 结合sha1解密验证的代码： 1234567891011121314151617#!/usr/bin/env python# -*- coding: utf-8 -*-__author__ = 'draco'from itertools import *import hashlibc = (1,2,3,4,5,6,7,8,9)nq = [v for v in permutations(c) if 9==len(&#123;v[i-1]+i for i in c&#125;)==len(&#123;v[i-1]-i for i in c&#125;)]for q in nq: code = "".join(map(str, q)) s = hashlib.sha1() s.update("zWp8LGn01wxJ7" + code + "\n") if s.hexdigest() == "e48d316ed573d3273931e19f9ac9f9e6039a4242": print(code) break 得出答案：953172864 第8关好吧26进制 A=1, B=2, … , Z=26 于是AA=26^11+1, ZZ=26^126+26, AAA=26^21+26^11+1, … 算出来是85165，然后还要转字符……是DUYO。 第9关根据图片搜出来是Pigpen Cipher，上wiki查到对应英文。 答案是helloworld。 啊终于通关了，看top100，排53。 本文被原作者指出会破坏游戏公平性，故在活动结束之后才重新发布……当时自己考虑不周给各位道歉了OTL。]]></content>
      <categories>
        <category>技术</category>
        <category>黑客</category>
        <category>编程语言</category>
        <category>python</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>python</tag>
        <tag>walkthrough</tag>
        <tag>quiz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中有趣的zip函数]]></title>
    <url>%2Fpython-interesting-function-zip%2F</url>
    <content type="text"><![CDATA[懂python的都知道有一个内置函数zip，作用是将多个序列里面的对应组合起来。 直接上图。 图中a1、a2、result都是序列。zip在执行的时候将序列a1中的一个元素取出，再取出序列a2对应位置中的元素，组合成一个tuple，最后将这些tuple组合成一个数组。 所以，最后我们得到一个数组result=[(1,a),(2,b),(3,c),…] 所以这个zip的意思理解成拉链比较形象。 两个序列是两边的链，zip函数将它们拉上组合起来。 当然zip函数可接收多个序列。 然后很有趣的事情就来了，如果在这之后再执行zip(*result)，就可以取回序列a1和序列a2！ 代码上看更直观。 1234567&gt;&gt;&gt; a1 = [1, 2, 3]&gt;&gt;&gt; a2 = ['a', 'b', 'c']&gt;&gt;&gt; result = zip(a, b)&gt;&gt;&gt; result[(1, 'a'), (2, 'b'), (3, 'c')]&gt;&gt;&gt; zip(*result)[(1, 2, 3), ('a', 'b', 'c')] 注意到result前有一个*号，这其实是告诉zip函数传入的是一个序列，于是result从一个参数变成了多个参数了。 从zip([(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)])变成了zip((1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;))了。 于是也就不难理解为什么能拆回来。 图示就是如下。 实际上起到了unzip的作用了～ python还真是可愛い～]]></content>
      <categories>
        <category>技术</category>
        <category>杂谈</category>
        <category>编程语言</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为上一篇分析如何保存网络广播的博文追加一个脚本]]></title>
    <url>%2Fappend-a-python-script-for-last-post-about-saving-internet-radio%2F</url>
    <content type="text"><![CDATA[在 上一篇博文 中，只是给出了提取“響”上的广播的 mms 协议地址的脚本，这些地址使用某雷来下载就可以了。但是其中有一节提到音泉上的广播是可以直接提取到 mp3 的地址的，这就意味着可以直接使用 http 协议来下载。 于是我今天下午写了一个辅助的 python 脚本出来，方便自己用。 直接上代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/usr/bin/env python# _*_ coding: utf-8 _*_from bs4 import BeautifulSoupimport argparseimport urllib2import sysimport jsondef download_audio(name, proxy): print("collecting information...") try: respose = urllib2.urlopen(u"http://www.onsen.ag/data/api/getMovieInfo/&#123;name&#125;".format(name=name), timeout=60) bangumi = json.loads((respose.read())[9:-3]) except Exception, e: print("Error:&#123;0&#125;".format(e)) return path = bangumi["moviePath"]["pc"] filename = path[path.rindex("/")+1:] print("downloading...") if proxy is None: import urllib urllib.urlretrieve(path, filename=filename) else: if proxy[0] == "http": # not sure whether this works... import urllib urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler(&#123;"http": proxy[1]&#125;))) urllib.request.urlretrieve(path, filename=filename) elif proxy[0] == "socks": proxy_ip, proxy_port = proxy[1].split(":") import socks import socket socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, proxy_ip, int(proxy_port)) socket.socket = socks.socksocket import urllib urllib.urlretrieve(path, filename=filename)def download_images(name): print("collecting information...") soup = BeautifulSoup(urllib2.urlopen(u"http://www.onsen.ag/program/&#123;name&#125;/".format(name=name), timeout=60)) print("downloading...") for pic in soup.select(".newProgramLeft &gt; img"): path = pic["src"] filename = path[path.rindex("/")+1:] import urllib urllib.urlretrieve(u"http://www.onsen.ag/program/&#123;name&#125;/".format(name=name) + path, filename=filename)def process(option, proxy): print("processing...&#123;0&#125;".format(option.name)) if option.image: print("download images:") download_images(option.name) if option.audio: print("download audio:") download_audio(option.name, proxy) print("Completed.")if __name__ == "__main__": parser = argparse.ArgumentParser(version="1.0") parser.add_argument("-i", "--image", action="store_true", dest="image", help="download images") parser.add_argument("-a", "--audio", action="store_true", dest="audio", help="download audio") proxy_group = parser.add_mutually_exclusive_group() proxy_group.add_argument("--NOPROXY", action="store_true") proxy_group.add_argument("-p", "--proxy", nargs=2, action="store", dest="proxy", help="set the proxy address", metavar=("http/socks", "PROXY_ADDRESS")) parser.add_argument("name", action="store", help="list of bangumi name, name") SUPPORT_PROXY = ["http", "socks"] try: args = parser.parse_args(sys.argv[1:]) except argparse.ArgumentError, e: print("bad options: &#123;0&#125;".format(e)) except argparse.ArgumentTypeError, e: print("bad option value: &#123;0&#125;".format(e)) else: if args.NOPROXY: process(args.name, None) else: if args.proxy[0] not in SUPPORT_PROXY: print("proxy type &#123;0&#125; is not supported!".format(args.proxy[0])) else: process(args, args.proxy) 脚本没什么好解释的，流程就是解析参数→执行 process 函数→调用图片下载函数 / 音频下载函数。其中的过程不过是上一篇文章中分析的结果而已。 注意这个脚本需要配合 SocksiPy 来使用，就是一个 socks.py 的文件而已，点击下载。 为什么这么蛋疼，因为 urllib 不支持 socks 代理…… 而我使用的日本代理就是用 socks 的…… 我没有日本 ip 的 http 代理，所以无法测试 http 代理是否有效。如果有好心人测试一下，出问题的话请给我发邮件：draco.knight0#gmail.com 最后再说说怎么用吧，方便那些连命令行都不会打的人。 一般来说，如果你要下载一个广播，比如新番玻璃之唇的广播，那么你在访问这个广播在音泉上的主页，网址就是：http://www.onsen.ag/program/glasslip/ 看到 “program/” 后面的 “glasslip” 了吗？这个是广播的标识。 那么你就在控制台运行： 1python onsen.py -a -i --NOPROXY glasslip 参数 -a 代表下载音频，也可以用长参数 --audio 参数 -i 代表下载图片，也可以用长参数 --image 参数 --NOPROXY 表示不使用代理 而因为音泉限制日本 ip，所以我花了大力气来支持代理的下载。 比如你有一个使用 socks 协议的代理，本机开启的端点是 127.0.0.1:8080。 那么就这样用： 1python onsen.py -a -i -p socks 127.0.0.1:8080 glasslip 运行完之后大概会输出这么的东西： 12345678processing...glasslipdownload images:collecting information...downloading...download audio:collecting information...downloading...Completed. 就表示搞掂了，在脚本目录下找图片和 mp3 吧。 一时忘了怎么用，直接加 -h 参数就可以了。 1python onsen.py -h]]></content>
      <categories>
        <category>技术</category>
        <category>黑客</category>
        <category>编程语言</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>script</tag>
        <tag>spider</tag>
        <tag>scraper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何保存一些网络广播]]></title>
    <url>%2Fhow-to-save-internet-radio%2F</url>
    <content type="text"><![CDATA[近来一直有在网上听一些动画的广播以及网络广播。而因为广播每周都有放送，如果错过了这周，下一周就没得再听了（有些可以付费重新听，相当于不可能再听了）。那么本周的广播其实可以先保存下来，等到有时间的时候再听。经过了一段时间的摸索，的确摸到了一些门路，于是总结一下整个流程的技术。这些广播实质上就是一些网络媒体，和平常在音乐网站听音乐等其实是一样的，因此这些获取方法应该也基本适用。 边用边分析——響篇 提取媒体位置——響篇 使用特定的工具 另一个例子——音泉篇 使用插件或工具下载 编写脚本 福利 边用边分析——響篇下面以我经常去的 響 - HiBiKi Radio Station - 为例子。 打开网站。 大概浏览一下整个页面，可以看到分成几个区域，新闻区、播放器区、节目列表区、广告区。 新闻区会更新广播的信息，一般是得知新广播推出的来源。 播放器区，这个是重点。一般看播放器就大概知道获取广播的难度。 节目列表区，这种涉及和网站交互的区域是搞懂网站架构的好地方。 广告区，并非没用，有时会出现一些新广播或者新广播站的消息。 随便点一个广播，就这个吧，妹ちょ。らじお。 按 F12 打开 chrome 的开发者工具。什么？你不是在用 chrome？那你自己看着办。 来看看控制台输出了什么？（红色的是资源获取失败，是我的网络原因，可以忽略） 看起来是一些调试信息。这应该不是 javascript 输出的信息，一般 js 代码输出的信息在右边会有代码行数提示。 看到两行比较感兴趣的输出： connectiong Stream-&gt;rtmpe://cp209391.edgefcs.net/ondemand/ DetailsLoad-&gt;urlhttp://image.hibiki-radio.jp/uploads/data/channel/imocyo/description.xml 第一个有单词 stream，而且后面的网址使用 rtmpe 协议。（什么协议，我没看过……） 第二个看到一个 xml 文件位置，url 中有 imocyo，是广播题目妹ちょ的罗马拼写，看来就是跟广播有关的东西，点进去看看。 可以看到这么一些 xml 文件内容。 1234567891011&lt;data&gt;&lt;title &gt; 妹ちょ。らじお&lt;/title&gt;&lt;cast&gt;&lt;name &gt; 橋本ちなみ&lt;/name&gt;&lt;name &gt; 金元寿子&lt;/name&gt;&lt;/cast&gt;&lt;outline&gt;絶賛放送中の TV アニメ『最近、妹のようすがちょっとおかしいんだが。』のラジオ番組！ 神前美月役の橋本ちなみさんと桐谷雪那役の金元寿子さんが番組を担当。 第 5 回より「妹ちょ。らじお」は毎週土曜日の更新へ変更となります。 ラジオ大阪 OBC [1314kHz]では毎週金曜日 24 時 30 分～25 時にて放送！&lt;/outline&gt;&lt;link&gt;http://hibiki-radio.jp/description/imocyo&lt;/link&gt;&lt;/data&gt; 看起来就是一些配置信息。 回头再来看首页的播放器，右边的是不是就是 xml 文件里面的内容啊？看来这个 xml 就是播放器请求的了。 顺手右击一下播放器，看看弹出的菜单。嗯，看来是 flash 了，可能就比较麻烦了。 为什么说是 flash 就比较麻烦呢？因为 flash 作为组件，内部是对浏览器屏蔽的，也就是说它搞了什么，浏览器基本是不清楚的，包括它向哪里请求了什么。通常情况下，flash 请求的是流媒体，很多是没有缓存的。 比较幸运的是这个 flash 自己输出了一些调试信息，也算有迹可寻。 如果连控制台输出都没有，那怎么办呢？其中一种方法是可以用硕思闪客精灵反汇编这个 flash 的 swf 文件，在文件内部找 url。这个方法可能涉及到版权或法律问题，就不在这叙述。另外一种方法操作上比较难，就是监听网卡。这个算是终极手段，因为所有的网络进出信息都可以捕捉到，但是技术要求也是最高的（我自己尝试过，收获不多就另辟蹊径了）。 ok，现在保持控制台打开的状况，点击播放。 听到了橋本ちなみ和金元寿子的声音。 再看控制台，哦真给力，呕吐一样输出一堆东西。 显然最有用的就是那一行。 1stream-&gt;mp4:140614_imocyo_140614_imocyo.mp4?di=910&amp;si=609&amp;pi=2806&amp;gi=6498&amp;gc=6&amp;bi=57971&amp;bc=imocyo&amp;ei=717045&amp;ec=140614_imocyo&amp;vi=4102269&amp;vc=140614_imocyo&amp;msi=516&amp;mc=&amp;ni=1625?1405751016018 一看到 mp4，感觉已经摸到了这个资源了，而且名字很明显是 140614_imocyo_140614_imocyo.mp4，后面的形似? xx=xxx&amp;xx=xxx 的东西是一些请求的参数。 这名字，一看就知道格式是：日期_名字_日期_名字_.mp4，也就是说 14 年 6 月 14 日的妹ちょ广播。这些信息说不定有用，先记录下来。 尝试和前面的网址结合起来得到 cp209391.edgefcs.net/ondemand/140614_imocyo_140614_imocyo.mp4，放到地址栏访问一下，啥都没有。嗯，预料之内，有可能是协议问题，也有可能是路径不对。 上网搜索一下 rtmpe 协议，发现叫实时消息传送协议协议，是 Adobe 公司的（好吧又是你）。搜索出来的结果基本都是有关怎么下载这些协议的流媒体的。基本就是介绍什么软件什么软件的，个人比较讨厌这些使用乱七八糟软件的方法，而且基本也是不凑效的。 将关键字改为 download rtmpe 一搜，发现一个 rtmpdump 的命令行工具，声称通杀这类协议。但是一看文档，嗯，暂时不想深究。看看有没有其他方法吧。 留意到播放器里面有个“详细”，点击一下跳转到一个网页 http://hibiki-radio.jp/description/imocyo。 看来就是个节目的详细介绍页面，估计网址格式是：hibiki-radio.jp/description / 节目名字。 拉到最下面，终于发现突破口！ 提取媒体位置——響篇页面中内嵌了一个 WMP（Windows Media Player）组件，虽然这个也是跟 flash 一样的组件，但是并没有 flash 那样让人讨厌。根据我的经验，WMP 播放的媒体是可以手动提取的。现在就来试试。 打开开发者工具，审查这个插件元素，可以看到是一个 &lt;embed&gt; 标签，属性 src 就是一个网址 http://www2.uliza.jp/IF/WMVDisplay.aspx?clientid=910&amp;playerid=2869&amp;episodeid=140614_imocyo&amp;videoid=140614_imocyo-wm&amp;vid=4102271&amp;memberid=&amp;membersiteid=516&amp;nickname=&amp;sex=&amp;birthday=&amp;local=&amp;mode=1。 点击访问发现下载了一个文件 140614_imocyo-wm.asx。 用记事本打开，内容如下： 1&lt;ASX version = &quot;3.0&quot;&gt;&lt;entry&gt;&lt;title&gt;[毎]140614_妹ちょ。らじお #23&lt;/title&gt;&lt;Ref href =&quot;mms://wms.uliza.jp/uliza/910/140614_imocyo_140614_imocyo-wm.wma&quot;/&gt;&lt;/entry&gt;&lt;/ASX&gt; 出来了！看到那个 mms://wms.uliza.jp/uliza/910/140614_imocyo_140614_imocyo-wm.wma 了吗？wma 就是一个音乐文件。mms 协议的文件是能够使用迅雷来下载的。Mission completed. 使用特定的工具在分析的时候不是发现了一个叫 rtmpdump 的命令行工具吗？现在来看看怎么使用。 尝试以各种关键字组合起来搜索，比如 download rtmpe mp4、how to downlaod rtmpe with rtmpdump…… 最后得到一个可用的命令：rtmpdump -r &quot;rtmpe://cp209391.edgefcs.net/ondemand/&quot; -y &quot;mp4:140614_imocyo_140614_imocyo&quot; -o test.flv 可以看到，其实就是组合了一直分析下来的网址。下图就是正在下载的窗口。 Boom! 这可比乱七八糟的软件好用多了。 另一个例子——音泉篇现在再来看另外一个例子，另一个广播比较多的网站，音泉。 先看一下网站，嗯比 hibiki 好看多了。 网站的区域分布也跟 hibiki 大同小异。播放器也是 flash。 播放之后看不到什么输出，只是看到一个请求：http://www.onsen.ag/data/api/getMovieInfo/aldnoah?callback=callback&amp;_=1405758148110。 可以看得出格式是：www.onsen.ag/data/api/getMovieInfo / 节目名字。后面的参数是代码回调和当前的时间。 直接访问这个网址，得到： 1callback(&#123;"type":"sound","thumbnailPath":"\/program\/aldnoah\/image\/128_pgi01_m.jpg","moviePath":&#123;"pc":"http:\/\/onsen.b-ch.com\/radio\/aldnoah140712Zf8j.mp3","iPhone":"http:\/\/onsen.b-ch.com\/radio\/aldnoah140712Zf8j.mp3","Android":"http:\/\/onsen.b-ch.com\/radio\/aldnoah140712Zf8j.mp3"&#125;,"title":"\u30a2\u30eb\u30c9\u30ce\u30a2\u30fb\u30e9\u30b8\u30aa","personality":"\u96e8\u5bae\u5929\uff08\u30a2\u30bb\u30a4\u30e9\u30e0\u30fb\u30f4\u30a1\u30fc\u30b9\u30fb\u30a2\u30ea\u30e5\u30fc\u30b7\u30a2 \u5f79\uff09 \/ \u6c34\u702c\u3044\u306e\u308a\uff08\u30a8\u30c7\u30eb\u30ea\u30c3\u30be \u5f79\uff09","guest":"","update":"2014.7.12","count":"03","schedule":"\u6bce\u9031\u571f\u66dc\u65e524:30\uff5e\u66f4\u65b0","optionText":"\u30a2\u30cb\u30d7\u30ec\u30c3\u30af\u30b9","mail":"aldnoah@onsen.ag","copyright":"\u00a9Olympus Knights\uff0fAniplex\u30fbProject AZ","url":"aldnoah","link":[],"recommendGoods":[],"recommendMovie":[&#123;"imagePath":"\/program\/gochiusa\/image\/34_pgi01_b.jpg","url":"\/program\/gochiusa\/"&#125;],"cm":[],"allowExpand":"false"&#125;); 就是个 json 而已，上 jsnice 整理一下得： 123456789101112callback(&#123; "type" : "sound", "thumbnailPath" : "/program/aldnoah/image/128_pgi01_m.jpg", "moviePath" : &#123; "pc" : "http://onsen.b-ch.com/radio/aldnoah140712Zf8j.mp3", "iPhone" : "http://onsen.b-ch.com/radio/aldnoah140712Zf8j.mp3", "Android" : "http://onsen.b-ch.com/radio/aldnoah140712Zf8j.mp3" &#125;, "title" : "\u30a2\u30eb\u30c9\u30ce\u30a2\u30fb\u30e9\u30b8\u30aa", "personality" : "\u96e8\u5bae\u5929\uff08\u30a2\u30bb\u30a4\u30e9\u30e0\u30fb\u30f4\u30a1\u30fc\u30b9\u30fb\u30a2\u30ea\u30e5\u30fc\u30b7\u30a2 \u5f79\uff09 / \u6c34\u702c\u3044\u306e\u308a\uff08\u30a8\u30c7\u30eb\u30ea\u30c3\u30be \u5f79\uff09", "guest" : "","update":"2014.7.12","count":"03","schedule":"\u6bce\u9031\u571f\u66dc\u65e524:30\uff5e\u66f4\u65b0","optionText":"\u30a2\u30cb\u30d7\u30ec\u30c3\u30af\u30b9","mail":"aldnoah@onsen.ag","copyright":"\u00a9Olympus Knights\uff0fAniplex\u30fbProject AZ","url":"aldnoah","link": [],"recommendGoods": [],"recommendMovie": [&#123;"imagePath":"/program/gochiusa/image/34_pgi01_b.jpg","url":"/program/gochiusa/"&#125;],"cm": [],"allowExpand":"false"&#125;); 看到第四行 &quot;moviePath&quot; 下的 http://onsen.b-ch.com/radio/aldnoah140712Zf8j.mp3 了吗？熟悉的 mp3 格式。 文件位置格式是：onsen.b-ch.com/radio/ + 节目名字 + 6 位日期 + 4 位随机字符 + .mp3。 于是广播也 get だぜ～ 举了两个详细的例子，一些更简单的就不再详述了。只要你活用开发者工具，很容易就找到地址的。有的广播比如 Aniplex 旗下的动画，会做一个官网，查看网页的源代码就直接能找到音频的地址。 使用插件或工具下载浏览器能帮我们做到很多事情。因为从网络上来的东西，最后都是交给浏览器来解析的（flash 这类内嵌的组件除外）。也就是说，浏览器是知道我们想保存的下来的资源的位置和内容的，只要告诉浏览器给我们就行了，这也就是比较早期的时候，一些教程教授的从缓存文件夹中复制出文件的技术基础。不过现代浏览器有插件，就不用那么复杂了。安装上了插件，会自动给你提取出网页中可能存在的多媒体文件（音乐 / 视频 / 图片 /…）。 比如音泉 随便点击一个节目，在播放的同时，能够捕捉多媒体的插件就抓到资源了。 直接点击下载就 ok 了，容易吧。这些插件在 chrome 商店一搜一大堆，其他现代浏览器比如 FireFox 和 Opera 也是有这类插件。IE…… 我就不太清楚了。 BTW，这个网站访问是没问题的，但是媒体资源例如 mp3 和 mp4 等是限定日本 IP 的，请自备梯子。 编写脚本以下是比较高阶的使用，电脑小白可以跳过了。 为什么在已经能够下载媒体的情况下，还要写脚本？~~ 装逼~~ ~~ 懒~~ 咳咳，不是啦，其实是使用脚本能够快速和自动化啦（诶偷懒好像说对了…… 鉴于访问外国网站的不稳定性（为了能截到博文中的漂亮的大图，我整个下午在不断地刷新……），这些广播网站经常是比较卡的。使用脚本能够只请求最小的资源就能提取出媒体的位置，比起每次打开网页快多了。当然你听一个两个广播还好，我要听十来个广播我是受不了的。如果能做到高度自动化，鼠标点两下，资源就自动躺在你面前了岂不妙哉？ 废话不多说，直接上代码。 1234567891011121314151617#!/usr/bin/env python# _*_ coding: utf-8 _*_from bs4 import BeautifulSoupimport urllib2import sysdef mms_extract(url): soup = BeautifulSoup(urllib2.urlopen(url)) return soup.select("ref")[0]["href"]name_list = sys.argv[1].split(",")for name in name_list: soup = BeautifulSoup(urllib2.urlopen(u"http://hibiki-radio.jp/description/&#123;name&#125;".format(name=name), timeout=30)) mms = soup.select("div.hbkDescriptonContents embed")[0]["src"] print mms_extract(mms) 这个是提取广播站響的广播音频地址，简单易懂吧？ 先通过请求地址 http://hibiki-radio.jp/description / 节目名字 来获得节目详细页面。还记得这里的地址吗？是在分析的过程得知的。 注意这里获得到的网页文件只是一些代码和文字， 没有图片或者这个页面再请求的其他资源 。 接着是用 BeautifulSoup 在这个页面中提取出 &lt;embed&gt; 标签中的 src 属性值，再请求一次那个 asx 文件，在 asx 文件中取到最终要得到的 mms 协议地址。 使用的时候可以这样用： 1python hibiki.py 节目名字[, 节目名字] 而如果你想使用 rtmpdump 来下载，也不是不可能，但是思维就完全不一样。先来看看 rtmpdump 的使用： 1rtmpdump -r "rtmpe://cp209391.edgefcs.net/ondemand/" -y "mp4:140614_imocyo_140614_imocyo" -o test.flv 重点是要得到 -y 参数里面的名字，这就需要你清楚节目更新的日期和节目名字的代号。 123456789101112131415161718#!/usr/bin/env python# _*_ coding: utf-8 _*_from datetime import datedef get_date(delta=0): """ :return: formatted date, i.e. 140505 """format ="%y%m%d" day = date.today() if delta != 0 and isinstance(delta, int): day = day + timedelta(days=delta) return day.strftime(format)def get_download_command(bangumi, output_name): return "rtmpdump -r \"rtmpe://cp209391.edgefcs.net/ondemand/\"-y \"mp4:&#123;date&#125;_&#123;bangumi&#125;_&#123;date&#125;_&#123;bangumi&#125;\"-o &#123;output&#125;.flv".format(bangumi=bangumi, date=get_date(), output=output_name) 福利：一些广播网站地址インターネットラジオ ·TV の番組表 響 - HiBiKi Radio Station - インターネットラジオステーション＜音泉＞ Lantis web radio 超！A&amp;G | AM1134kHz 文化放送 JOQR]]></content>
      <categories>
        <category>技术</category>
        <category>黑客</category>
        <category>杂谈</category>
        <category>编程语言</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>script</tag>
        <tag>spider</tag>
        <tag>scraper</tag>
        <tag>bytalk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四川实训遗诗一首]]></title>
    <url>%2Fa-poem-after-the-train-in-sichuan%2F</url>
    <content type="text"><![CDATA[癸巳年六月，入蜀实训，郁郁而周游。登青城、峨嵋，过乐山，临都江堰，拜杜甫草堂。然最是安逸处，除乐山大佛旁无人游览之东坡楼外无他。 入蜀 皇令今入蜀，至秋不得归。 万里马前尘，三更枕上泪。 乐山风花瘦，金顶日月亏。 独上东坡楼，公与吾与谁？]]></content>
      <categories>
        <category>生活</category>
        <category>诗</category>
      </categories>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]使用 AngularJS 编写 2048 游戏]]></title>
    <url>%2Ftranslation-building-the-2048-game-in-angularjs%2F</url>
    <content type="text"><![CDATA[原文http://www.ng-newsletter.com/posts/building-2048-in-angularjs.html，所有版权属于原文。考虑到排版和图片，内容稍有修改，对文章表达的意思并无太大影响。第一次渣翻长文，求翻译大大们拍砖和调教。 我们最近经常被问到的其中一个问题是作为一个框架，Angular 在什么情况下使用并不太适合。我们的标准答案通常是编写游戏的时候，因为 Angular 有它自己的事件处理循环（$digest 循环）而游戏通常要求非常多的底层 DOM 操作。其实这个答案并不准确因为 Angular 其实是能支持多数游戏的编写的。即使要求大量的 DOM 操作的游戏，Angular 也能胜任其静态部分，例如高分记录和游戏菜单。 如果你是像我那样的人（同时是个技术人），你有可能会喜欢玩那个流行的 2048 游戏。游戏的目标是通过合并相同数值的方块来得到数值是 2048 的方块。 在 HackerNews 上讨论 在今天的博文中，我们准备使用 AngularJS 来仿制这个游戏，而且是从头到尾完整地解释整个 app 的编写流程。这个 app 是一个相当复杂的应用，我们也希望利用这篇博文来展示如何编写复杂的 AngularJS 应用。 此 Angular 版应用的demo。 来让我们开始吧！ TL;DR: 本应用的完整源代码都能在文章底部的 github 链接里面找到。 目录 计划 模块结构 GameController 测试，测试，测试 建造游戏网格 SCSS 来救援 Tile 指令 游戏棋盘 网格理论 玩法（键盘） 按下开始按钮之时 游戏循环 计算得分 游戏结束和获胜界面 动画 自定义 演示 第一步：计划 我们首先想做的是对将要编写的应用进行高层次设计。如果是仿制一个应用或是从零开始，我们都会这样做，不论应用有多大。 审视一下，我们可以看到游戏是有一块游戏棋盘，上面有一些方块。每一个方块的位置就是数值方块的位置。我们可以利用这一个事实，使用 CSS3 而不是 javascript 来摆放方块，后者需要知道方块摆放的位置。当摆放方块的时候，我们只需要保证方块覆盖在合适的位置上就可以了。 CSS3 的使用让我们不但能够免于在 CSS 上搞动画的工作，而且能使用标准的 AngularJS 行为（译者注：AngularJS behavior）来跟踪游戏棋盘、方块和游戏逻辑的状态。 因为我们只有一个页面，所以只需要一个 controller 来管理页面。 既然在应用的运行期间只有一个游戏棋盘，我们就另外创建单一一个 GridService 的 service 实例来保存所有的网格逻辑。service 都是单例对象，适合用来存储网格。我们会使用 GridService 来放置和移动方块、寻找可供移动的位置和管理网格。 我们将游戏的逻辑和运行存储在另外一个叫 GameManager 的 service 中。GameManager 负责管理游戏状态、处理移动和维护得分（包括当前得分和最高得分）。 最后，还需要一个组件来控制键盘。我们将使用一个名为 KeyboardService 的 service（只需要一个键盘动作的处理）。我们会在这篇文章中实现桌面版的处理，然而我们也可以重用同一个 service 来处理触屏动作使其能在移动设备上使用。 开始编写应用要开始编写，我们先创建一个基本的应用（我们使用yeoman angular generator 来生成应用的结构，但这是非必要的。我们只是将其作为一个起始点，但很快就会做出分支）。我们新建一个包含整个应用的目录，然后再在 app/ 目录旁边建一个 test/ 目录。 以下使用 yeamon tool 来构建项目的指南。如果你更喜欢自己动手，可以跳过依赖安装直接进入下一章节。 我们要先保证安装了 yeamon 才能在项目中使用。Yeamon 依赖 NodeJS 和 npm。NodeJS 的安装并不在本文叙述的范围内但是在 NodeJS.org 上有一个很好的指南。 在 npm 安装完后，我们就能安装 yeamon tool，yo，和 angular generator（yo 会使用这个生成器来生成我们的 Angular 应用）： 12$ npm install -g yo$ npm install -g generator-angular 安装完之后，就可以使用 yeamon tool 来创建应用了，按照下面的来： 12$ cd ~/Development &amp;&amp; mkdir 2048$ yo angular twentyfourtyeight 工具会问你一些问题，一律答 yes，除了只选 angular-cookies 作为依赖，因为我们不需要除了缺省以外的依赖。 注意使用 Angular generator 会要求你安装 ruby 环境、gem 和 compass。文章下面给出的完整代码中会介绍如何避免使用 ruby 和 compass。 我们的 angular 模块新建 scripts/app.js 文件来控制我们的应用。来，开始编写吧： 1angular.module('twentyfourtyeightApp', []) 模块结构现在比较推荐的 Angular 应用结构是根据功能来构建而不是类型。也就是说，不是以 controllers（译者注：控制器）、services、directives 等来分离我们的组件而是以功能来定义模块结构。例如在我们的应用中，定义了一个 Game 模块和 Keyboard 模块。 这样的模块结构让我们能够清晰分离出跟文件结构相匹配的职责。这样做既能帮助我们构建大型的复杂的 angular 应用，也能让功能在不同的应用间共享。 之后我们将会建立起匹配文件和目录结构的测试环境。 视图在我们的项目中，从视图开始编写是最容易的。审视一下，要做的视图 / 模板只有一个。我们不需要多个视图，所以只需要一个 &lt;div&gt; 元素来包含应用中的所有内容。 在我们的的 app/index.html 文件中，我们需要包含所有的依赖（包括 angular.js 自身和自己编写的 javascript 文件——现在就只有 scripts/app.js），就像下面的： 123456789101112131415&lt;!-- index.html --&gt;&lt;doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;2048&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/main.css&quot;&gt; &lt;/head&gt; &lt;body ng-app=&quot;twentyfourtyeightApp&quot; &lt;!-- header --&gt; &lt;div class=&quot;container&quot; ng-include=&quot;&apos;views/main.html&apos;&quot;&gt;&lt;/div&gt; &lt;!-- script tags --&gt; &lt;script src=&quot;bower_components/angular/angular.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;scripts/app.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 你完全可以编写更复杂的多视图游戏——如果你这样打算的话请在下面留言，我们非常期待你的表现。 现在 app/index.html 文件做好了，我们只需要在 app/views/main.html 中继续细节化应用层面的视图就可以了。当我们需要在应用中引入新资源的时候就只需要修改 index.html 了。 赶快打开 app/views/main.html，所有的游戏相关的视图都放在此。通过使用 controllerAs 语法，控制器就可以显式暴露在任何需要在 $scope 中找数据和查询控制器对应组件的地方。 1234&lt;!-- app/views/main.html --&gt;&lt;div id=&quot;content&quot; ng-controller=&apos;GameController as ctrl&apos;&gt; &lt;!-- Now the variable: ctrl refers to the GameController --&gt;&lt;/div&gt; controllerAs 语法是 1.2 版本提供的比较新的语法。当要在页面处理多个控制器的时候非常有用，因为这样就能指定包含我们需要的功能和数据的控制器。 在视图中，我们想至少要显示如下几个东西： 游戏的静态标题 当前的游戏得分和本地用户最高的得分 游戏棋盘 游戏的静态标题可以像下面那么简单： 1234567891011&lt;!-- heading inside app/views/main.html --&gt;&lt;div id=&quot;content&quot; ng-controller=&apos;GameController as ctrl&apos;&gt; &lt;div id=&quot;heading&quot; class=&quot;row&quot;&gt; &lt;h1 class=&quot;title&quot;&gt;ng-2048&lt;/h1&gt; &lt;div class=&quot;scores-container&quot;&gt; &lt;div class=&quot;score-container&quot;&gt;&#123;&#123; ctrl.game.currentScore &#125;&#125;&lt;/div&gt; &lt;div class=&quot;best-container&quot;&gt;&#123;&#123; ctrl.game.highScore &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- ... --&gt;&lt;/div&gt; 注意在引用 currentScore 和 highScore 的时候我们也在视图中引用了 GameController。controllerAs 语法让我们能显式地引用自己感兴趣的控制器。 控制器 GameController现在既然已经有了一个合理的项目结构，我们赶快来创建一个 GmaeController 来控制会在视图上显示的数据。在 app/scripts/app.js 中，我们可以在主要模块 twentyfourtyeightApp 里创建这个控制器。 1234angular.module('twentyfourtyeightApp', []).controller('GameController', function() &#123;&#125;); 在视图中，我们已经引用了一个 game 对象，此对象会在 GameController 中进行设置。game 对象引用的是主 游戏对象 。我们会在另外一个新的模块中创建这个主游戏对象，新的模块也会保存游戏中的所有引用。 现在还没有创建这个模块，应用不会在浏览器中载入。而在控制器里面，我们可以加上对 GameManager 的依赖： 123.controller('GameController', function(GameManager) &#123; this.game = GameManager;&#125;); 记住，我们正在做的是为应用中不同的部分创建模块级别的依赖，所以为了能在我们的应用中加载这些模块，需要在我们 Angular 模块中作为依赖来列出。将 Game 作为 twentyfourtyeightApp 的依赖，要在我们定义模块的地方的数组中列出。 完整的 app/scripts/app.js 文件看起来应该像下面那样： 12345angular.module('twentyfourtyeightApp', ['Game']).controller('GameController', function(GameManager) &#123; this.game = GameManager;&#125;); The Game现在已经将部分数据绑定到视图上（译者注：原文 Now that we have the view partially hooked up to the view，或有误），我们可以开始编写游戏的逻辑了。在 app/scripts/ 目录下新建 app/scripts/game/game.js 中创建游戏模块： 1angular.module('Game', []); 当创建模块的时候，我们通常将其放在以模块命名的目录内，而以模块命名的文件来完成初始化工作。比如，我们正在写一个游戏 (译者注：game) 模块，于是我们在 app/scripts/game 目录下的 game.js 中编写。这个方法在生产环境下被认为是可扩展的和合理的。 Game 模块会提供唯一的核心组件：GameManager。 我们编写的 GameManager 模块要做到：维持游戏的状态和玩家能做出的移动，维护得分、判断游戏结束和搞清楚是玩家赢了还是输了。 当在编写应用的时候，我们通常将已知需要的方法写成桩方法，为这些方法写测试然后再填内容。 为了文章起见，我们在这个模块里会走一遍这个流程。当继续写剩下的模块的时候，我们则只会涉及到应该测试的核心组件。 我们知道到现在为止 GameManager 中会提供的几个 已知的 功能： 创建一个新的游戏 处理游戏循环 / 移动操作 更新得分 跟踪游戏的进行情况 记住这几个功能，我们就能勾勒出 GameManager 服务的基本轮廓以供测试： 1234567891011angular.module('Game', []).service('GameManager', function() &#123; // Create a new game this.newGame = function() &#123;&#125;; // Handle the move action this.move = function() &#123;&#125;; // Update the score this.updateScore = function(newScore) &#123;&#125;; // Are there moves left? this.movesAvailable = function() &#123;&#125;;&#125;); 完成了基本的功能性函数之后，先挪一下，去写测试来决定在 GameManager 中 已知的 需要支持的函数中空白部分的内容。 测试驱动开发（TDD）在开始实施测试前，我们需要配置好 karma 来驱动我们的测试。如果你对 karma 并不熟悉，就只需要了解到它是一个测试运行器，能让我们舒服而高效地在控制台和代码中自动化操作前端测试。 Karma 作为一个 npm 包，依赖于 NodeJS。运行命令行来安装： 1$ npm install -g karma 参数 -g 告诉 npm 这个包作为全局模块来安装。没有这个参数，包将只会安装到本地的工作目录上。 如果你是通过 yeoman angular 生成器来构建应用的话可以跳过以下的部分。 要使用 karma，需要一个配置文件。虽然我们这里不会深入叙述如何配置 Karma（在 ng-book 中查看详细的 karma 配置选项），但是过程中决定性的部分就是让 Karma 载入所有我们想要测试的文件。 我们可以使用 karma init 命令来生成一个基本的配置文件： 1$ karma init karma.conf.js 命令会问几个问题然后生成 karma.conf.js。这里我们修改一下其中两个选项：files 数组和打开 autoWatch： 12345678910// ...files: [ 'app/bower_components/angular/angular.js', 'app/bower_components/angular-mocks/angular-mocks.js', 'app/bower_components/angular-cookies/angular-cookies.js', 'app/scripts/**/*.js', 'test/unit/**/*.js'],autoWatch: true,// ... 一旦写好了配置文件，任何时候我们保存文件都可以运行测试了（测试文件在 test/unit/ 目录内）。 我们像如下那样执行命令 karma start 来运行测试： 1$ karma start karma.conf.js 编写第一个测试karma 已经配置好了，可以写对 GameManager 的基本测试了。然而我们还并不清楚应用的整个功能，所以暂时只能写有限的测试。 在编写应用的时候我们经常发现 API 需要修改，所以与其在变化前投入大量时间，不如建立好对基本功能的测试然后在深入测试中找到最终的 API。 用是否有可能的移动来作为第一个写的测试是个好选择。简单地编写几个我们已知需要的返回真 / 假的调用，来测试我们应用的逻辑行为。 创建 test/unit/game/game_spec.js 文件然后开始填入内容： 12345678describe('Game module', function() &#123; describe('GameManager', function() &#123; // Inject the Game module into this test beforeEach(module('Game')); // Our tests will go below here &#125;);&#125;); 在这个测试中我们使用 Jasmine 语法。 跟其他单元测试一样，我们需要创建一个 GameManager 对象的实例。我们可以使用普通的语法（测试服务的时候）将它注入到测试中。 12345678910// ...// Inject the Game module into this testbeforeEach(module('Game'));var gameManager; // instance of the GameManagerbeforeEach(inject(function(GameManager) &#123; gameManager = GameManager;&#125;);// ... 有了这个 gameManager 实例，就可以建立对函数 movesAvailable() 的期望值。 我们定义的 movesAvailable() 函数是用来检测是否有空格剩余和是否有方块可以合并。另外这个结果跟游戏是否结束是有关联的，我们会将这个方法放进 GameManager 中，但是在之后创建的 GridService 中才实现大多数的复杂细节。 棋盘上要有剩余可走的地方，必须满足以下两个条件： 棋盘上有空余空格 方块可以合并 弄清楚了这两个条件，我们就可以写出测试来看看是否符合。 基本的思路就是我们写出的单元测试对于设定的条件要能作可观察到的反应。然后因为要依赖 GridService 来反映游戏的状态，所以需要模拟出这个条件来保证在 GameManager 中的逻辑是正确的。 模拟 GridService要模拟 GridService，我们只需要简单地 重写 缺省的 Angular 行为，替换 真正的 服务为我们模拟出来的服务，然后就可以在模拟的服务中建立可控制条件。 详细一点说就是，我们简单地创建一个拥有模拟方法的假对象然后通过在 $provide 中换上来骗 Angular 说这个假对象是 真 对象。 12345678910111213// ...var _gridService;beforeEach(module(function($provide) &#123; _gridService = &#123; anyCellsAvailable: angular.noop, tileMatchesAvailable: angular.noop &#125;; // Switch out the real GridService for our // fake version $provide.value('GridService', _gridService);&#125;));// ... 现在我们就可以用 _gridService 这个假对象实例来建立条件了。 我们希望当有单元格剩余的时候函数 movesAvailable() 返回 true。在 GridService 中模拟一个 anyCellsAvailable() 函数（其实还没写）。我们期望这个在 GridService 的函数能告诉我们还有剩余的单元格。 1234567// ...describe('.movesAvailable', function() &#123; it('should report true if there are cells available', function() &#123; spyOn(_gridService, 'anyCellsAvailable').andReturn(true); expect(gameManager.movesAvailable()).toBeTruthy(); &#125;); // ... 现在基础工作已经做好了，我们可以接着建立第二个条件了。如果方块可以合并，那么我们希望 movesAvailable() 保证会返回 true。相反的情况也是返回 true 因为既没有单元格空余也没有可合并的方块才是没有步数可走。 另外两个保证这个结果的测试是： 123456789101112// ...it('should report true if there are matches available', function() &#123; spyOn(_gridService, 'anyCellsAvailable').andReturn(false); spyOn(_gridService, 'tileMatchesAvailable').andReturn(true); expect(gameManager.movesAvailable()).toBeTruthy();&#125;);it('should report false if there are no cells nor matches available', function() &#123; spyOn(_gridService, 'anyCellsAvailable').andReturn(false); spyOn(_gridService, 'tileMatchesAvailable').andReturn(false); expect(gameManager.movesAvailable()).toBeFalsy();&#125;);// ... 将基础工作搞好，我们也好在实现真正函数前写好测试。 虽然考虑到整个文章的整体性我们不会再在文章中使用 TDD，但是我们建议你应该始终使用 TDD。可以在下面的完整代码中查看更多的测试代码。 回到 GameManager现在我们的任务就是实现函数 movesAvailable()。然而我们已经确认了代码可行性和要求的条件，实现起来实在简单。 123456// ...this.movesAvailable = function() &#123; return GridService.anyCellsAvailable() || GridService.tileMatchesAvailable();&#125;;// ... 建造游戏网格到现在为止我们已经让 GameManager 运行起来了，然后就是要创建 GridService 来处理在棋盘中的所有状况。 回忆一下我们的想法：在 GridService 中使用两个本地数组变量，基本数组 grid 和基本数组 tiles。在 app/scripts/grid/grid.js 文件中写服务： 12345678angular.module('Grid', []).service('GridService', function() &#123; this.grid = []; this.tiles = []; // Size of the board this.size = 4; // ...&#125;); 当开始一个新的游戏的时候，我们需要清空这些数组。而因为 grid 数组只是用来放方块的 DOM 元素组成的。 然而数组 tiles 则是动态的，它会跟踪游戏过程中的当前的方块。使用游戏中不同的状态之前，先在页面上建造好网格先吧，这样我们也好看看大概样子是怎么样。 回到 app/views/main.html，我们开始设计网格。因为网格是动态而又带有我们给它写的逻辑，所以只有就其放在其指令（译者注：directive）中才合乎逻辑。使用指令可以让主要的模板保持简洁，同样也能将功能封装在指令中而让主要的控制器保持简洁。 在 app/index.html 中我们将网格指令添加上然后在控制器中传递给 GameManager 实例。 1234&lt;!-- instructions --&gt;&lt;div id=&quot;game-container&quot;&gt; &lt;div grid ng-model=&apos;ctrl.game&apos; class=&quot;row&quot;&gt;&lt;/div&gt; &lt;!-- ... --&gt; 我们是在 Grid 模块里写这个指令的，所以在 app/scripts/grid/ 目录下，新建一个 grid_directive.js 文件来安放我们的 grid 指令。 在 grid 指令里面，我们只需要少量变量因为它需要封装视图，能做的事情不多。 指令会需要持有 GameManager 的实例（或者至少是一个有 grid 和 tiles 数组的模型），所以将其设置为指令的依赖。另外，不希望指令由于页面上的其它内容或者 GameManager 自身的原因瘫痪，所以我们创建了隔离作用域。 查看我们写的 自定义指令 来更加深入指令的编写，或者查看 ng-book 中有关指令的细节。 1234567891011angular.module('Grid').directive('grid', function() &#123; return &#123; restrict: 'A', require: 'ngModel', scope: &#123; ngModel: '=' &#125;, templateUrl: 'scripts/grid/grid.html' &#125;;&#125;); 这个指令的主要功能是构建网格视图，所以我们不需要写任何自定义逻辑。 grid.html在指令的模板里面，我们会运行两个 ngRepeat 来显示网格和方块数组，还会（暂时）在循环中使用 $index 来跟踪。 12345678910111213&lt;div id=&quot;game&quot;&gt; &lt;div class=&quot;grid-container&quot;&gt; &lt;div class=&quot;grid-cell&quot; ng-repeat=&quot;cell in ngModel.grid track by $index&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;tile-container&quot;&gt; &lt;div tile ng-model=&apos;tile&apos; ng-repeat=&apos;tile in ngModel.tiles track by $index&apos;&gt; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 第一个 ng-repeat 简单易懂，就是遍历了 grid 数组然后生成了 class 属性是 grid-cell 的单个空 div 元素。 在第二个 ng-repeat 中，我们会为每一个显示的元素生成一个名为 tile 的指令。这个 tile 指令会负责生成每一个方格元素的样子。我们很快就会去编写 tile 指令…… 精明的读者可能会发现我们只适用一维数组来显示二维网格。当我们渲染视图的时候，我们只会得到一列“方格”，而不是一个网格。 要将它弄成网格，我们来深入 CSS 的编写。 开始 SCSS在这个项目中，我们会使用 SASS 的一个变种：scss。scss 除了是一个更强大的 CSS 外，还能动态地生成 CSS。 应用所有显示的元素的主要部分会使用 CSS 来完成，包括动画、布局和可视元素（方格的颜色等）。 要创建二维的棋盘，我们会用到 CSS3 关键字：transform 来处理每一个特定的方格的位置。 CSS3 transform 属性CSS3 transform 属性是一个可以让我们对元素进行 2D 或者 3D 上的移动、扭曲、旋转、缩放等操作（支持动画）的属性。用上了此属性，就可以直接将方块放在棋盘上然后剩下就只是应用合适的 transform 属性的事了。 例如，在下面的演示中，我们有一个宽 40px 高 40px 的盒子。 12345.box &#123; width:40px; height:40px; background-color: blue;&#125; 如果我们应用一个 translateX(300px) 的 transform 属性，就可以将盒子向右移动了 300px，就像下面所展示的： 1234.box.transformed &#123; -webkit-transform: translateX(300px); transform: translateX(300px);&#125; 使用 translate 属性，我们只需应用 CSS 类就可以在棋盘上随便移动方块了。现在，精妙之处在于页面是多变的，我们如何能将类写得足够动态可以对应到网格上的正确位置。 这里就是 SCSS 大显身手的地方了。我们会创建几个变量（例如一行有多少个方格）然后在 SCSS 中结合数学来帮助我们计算。 来看一下计算棋盘上正确位置需要的变量： 123$width: 400px; // The width of the whole board$tile-count: 4; // The number of tiles per row/column$tile-padding: 15px; // The padding between tiles 让 SCSS 用这些变量帮我们动态计算位置。首先算出每一个方格的大小。在 SCSS 中非常简单： 1$tile-size: ($width - $tile-padding * ($tile-count + 1)) / $tile-count; 现在我们就可以使用适当的宽和高来建立那个 #game 容器了。同时 #game 容器也会被设置成位置参照，它的子元素将会使用绝对定位。我们将 .grid-container 和 tile-container 放在 #game 容器内。 我们这里只展示跟 scss 有关的部分。剩下的代码可以在文章末尾的 github 地址上找到。 1234567891011121314151617181920212223242526272829#game &#123; position: relative; width: $width; height: $width; // The gameboard is a square .grid-container &#123; position: absolute; // the grid is absolutely positioned z-index: 1; // IMPORTANT to set the z-index for layering margin: 0 auto; // center .grid-cell &#123; width: $tile-size; // set the cell width height: $tile-size; // set the cell height margin-bottom: $tile-padding; // the padding between lower cells margin-right: $tile-padding; // the padding between the right cell // ... &#125; &#125; .tile-container &#123; position: absolute; z-index: 2; .tile &#123; width: $tile-size; // tile width height: $tile-size; // tile height // ... &#125; &#125;&#125; 注意为了让 .tile-container 放在 .grid-container 前面，我们必须要为 .tile-container 更高的 z-index 值。如果没有设置 z-index 值，浏览器会将两个元素放在同等高度，就不好看了。 做好这一步之后，现在我们来动态生成方块的位置。我们需要是一个 .position-{x}-{y} 类，用来应用到方块上，这样浏览器就会知道方块的位置然后将它放置好。既然我们是计算相对于网格容器的的 transformation 属性值，那就使用 0,0 作为第一个方块的初始位置。 我们对队列进行迭代，结合基于计算出来的期望偏移，动态生成每一个类。 12345678910111213141516171819.tile &#123; // ... // Dynamically create .position-#&#123;x&#125;-#&#123;y&#125; classes to mark // where each tile will be placed @for $x from 1 through $tile-count &#123; @for $y from 1 through $tile-count &#123; $zeroOffsetX: $x - 1; $zeroOFfsetY: $y - 1; $newX: ($tile-size) * ($zeroOffsetX) + ($tile-padding * $zeroOffsetX); $newY: ($tile-size) * ($zeroOffsetY) + ($tile-padding * $zeroOffsetY); &amp;.position-#&#123;$zeroOffsetX&#125;-#&#123;$zeroOffsetY&#125; &#123; -webkit-transform: translate($newX, $newY); transform: translate($newX, $newY); &#125; &#125; &#125; // ...&#125; 注意我们不得不使用从 1 开始的偏移量来计算位置，而不是传统的从 0 开始。这是受 SASS 自身的限制所迫。不过我们可以使用将索引减 1 来解决。 现在我们写好了动态的 .position-#{x}-#{y}CSS 类，方块能够显示在页面上了。 为不同的方块上色注意到当有不同的方块出现的时候，各自都是不同颜色的。不同的颜色标识着不同方块所代表的值。如此一来玩家能看得出方格所处的状态。使用和我们迭代方格数目的时候同样的技巧来创建方格颜色方案。 要创建出颜色方案，我们首先要创建一个 SCSS 数组，包含有每一种需要用到的背景颜色。每一种颜色： 1234567891011$colors: #EEE4DA, // 2 #EAE0C8, // 4 #F59563, // 8 #3399ff, // 16 #ffa333, // 32 #cef030, // 64 #E8D8CE, // 128 #990303, // 256 #6BA5DE, // 512 #DCAD60, // 1024 #B60022; // 2048 使用了 $colors 数组，我们只要迭代每一个颜色就能基于方块的值来动态创建一个类。也就是说，当一个方块的值是 2，我们会给它加上指定背景颜色是 #EEE4DA 的 .tile-2 类。与其给每个方块用硬编码，我们不如用 SCSS 的魔法来完成： 12345@for $i from 1 through length($colors) &#123; &amp;.tile-#&#123;power(2, $i)&#125; .tile-inner &#123; background: nth($colors, $i) &#125;&#125; 当然，我们需要自己定义 power() 混合（译者注：mixin）。定义如下： 123456789101112131415@function power ($x, $n) &#123; $ret: 1; @if $n &gt;= 0 &#123; @for $i from 1 through $n &#123; $ret: $ret * $x; &#125; &#125; @else &#123; @for $i from $n to 0 &#123; $ret: $ret / $x; &#125; &#125; @return $ret;&#125; Tile 指令SCSS 的繁琐工作完成了，我们可以回到 tile 指令的编写中了。通过动态的位置布局，让 CSS 按我们所设计的那样将方块摆放到位。 然而 tile 指令是一个自定义视图的容器，并不需要做很多事。我们需要的是它负责显示的单元格的访问权。除此以外，并不需要在指令内放任何功能。代码简单到足以自我描述： 12345678910angular.module('Grid').directive('tile', function() &#123; return &#123; restrict: 'A', scope: &#123; ngModel: '=' &#125;, templateUrl: 'scripts/grid/tile.html' &#125;;&#125;); 现在，tile 指令中有趣的地方就是我们如何动态的为网格布局。而模板会需要用到在隔离作用域（译者注：isolate scope）中的 ngModel 变量来处理好一切。 12345&lt;div ng-if=&apos;ngModel&apos; class=&quot;tile position-&#123;&#123; ngModel.x &#125;&#125;-&#123;&#123; ngModel.y &#125;&#125; tile-&#123;&#123; ngModel.value &#125;&#125;&quot;&gt; &lt;div class=&quot;tile-inner&quot;&gt; &#123;&#123; ngModel.value &#125;&#125; &lt;/div&gt;&lt;/div&gt; 我们几乎已经可以将这个基础的指令直接显示了。对于每一个有 x 和 y 坐标的方块而言，它们都会 自动 被赋予一个 .position-#{x}-#{y} 的类。浏览器会 自动 地将它们放到我们期待的位置。 这意味着我们的方块对象会需要一个 x 和 y 以及 value 让指令来使用。为此，对于每一个显示的方块，我们都需要创建一个新的对象。 TileModel与其创建一个 哑 对象，我们还不如创建一个比较智能的对象，既存储数据也能提供功能。 我们希望能使用 Angular 的依赖注入，因此创建一个服务来安置数据模型。我们在 Grid 模块中创建一个 TileModel 服务，因为跟游戏棋盘有关的操作时，它只需要使用底层的 TileModel。 使用 .factory 方法，我们能够简单地创建一个工厂函数。跟使用 service() 函数时传递的用以定义服务的函数会被默认为服务的构造函数不同的是，使用 factory() 函数会认为传递函数返回的对象才是服务。所以，只用 factory() 函数，我们可以将服务赋给任何对象以便在我们 Angular 应用中随时 注入 。 在 app/scripts/grid/grid.js 文件中，我们可以创建 TileModel 工厂： 1234567891011angular.module('Grid').factory('TileModel', function() &#123; var Tile = function(pos, val) &#123; this.x = pos.x; this.y = pos.y; this.value = val || 2; &#125;; return Tile;&#125;)// ... 现在在我们 Angular 应用中的任何地方，我们都可以 注入 这个 TileModel 并想全局对象一样使用。非常方便不是吗？ 不要忘了要为我们在 TileModel 中实现的任何功能写测试。 我们第一个网格现在我们已经写好了 TileModel 了，我们可以开始在 tiles 数组中放入 TileModel 的实例了，然后发现它们 神奇地 出现在网格中正确的位置上。 让我们来试试在 GridService 中的 tiles 数组中加入一些方块： 12345678910angular.module('Grid', []).factory('TileModel', function() &#123; // ...&#125;).service('GridService', function(TileModel) &#123; this.tiles = []; this.tiles.push(new TileModel(&#123;x: 1, y: 1&#125;, 2)); this.tiles.push(new TileModel(&#123;x: 1, y: 2&#125;, 2)); // ...&#125;); 棋盘已经准备好了现在我们具备显示方块的能力了，还需要在 GridService 中实现准备棋盘的功能。当第一次载入页面的时候我们想创建一个空的棋盘。而同样的动作也应该发生在当用户在进行游戏的时候点击了 New Game 或者 Try again 的时候。 要清理棋盘，我们会在 GridService 中创建一个叫 buildEmptyGameBoard() 的函数。这个方法会负责将 GridService 中的 grid 数组和 tiles 数组填充 null。 在开始编写代码之前，我们先写出测试以保证 buildEmptyGameBoard() 函数的行为没问题。然而这个写的过程在上面已经讲过一遍了，所以不再讨论直接给出结果。写出来的测试大概就像下面那样： 123456789101112131415161718192021222324252627282930// In test/unit/grid/grid_spec.js// ...describe('.buildEmptyGameBoard', function() &#123; var nullArr; beforeEach(function() &#123; nullArr = []; for (var x = 0; x &lt; 16; x++) &#123; nullArr.push(null); &#125; &#125;) it('should clear out the grid array with nulls', function() &#123; var grid = []; for (var x = 0; x &lt; 16; x++) &#123; grid.push(x); &#125; gridService.grid = grid; gridService.buildEmptyGameBoard(); expect(gridService.grid).toEqual(nullArr); &#125;); it('should clear out the tiles array with nulls', function() &#123; var tiles = []; for (var x = 0; x &lt; 16; x++) &#123; tiles.push(x); &#125; gridService.tiles = tiles; gridService.buildEmptyGameBoard(); expect(gridService.tiles).toEqual(nullArr); &#125;);&#125;); 既然测试写好了，就可以实现 buildEmptyGameBoard() 函数的函数体了。 函数并不大，代码也足以自我说明。在 app/scripts/grid/grid.js 中 12345678910111213141516.service('GridService', function(TileModel) &#123; // ... this.buildEmptyGameBoard = function() &#123; var self = this; // Initialize our grid for (var x = 0; x &lt; service.size * service.size; x++) &#123; this.grid[x] = null; &#125; // Initialize our tile array // with a bunch of null objects this.forEach(function(x,y) &#123; self.setCellAt(&#123;x:x,y:y&#125;, null); &#125;); &#125;; // ... 上面的代码使用了一些足以自我描述出会做什么的辅助方法。部分我们会在整个项目中用到辅助函数如下列出，都是自我描述的： 123456789101112131415161718192021222324252627282930313233// Run a method for each element in the tiles arraythis.forEach = function(cb) &#123; var totalSize = this.size * this.size; for (var i = 0; i &lt; totalSize; i++) &#123; var pos = this._positionToCoordinates(i); cb(pos.x, pos.y, this.tiles[i]); &#125;&#125;;// Set a cell at positionthis.setCellAt = function(pos, tile) &#123; if (this.withinGrid(pos)) &#123; var xPos = this._coordinatesToPosition(pos); this.tiles[xPos] = tile; &#125;&#125;;// Fetch a cell at a given positionthis.getCellAt = function(pos) &#123; if (this.withinGrid(pos)) &#123; var x = this._coordinatesToPosition(pos); return this.tiles[x]; &#125; else &#123; return null; &#125;&#125;;// A small helper function to determine if a position is// within the boundaries of our gridthis.withinGrid = function(cell) &#123; return cell.x &gt;= 0 &amp;&amp; cell.x &lt; this.size &amp;&amp; cell.y &gt;= 0 &amp;&amp; cell.y &lt; this.size;&#125;; 究竟是什么？！？？this._positionToCoordinates() 和 this._coordinatesToPosition() 这两个函数是什么？ 回忆起之前我们已经讨论过了我们会使用一个一维数组来存储网格。在考虑到性能和复杂动画的处理，这是较为可取的。关于动画我们会稍后研究。我们暂且只能从使用单维数组表示多维数组的复杂性得到一点好处。 一维数组中的多维数组如何使用单维数组表示多维数组？先来看看在棋盘上用每一个单元格的值来标出网格位置，不需要有颜色。在代码中，这个多维数组被分解成数组的数组。 看看每个单元格的位置，如果单维数组来看，可以看出一个关系来： 我们可以看到，在第一个单元格，(0,0) 单元格对应的数组下标是 0。第二个数组元素下标是 1 而单元格是 (1.0)。移动到下一行，单元格是 (0,1) 对应第四个数组元素而下标是 5 的数组元素是单元格 (1,1)。 据此可以推断出两个位置之间的等式关系。 i = x + nyi 代表数组元素的下标，x 和 y 是多维数组中的位置坐标，n 是一行 / 列的单元格数。 我们在上面定义的两个辅助函数就是将数组下标转换为 x-y 坐标的过程和相反的转换过程。从理论上来说，使用 x-y 坐标处理单元格会比较简单，但是从功能上考虑我们却会在单维数组里存放方块。 1234567891011121314// Helper to convert x to x,ythis._positionToCoordinates = function(i) &#123; var x = i % service.size, y = (i - x) / service.size; return &#123; x: x, y: y &#125;;&#125;;// Helper to convert coordinates to positionthis._coordinatesToPosition = function(pos) &#123; return (pos.y * service.size) + pos.x;&#125;; 初始化玩家位置在游戏的一开始，我们想预先放几块。我们会为玩家随机在棋盘上挑选放方块的地方。 123456789.service('GridService', function(TileModel) &#123; this.startingTileNumber = 2; // ... this.buildStartingPosition = function() &#123; for (var x = 0; x &lt; this.startingTileNumber; x++) &#123; this.randomlyInsertNewTile(); &#125; &#125;; // ... 构建一开始的位置非常简单因为它只根据我们想放多少块方块来调用 randomlyInsertNewTile() 函数。randomlyInsertNewTile() 函数需要我们知道所有可以随机放置方块的位置。这个功能非常容易实现因为需要做的只是遍历单维数组的同时记录下还没有方块放置的位置。 1234567891011121314151617.service('GridService', function(TileModel) &#123; // ... // Get all the available tiles this.availableCells = function() &#123; var cells = [], self = this; this.forEach(function(x,y) &#123; var foundTile = self.getCellAt(&#123;x:x, y:y&#125;); if (!foundTile) &#123; cells.push(&#123;x:x,y:y&#125;); &#125; &#125;); return cells; &#125;; // ... 有了一个棋盘上所有可用的坐标的列表，我们就可以简单地在数组中取随机位置。randomAvailableCell() 函数为我们处理。要实现函数的方法非常多。以下是我们在 2048 中实现的方法： 123456789.service('GridService', function(TileModel) &#123; // ... this.randomAvailableCell = function() &#123; var cells = this.availableCells(); if (cells.length &gt; 0) &#123; return cells[Math.floor(Math.random() * cells.length)]; &#125; &#125;; // ... 从这里开始，我们可以简单地创建一个新的 TileModel 实例然后插入到我们的 this.tiles 数组中了。 123456789101112131415161718192021.service('GridService', function(TileModel) &#123; // ... this.randomlyInsertNewTile = function() &#123; var cell = this.randomAvailableCell(), tile = new TileModel(cell, 2); this.insertTile(tile); &#125;; // Add a tile to the tiles array this.insertTile = function(tile) &#123; var pos = this._coordinatesToPosition(tile); this.tiles[pos] = tile; &#125;; // Remove a tile from the tiles array this.removeTile = function(pos) &#123; var pos = this._coordinatesToPosition(tile); delete this.tiles[pos]; &#125; // ...&#125;); 现在，得益于我们使用的 Angular，视图中的棋盘上，网格块会神奇地显示出方块来。 记住，明智的做法是接下来写测试来测试我们对于功能的假设实现。我们已经在为项目写测试的过程中发现了不少 bug，同样的事情你也会遇到的。 键盘交互很好，现在我们已经将方块放到棋盘上了。但一个不能玩的游戏有啥意思呢？是时候将注意力转移到加入交互上面去了。 为文章起见，我们只准备着眼在键盘的交互而没有考虑触控的交互。然而，加上触控支持并不应该太难，特别是我们只关注滑动动作，这个在 ngTouch 里有提供。我们将其留给你自己实现。 游戏本身使用方向键（或者 a,w,s,d 键）来玩。在游戏中，我们希望让玩家在页面上跟游戏简单地交互。而不是要求玩家将焦点移到在游戏棋盘元素上（或者同样问题下的其他元素）。玩家只需要让页面获得焦点就可以进行游戏了。 要做到这种交互，就要将事件监听绑定在 document 上。在 Angular 中，我们会 绑定 自己的事件监听在 Angular 提供的 $ducoment 服务上。要处理用户交互的创建，我们会将键盘事件绑定包裹在一个服务中。记住在页面中我们只需要一个键盘处理器，所以只要一个服务就可以了。 此外，我们也希望为用户的任何输入动作作出自定义的反应。使用了服务能自然地注入到应用中然后根据用户的输入来决定应用的反应。 首先，在 app/scripts/Keyboard/keyboard.js 文件中创建一个新的模块（因为我们正在做基于模块的开发的）KeyBoard（文件不存在就要先创建）。 12// app/scripts/keyboard/keyboard.jsangular.module('Keyboard', []); 正如创建任何新的 JavaScript 一样，我们需要在 index.html 中引用。现在 &lt;script&gt; 标签列表看起来是这样的： 123456789 &lt;!-- body --&gt; &lt;script src=&quot;scripts/app.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;scripts/grid/grid.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;scripts/grid/grid_directive.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;scripts/grid/tile_directive.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;scripts/keyboard/keyboard.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;scripts/game/game.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后，因为新建一个模块，我们同样需要告诉自己的 Angular 模块在应用在需要依赖这个新模块： 1.module('twentyfourtyeightApp', ['Game', 'Grid', 'Keyboard']) Keyboard 服务的实现思路，就是在 $document 上 绑定 了 Keydown 事件来捕获用户的键盘操作。而另一端，在我们的 angular 对象中，我们会注册一有用户操作就触发的处理函数。 来写代码。 1234567891011121314// app/scripts/keyboard/keyboard.jsangular.module('Keyboard', []).service('KeyboardService', function($document) &#123; // Initialize the keyboard event binding this.init = function() &#123; &#125;; // Bind event handlers to get called // when an event is fired this.keyEventHandlers = []; this.on = function(cb) &#123; &#125;;&#125;); init() 函数会作为 KeyboardService 的开始，然后开始监听键盘事件。我们会过滤掉不感兴趣的键盘事件。 对于感兴趣的事件，我们会阻止它的默认行为然后将它交给我们的 KeyEventHandlers。 如何知道那些是我们感兴趣的呢？既然 感兴趣的 键盘操作是固定的，那么我们就去检查事件是否有其中一种键盘事件所激发。 一旦方向键被按下，document 会接收到一个包含被按下的按键的键码的事件。 我们可以为这些事件建立一个映射，然后查询捕获到的键盘动作是否在这个 感兴趣的 映射中。 1234567891011121314151617181920212223242526272829303132// app/scripts/keyboard/keyboard.jsangular.module('Keyboard', []).service('KeyboardService', function($document) &#123; var UP = 'up', RIGHT = 'right', DOWN = 'down', LEFT = 'left'; var keyboardMap = &#123; 37: LEFT, 38: UP, 39: RIGHT, 40: DOWN &#125;; // Initialize the keyboard event binding this.init = function() &#123; var self = this; this.keyEventHandlers = []; $document.bind('keydown', function(evt) &#123; var key = keyboardMap[evt.which]; if (key) &#123; // An interesting key was pressed evt.preventDefault(); self._handleKeyEvent(key, evt); &#125; &#125;); &#125;; // ...&#125;); 每当一个存在于我们映射中的按键触发了 keydown 事件，KeyboardService 就会执行 this._handleKeyEvent 函数。 这个函数的整个职责就是调用每一个为按键注册了的处理函数。它就是简单地对处理函数数组进行迭代，使用按键和原事件组为参数来调用处理函数。 12345678910111213141516// ...this._handleKeyEvent = function(key, evt) &#123; var callbacks = this.keyEventHandlers; if (!callbacks) &#123; return; &#125; evt.preventDefault(); if (callbacks) &#123; for (var x = 0; x &lt; callbacks.length; x++) &#123; var cb = callbacks[x]; cb(key, evt); &#125; &#125;&#125;;// ... 另一方面，我们只需要将处理函数压入处理函数数组就可以了。 12345// ...this.on = function(cb) &#123; this.keyEventHandlers.push(cb);&#125;;// ... 使用 Keyboard Service现在我们已经有能力来监控用户的键盘事件，我们需要在应用开始运行的时候就监控。因为我们将它做成了一个服务，所以可以很简单地在主要的控制器中做这件事。 首先，我们需要调用 init() 函数来开始监听键盘。接着，我们会注册函数来告诉 GameManager 来调用 move() 函数。 回到 GameController，我们添加上 newGame() 函数和 startGame() 函数。newGame() 函数会告诉游戏服务创建一个新的游戏然后开始键盘事件处理。 来开始编码吧！我们需要将 Keyboard 模块作为一个新的模块依赖 注入 到应用中： 12angular.module('twentyfourtyeightApp', ['Game', 'Keyboard'])// ... 然后就可以将 KeyboardService 注入到 GameController 中来开始跟用户交互了。首先，newGame() 方法： 123456789101112// ... (from above).controller('GameController', function(GameManager, KeyboardService) &#123; this.game = GameManager; // Create a new game this.newGame = function() &#123; KeyboardService.init(); this.game.newGame(); this.startGame(); &#125;; // ... 我们还没有在 GameManager 中定义 newGame() 方法，但很快就会去填好内容。 一旦我们开始了新游戏，我们会调用 startGame()。startGame() 函数会准备好键盘服务的事件处理函数。 123456789101112.controller('GameController', function(GameManager, KeyboardService) &#123; // ... this.startGame = function() &#123; var self = this; KeyboardService.on(function(key) &#123; self.game.move(key); &#125;); &#125;; // Create a new game on boot this.newGame();&#125;); 按下那开始按钮我们做了许多工作来达到开始游戏这么个目的。最后要实现的方法就是 GameManager 中的 newGame() 了，函数会： 创建一个空的棋盘 准备好开始的位置 初始化游戏 其实我们已经在 GridService 中实现了这些逻辑，所以现在就差把它们连起来了！ 在我们的 app/scripts/game/game.js 文件中，加入 newGame() 函数吧。此函数会重置游戏状态成应有的初始条件： 1234567891011121314151617angular.module('Game', []).service('GameManager', function(GridService) &#123; // Create a new game this.newGame = function() &#123; GridService.buildEmptyGameBoard(); GridService.buildStartingPosition(); this.reinit(); &#125;; // Reset game state this.reinit = function() &#123; this.gameOver = false; this.win = false; this.currentScore = 0; this.highScore = 0; // we'll come back to this &#125;;&#125;); 在浏览器中载入页面，包含功能的网格就出来了…… 然而这个阶段还是非常无聊因为我们还没有定义任何移动的功能。 动起来（游戏循环）现在我们来深入游戏功能的实现。当用户按下任何一个方向键，我们会调用 GridService 中的 move() 函数（在 GameController 中写的）。 要编写 move() 函数，我们需要定义游戏的约束。那就是说，我们需要定义游戏对于每一个给出的移动的操作。 对于每一步移动，我们要： 确定用户按下的方向键指示的方向 为棋盘上每一个方块找到所有最远的可能移动的位置。同时抓取下一个方块看是否能 合并 起来。 对于每一个方块，我们想确定下一个位置是否存在一个等值的方块。 如果下一个方块不存在，那么只将方块移动到可能的最远位置即可。（意味着这个最远位置就是棋盘的边缘。） 如果下一个方块存在： 且方块值不同的话，那么将方块放在最远位置（下一个方块就是当前方块的移动边界）。 且方块值和当前方块相同的话，我们就找到一个可能的合并了。 如果该方块已经是合并的结果了，则跳过并认定为已使用。 如果方块还没合并过，那么则认为需要合并。 既然定义了功能，就可以制定出写 move() 函数的策略了。 12345678910angular.module('Game', []).service('GameManager', function(GridService) &#123; // ... this.move = function(key) &#123; var self = this; // Hold a reference to the GameManager, for later // define move here if (self.win) &#123; return false; &#125; &#125;; // ...&#125;); 移动是有限制条件的：如果游戏已经结束或者游戏循环因为某种原因而终止了，那么就只需要返回并继续。 接下来我们需要在网格上走一下来找出所有可供移动的地方。而因为掌握空方格的位置其实是网格的职责，因此我们会在 GridService 中写一个新的函数来帮助我们找出这些可能会经过的方格。 我们通过提取玩家按键指示的 向量 来决定方向。例如，如果玩家按下了右键头键，那么就是想移动到 x 值 更大的 方格上。 如果玩家按了上箭头，那么玩家就是想将方块移动到 y 值 更小的 方格上。我们可以使用一个 JavaScript 对象将向量和玩家按键映射起来（从 KeyboardService 中得到的按键），就像这样： 1234567// In our `GridService` app/scripts/grid/grid.jsvar vectors = &#123; 'left': &#123; x: -1, y: 0 &#125;, 'right': &#123; x: 1, y: 0 &#125;, 'up': &#123; x: 0, y: -1 &#125;, 'down': &#123; x: 0, y: 1 &#125;&#125;; 现在我们就可以简单地迭代每一个可能的位置，并使用向量来控制迭代的方向： 1234567891011121314151617181920.service('GridService', function(TileModel) &#123; // ... this.traversalDirections = function(key) &#123; var vector = vectors[key]; var positions = &#123;x: [], y: []&#125;; for (var x = 0; x &lt; this.size; x++) &#123; positions.x.push(x); positions.y.push(x); &#125; // Reorder if we're going right if (vector.x &gt; 0) &#123; positions.x = positions.x.reverse(); &#125; // Reorder the y positions if we're going down if (vector.y &gt; 0) &#123; positions.y = positions.y.reverse(); &#125; return positions; &#125;; // ... 现在新的函数 traversalDirections() 定义好了，在 move() 函数中就可以在可能的移动上进行迭代了。回到 GameMabager，我们会根据这些可能的位置在网格上走动。 1234567891011121314// ...this.move = function(key) &#123; var self = this; // define move here if (self.win) &#123; return false; &#125; var positions = GridService.traversalDirections(key); positions.x.forEach(function(x) &#123; positions.y.forEach(function(y) &#123; // For every position &#125;); &#125;);&#125;;// ... 在位置的循环中，我们会对可供移动的位置进行迭代同时查找存在的方块。从这里开始，我们将编写函数的第二部分，找出从该方块出发能到达的所有方格。 1234567891011// ...// For every position// save the tile's original positionvar originalPosition = &#123;x:x,y:y&#125;;var tile = GridService.getCellAt(originalPosition);if (tile) &#123; // if we have a tile here var cell = GridService.calculateNextPosition(tile, key); // ...&#125; 如果我们确实在该方格内找到了方块，就会开始查看该方格最远能到哪里。先在网格上找到下一个位置，检查这个方格是否在棋盘内和方格是否为空。 如果该方格是空的 而且 在棋盘内，那么继续取得下一个方格然后执行一样的检查。 如果两个条件中任意一个不满足，那么要不我们到达了棋盘的边界，要不我们找到了下一个方块。我们会保存前一个位置（译者注：原文为 the next position，翻译为下一个位置。但根据描述和下文的代码此处应该为前一个位置。）同时抓取下一个方格（不管是否存在下一个方格）。 而这个过程是对网格进行操作，于是就这个函数放在 GridService： 12345678910111213141516171819// in GridService// ...this.calculateNextPosition = function(cell, key) &#123; var vector = vectors[key]; var previous; do &#123; previous = cell; cell = &#123; x: previous.x + vector.x, y: previous.y + vector.y &#125;; &#125; while (this.withinGrid(cell) &amp;&amp; this.cellAvailable(cell)); return &#123; newPosition: previous, next: this.getCellAt(cell) &#125;;&#125;; 现在我们可以计算下一个有可能放得下我们的方块的地方，接着就是检查是否有合并的可能。 一个 合并 的定义是两个相同值的方块碰撞在一起。我们会检查 next 的位置上是否有相同值的方块并且还之前没有被 合并 过。 1234567891011121314151617181920// ...// For every position// save the tile's original positionvar originalPosition = &#123;x:x,y:y&#125;;var tile = GridService.getCellAt(originalPosition);if (tile) &#123; // if we have a tile here var cell = GridService.calculateNextPosition(tile, key), next = cell.next; if (next &amp;&amp; next.value === tile.value &amp;&amp; !next.merged) &#123; // Handle merged &#125; else &#123; // Handle moving tile &#125; // ...&#125; 如果这个所谓的下一个位置并 不 符合上面的条件，那么我们就会将方块从当前的位置移动到这个下一个位置（else 语句）。 这是更相比之下更容易处理的条件，所需要做的就是将方块移动到 newPosition 位置。 12345678// ...if (next &amp;&amp; next.value === tile.value &amp;&amp; !next.merged) &#123; // Handle merged&#125; else &#123; GridService.moveTile(tile, cell.newPosition);&#125; 移动方块就像你大概猜测那样，moveTile() 函数最好就是定义在 GridService 中。 移动一个方块就是简单地更新一下方块在数组中的位置和更新 TileModel 而已。 就像我们定义的那样，函数里面有两个目的不同的操作。当我们： 在数组中移动方块的时候数组 GridService.tiles（译者注：原文为 GridService）为后端映射了方块的位置。数组中方块的位置 没有 和网格中方块的位置绑定。 更新 TileModel 中的位置的时候我们要为前端的 CSS 更新坐标来放置方块。 简而言之：为了在后端能跟踪方块们，我们需要更新 GridService 中的 this.tiles 数组 同时 更新方块对象的位置。 于是 moveTile() 就变成了一个简单的两步操作： 1234567891011121314// GridService// ...this.moveTile = function(tile, newPosition) &#123; var oldPos = &#123; x: tile.x, y: tile.y &#125;; // Update array location this.setCellAt(oldPos, null); this.setCellAt(newPosition, tile); // Update tile model tile.updatePosition(newPosition);&#125;; 现在我们需要定义我们的 tile.updatePosition() 方法。这个方法所做的就像它字面上的那样，就是简单地更新模型自己的 x 和 y 坐标。 123456789.factory('TileModel', function() &#123; // ... Tile.prototype.updatePosition = function(newPos) &#123; this.x = newPos.x; this.y = newPos.y; &#125;; // ...&#125;); 回到 GridService 中，我们已经可以只是调用 moveTile() 来同时更新 GridService.tiles 数组和方块自己的位置了。 合并一个方块既然我们已经处理了 比较简单 的情况了，那么合并一个方块就是我们下一个需要攻克的问题。合并定义如下： 当一个方块在下一个可移动的方格上遇到相同值的方块的时候就需要合并。* 当一个方块被合并出来，棋盘就算需要改变，同样当前得分和最高得分也需要更新（如果需要的话）。 合并需要几个步骤： 在最后的位置上添加一个新的带合并值的方块 移除旧方块 更新游戏得分 检查游戏是否结束 拆解后，合并操作很简单。 1234567891011121314151617181920212223242526// ...var hasWon = false;// ...if (next &amp;&amp; next.value === tile.value &amp;&amp; !next.merged) &#123; // Handle merged var newValue = tile.value * 2; // Create a new tile var mergedTile = GridService.newTile(tile, newValue); mergedTile.merged = [tile, cell.next]; // Insert the new tile GridService.insertTile(mergedTile); // Remove the old tile GridService.removeTile(tile); // Move the location of the mergedTile into the next position GridService.moveTile(merged, next); // Update the score of the game self.updateScore(self.currentScore + newValue); // Check for the winning value if (merged.value &gt;= self.winningValue) &#123; hasWon = true; &#125;&#125; else &#123;// ... 我们只想支持一行只有一个方块移动的效果（就是说如果一行里面有两个可以合并的情况，则只会合并一个），因此不得不跟踪 合并了的 方块。通过将 .merged 标志设置成随便什么东西而不是 undefined 就可以做到。 在结束这个函数的编写之前，还需要解释一下这里用到的我们还没有定义的函数。 GridService.newTile() 函数就是简单地创建 TileModel 对象。合并操作就放在包含创建新方块函数的｀GridService｀中： 12345// GridServicethis.newTile = function(pos, value) &#123; return new TileModel(pos, value);&#125;;// ... 我们一会再回来叙述 self.updateScore()。现在暂时只需要知道它更新游戏得分就可以了（就像函数名所表明的那样）。 移动了方块之后我们只希望在一次有效的方块移动之后才增加新的方块，因此需要检查一下是否真的有任何一个方块移动了。 1234567891011var hasMoved = false;// ... hasMoved = true; // we moved with a merge&#125; else &#123; GridService.moveTile(tile, cell.newPosition);&#125;if (!GridService.samePositions(originalPos, cell.newPosition)) &#123; hasMoved = true;&#125;// ... 当所有的方块都已经移动过了（或尝试移动过），我们就继续检查玩家是否赢了。如果是，那么实际上我们就要设置 self.win 这个标志了。 当有方块碰撞的时候我们会移动方块，所以在合并的条件下，我们只简单地设置 hasMoved 为 true。 最后，我们要检查一下棋盘上是否有任何的方块移动。如果有，则： 给棋盘添加一个新的方块 检查一下有没有必要展示游戏结束界面 123456789101112if (!GridService.samePositions(originalPos, cell.newPosition)) &#123; hasMoved = true;&#125;if (hasMoved) &#123; GridService.randomlyInsertNewTile(); if (self.win || !self.movesAvailable()) &#123; self.gameOver = true; &#125;&#125;// ... 重置方块在运行任何主游戏程序前，我们要重置每一个方块以便不再跟踪其合并的状态。详细来说，就是每一次移动之后，都要清理所有记录以便让所有方块能再次被移动。因此在执行移动的循环体开头，我们会调用： 1GridService.prepareTiles(); GridService 中的 prepareTiles() 函数只是简单地迭代每一个方块然后重置其状态而已： 1234567this.prepareTiles = function() &#123; this.forEach(function(x,y,tile) &#123; if (tile) &#123; tile.reset(); &#125; &#125;);&#125;; 计算得分回头来看看 updateScore() 方法，游戏本身需要记录两个得分： 当前游戏的得分 玩家的最高得分 currentScore 只是一个在每一次游戏的时候保存在内存中的变量，因此无需特殊对待。 然而 highScore 则是一个贯穿每一次的游戏的变量。我们有几个方法来保存，比如 localstorage，cookies，或者两者结合。 因为 cookies 是两个方法中最简单而且跨浏览器安全，我们就继续使用 cookies 来存储这个 highScore。 Angular 中使用 angular-cookies 模块是管理 cookies 的最简单的方法了。 要使用这个模块，可以到 angularjs.org 上下载或者使用包管理器例如 bower 来安装。 1$ bower install --save angular-cookies 照旧，我们要在 index.html 中引用这个脚本然后在应用中将 ngCookies 设置成模块级别的依赖。 像这样更新一下 app/index.html： 1&lt;script src=&quot;bower_components/angular-cookies/angular-cookies.js&quot;&gt;&lt;/script&gt; 然后添加 ngCookies 作为模块依赖（在 Game 模块中，我们引用 cookies 的地方）： 12angular.module('Game', ['Grid', 'ngCookies'])// ... 有了 ngCookies 作为依赖，我们就可以将 $cookieStore 服务 注入 到 GameManagere 服务中。现在可以在浏览器中对 cookies 进行读写了。 例如，要读取玩家的最高得分，我们会写一个函数从用户的 cookie 中取来： 123this.getHighScore = function() &#123; return parseInt($cookieStore.get('highScore')) || 0;&#125; 回到 GameManager 类中的 updateScore() 函数，我们开始编写更新当前得分的代码。如果得分比之前记录的最高得分高，那么就更新 cookie 中的最高得分。 12345678this.updateScore = function(newScore) &#123; this.currentScore = newScore; if (this.currentScore &gt; this.getHighScore()) &#123; this.highScore = newScore; // Set on the cookie $cookieStore.put('highScore', newScopre); &#125;&#125;; track by 之怒既然我们已经将方块显示出来了，一个 bug 也同样出现了，那就是一些有奇怪行为的方块复制品冒出来。进一步来说，就是方块可能会在不应该出现的地方出现。 原因是 Angular 通过基于一个唯一的标识来获知 titles 数组里面的有什么方块。而我们把这个唯一的标识在视图中设定为方块在数组中的 $index（也就是数组中的位置）。然而我们在数组中将方块移来移去，$index 不再起到唯一标识的作用。我们需要另外的监测方法。 12345678&lt;div id=&quot;game&quot;&gt; &lt;!-- grid-container --&gt; &lt;div class=&quot;tile-container&quot;&gt; &lt;div tile ng-model=&apos;tile&apos; ng-repeat=&apos;tile in ngModel.tiles track by $index&apos;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 与其依靠数组来标识方块的位置，我们不如使用方块自己唯一的 uuid 来跟踪。自己创建唯一标识能保证 angular 将方块数组中的每一个方块看成是唯一的对象。只要唯一的 uuid 没有变，那么 angular 就会根据这个标识来将方块识别为独立的对象。 创建新实例的时候使用 TileModel，我们能非常轻松地为方块实现出唯一标识。我们还能以自己的方式来创建唯一标识。 只要对于每一个创建的 TileModel 实例是唯一的，那么怎么创建这个唯一 id 的方法并无影响。 要生成这个唯一的 id，我们跳到 StackOverflow 上找一个 遵循 rfc4122 的全球唯一标识生成器，然后将其打包成一个工厂，提供一个函数：next()： 123456789101112131415.factory('GenerateUniqueId', function() &#123; var generateUid = function() &#123; // http://www.ietf.org/rfc/rfc4122.txt var d = new Date().getTime(); var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) &#123; var r = (d + Math.random()*16)%16 | 0; d = Math.floor(d/16); return (c === 'x' ? r : (r&amp;0x7|0x8)).toString(16); &#125;); return uuid; &#125;; return &#123; next: function() &#123; return generateUid(); &#125; &#125;;&#125;) 要 使用 工厂 GenerateUniqueId，就要将它注入然后调用 GenerateUniqueId.next() 来产生一个新的 uuid。回到 TileModel 中，我们已经可以为实例生成一个唯一的 id 了（在构造函数中）。 12345678910111213// In app/scripts/grid/grid.js// ....factory('TileModel', function(GenerateUniqueId) &#123; var Tile = function(pos, val) &#123; this.x = pos.x; this.y = pos.y; this.value = val || 2; // Generate a unique id for this tile this.id = GenerateUniqueId.next(); this.merged = null; &#125;; // ...&#125;); 现在每一个方块都已经有了唯一的标识了，于是就可以告诉 Angular 使用 id 而不是 $index 来追踪方块了。 12345&lt;!-- ... --&gt;&lt;div tile ng-model=&apos;tile&apos; ng-repeat=&apos;tile in ngModel.tiles track by $id(tile.id)&apos;&gt;&lt;/div&gt;&lt;!-- ... --&gt; 这样做会出现一个问题。我们使用 nulls 来初始化数组（显式地）和 nulls 来重置数组（而不是对数组排序或者调整长度），angular 会不顾一切地试图将 nulls 看作对象。但是 null 值并不包含有唯一标识，于是就会引起浏览器抛异常，并且不知道怎么处理复制出来的对象。 所以，我们要使用内置的 angular 工具来追踪唯一标识或者数组中的 $index 位置（因为 null 对象在方格内只有一个所以可以通过数组的位置来追踪）。我们可以向如下那样修改一下 grid_directive 中的视图来解决 null 对象： 12345&lt;!-- ... --&gt;&lt;div tile ng-model='tile' ng-repeat='tile in ngModel.tiles track by $id(tile.id || $index)'&gt;&lt;/div&gt;&lt;!-- ... --&gt; 这个问题也能通过实现不同的底层数据结构来解决，例如使用迭代器来查看每一个 TileModel 的位置而不是依靠数组下标或者每次改变数组后重新调整（或在 $digest() 中调整）。为了保持简单和清晰，我们使用数组来实现因为这种实现方法只需要处理上文的副作用就可以了。 我们赢了?!?? 游戏结束当我们在原来 2048 游戏中输了的时候，一个 游戏结束 界面会滑入，让我们重新开始游戏或者在 twitter 上 follow 游戏作者。这不仅是游戏中一个酷酷的效果，也是一个中断游戏的好方法。 使用基本的 angular 技术也能做到这个。我们已经在 GameManager 使用了变量 gameOver 来确定游戏什么时候结束。可以直接就用一个 &lt;div&gt; 元素来装着游戏结束界面，然后使用绝对定位覆盖在棋盘上。这种技术（和 Angular）的神奇在于实现起来没有任何的花招： 就是简单地创建一个包含游戏结束或者玩家获胜的信息的 &lt;div&gt; 元素，根据游戏的状态来选择显示。比如，游戏结束界面看起来可以像这样： 123456789101112&lt;!-- ... --&gt;&lt;div id=&quot;game-container&quot;&gt; &lt;div grid ng-model=&apos;ctrl.game&apos; class=&quot;row&quot;&gt;&lt;/div&gt; &lt;div id=&quot;game-over&quot; ng-if=&quot;ctrl.game.gameOver&quot; class=&quot;row game-overlay&quot;&gt; Game over &lt;div class=&quot;lower&quot;&gt; &lt;a class=&quot;retry-button&quot; ng-click=&apos;ctrl.newGame()&apos;&gt;Try again&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- ... --&gt; 困难的部分是处理样式 / CSS。为效率起见，我们只是将元素设置成绝对定位在网格之上，让浏览器来决定真正的位置。这里附上 相关的 一部分 css（提醒一下，完整 CSS 在下面的 gtihub 地址中有）： 12345678910111213141516171819.game-overlay &#123; width: $width; height: $width; background-color: rgba(255, 255, 255, 0.47); position: absolute; top: 0; left: 0; z-index: 10; text-align: center; padding-top: 35%; overflow: hidden; box-sizing: border-box; .lower &#123; display: block; margin-top: 29px; font-size: 16px; &#125;&#125; 我们可以使用完全相同的技术来做获胜界面，同样创建一个代表获胜的 .game-overlay 元素即可。 动画原 2048 游戏中其中一个令人印象深刻的地方是方块似乎会魔术般地从一个网格滑到下一个网格，另外游戏结束 / 获胜界面的显示显得很自然。因为使用 Angular，我们能做到 几乎一样的效果 （感谢 CSS）。 实际上，我们做出来的游戏能够容易地实现诸如滑动，出现，显现等的动画效果。我们几乎不会碰到 JavaScript（只需一点点）就可以实现这些效果。 CSS 位置动画（也就是添加滑动的方块）因为我们通过 CSS 设置类 position-[x]-[y] 来定位方块，当为方块设置新位置的时候，DOM 元素会加上类 position-[newX]-[newY] 并移除类 position-[oldX]-[oldY]。在这种情况下，我们在 .tile 类上定义一个 CSS 变换来实现 CSS 类上自带滑动效果。 相关的 SCSS： 12345678.tile &#123; @include border-radius($tile-radius); @include transition($transition-time ease-in-out); -webkit-transition-property: -webkit-transform; -moz-transition-property: -moz-transform; transition-property: transform; z-index: 2;&#125; CSS 变换定义好后，现在方块就会在网格之间滑动了（对，就是 那么简单 ）。 游戏结束界面动画如果想在动画上取得更多的效果，可以使用 ngAnimate 模块来做。此模块本身配合 angular 一起就是开箱即用了。 在使用前，同样需要安装 ngAnimate 模块。在 angularjs.org 上下载或者使用包管理器（例如 bower）来安装。 1$ bower install --save angular-animate 同样，我们接着就需要在 HTML 中引用以便浏览器加载。修改 index.html 来引用 angular-animate.js 文件。 1&lt;script src=&quot;bower_components/angular-animate/angular-animate.js&quot;&gt;&lt;/script&gt; 最后，就像其他 angular 模块一样，我们要告诉 angular 我们的应用依赖什么模块来运行。在应用的依赖数组中加入： 123angular.module('twentyfourtyeightApp', ['Game', 'Grid', 'Keyboard', 'ngAnimate', 'ngCookies'])// ... ngAnimate虽然对 ngAnimate 的深度探讨超出本文范围（看 ng-book 来深入了解其机制），但是我们还是粗浅了解一下其工作机制以便在应用里实现动画。 引入了 ngAnimate 作为模块级别依赖之后，任何时候 angular 为相关的（对于我们的应用而言）指令添加一个新对象的时候，它也会增添上一个 CSS 类（免费）。我们可以利用这些类来给游戏中的不同组件赋予 CSS 动画： Directive Added class Leaving class ng-repeat ng-enter ng-leave ng-if ng-enter ng-leave ng-class [className]-add [className]-remove 当一个元素被添加进 ng-repeat 的作用域，新的 DOM 元素会被自动添加上 CSS 类 ng-enter。然后，当它真正地添加到视图上后，就会被添加上 CSS 类 ng-enter-active。这个机制很重要因为它让我们能够在 CSS 类 ng-enter 里设定动画的样子和在 CSS 类 ng-enter-active 里设定动画的样式。当元素在 ng-repeat 迭代器中被移除的时候类 ng-leave 也是如此的工作机制。 当 DOM 元素上一个新的 CSS 类被添加（或被移除），相应的 [classname]-add 和 [classname]-add-active 也会添加到 DOM 元素上。同理，也可以在相应的类里设定 CSS 动画。 游戏结束界面动画我们能使用类 ng-enter 来让游戏结束界面和获胜界面动起来了。记住，类 .game-overlay 是使用 ng-if 指令来实现隐藏和显示的。当 ng-if 的条件变化了，ngAnimate 会在等式值为真的时候添加上 .ng-enter 和 .ng-enter-active（或者移除元素时添加 .ng-leave 和 .ng-leave-active）。 我们会在类 .ng-enter 中设定好动画，然后在类 .ng-enter-active 中激活。相关的 SCSS： 12345678910111213.game-overlay &#123; // ... &amp;.ng-enter &#123; @include transition(all 1000ms ease-in); @include transform(translate(0, 100%)); opacity: 0; &#125; &amp;.ng-enter-active &#123; @include transform(translate(0, 0)); opacity: 1; &#125; // ...&#125; 所有的 SCSS 在文章底部的 github 连接中可以看到。 定制位置假设我们想使用不同的棋盘大小。例如，原 2048 是 4x4 的。如果我们想要 3x3 或者 6x6 呢？不用变动太多的代码我们就能轻松实现。 棋盘本身是通过 SCSS 来创建和定位的，而网格又是通过 GridService 来管理的。所以我们在这两个地方修改一下以便能自定义棋盘。 动态 CSS好吧实际上我们并不是打算弄动态 CSS，但是我们可以创建更加多实际会用得上的 CSS。与其使用单个 #game 标签，我们可以实时创建可以动态设置网格的 DOM 元素标签。也就是说，我们将 3x3 的棋盘版本嵌套在 ID 是 #game-3 的 DOM 元素下，将 6x6 的棋盘版本嵌套在 id 标签是 #game-6 的元素下。 可以在原本已经是动态的 SCSS 中编写出一个混合。就是很简单地找到 css ID 标签 #game 然后将其包裹进一个混合。例如： 123456789@mixin game-board($tile-count: 4) &#123; $tile-size: ($width - $tile-padding * ($tile-count + 1)) / $tile-count; #game-#&#123;$tile-count&#125; &#123; position: relative; padding: $tile-padding; cursor: default; background: #bbaaa0; // ...&#125; 现在我们可以引用 game-board 混合来动态创建一个包含有不同棋盘版本的样式表了，棋盘的版本都各自独立在其 #game-[n] 标签下。 要做出这样不同的版本，我们只需要遍历所有的棋盘大小然后调用上面的混合就可以了。 12345$min-tile-count: 3; // lowest tile count$max-tile-count: 6; // highest tile count@for $i from $min-tile-count through $max-tile-count &#123; @include game-board($i);&#125; 动态的 GridService现在已经编写好了应付不同大小棋盘的 CSS 了，我们还需要修改 GridService 好让启动应用的时候能设置网格的大小。 Angular 让这变得十分简单。首先，我们需要将 GridService 变成 provider，而不是一个直接的 service。如果你不清楚服务（译者注：service）和提供者（译者注：provider）之间的不同，看 ng-book 作深入了解。简单来说，一个提供者能够让我们在运行之前对其进行配置。 此外，我们也需要将提供者中的构造函数修改为 $get 方法： 12345678910.provider('GridService', function() &#123; this.size = 4; // Default size this.setSize = function(sz) &#123; this.size = sz ? sz : 0; &#125;; var service = this; this.$get = function(TileModel) &#123; // ... 提供者中任何不在 $get 方法中的方法都能在应用的 .config() 函数中访问得到。$get() 中的所有东西不能被 .config() 方法访问，而能在运行的时候被应用访问。 实现动态棋盘大小的工作就这么多。现在我们试着做一个 6x6 的棋盘而不是 4x4 的棋盘。在 app 模块的 .config() 函数中，我们叫来 GridServiceProvider 来设置大小： 12345angular.module('twentyfourtyeightApp', ['Game', 'Grid', 'Keyboard', 'ngAnimate', 'ngCookies']).config(function(GridServiceProvider) &#123; GridServiceProvider.setSize(4);&#125;) Angular 在创建一个提供者的时候，会自动生成一个仅供配置时使用的模块，我们使用名字：[serviceName]Provider 来实现注入。 演示 demo完整的 demo 在这里：http://ng2048.github.io/。 总结唷！我们希望你已经在愉快地使用 Angular 来编写这个 2048 游戏了。博文中应该已经覆盖了大部分的过程了。如果你觉得不错，可以在下面留下评论。如果你对继续学习 Angular 有兴趣，务必去看看我们的书Complete Book on AngularJS。这是唯一一本会不断更新 AngularJS 知识的书，并且包括了在 AngularJS 中所有你需要了解的东西。 在 HackerNews 上讨论 Thanks非常感谢 Gabriele Cirulli 编写出了妙极的（和让人上瘾的）2048，同样感谢他对此文的启发。文中的很多主意都是从原游戏中搜集、提炼，用以阐明如何使用 Angular 来编写。 完整代码游戏的完整代码在 Github 上，地址是 http://d.pr/pNtX。要在本地编译游戏，只需要复制代码然后运行： 123$ npm install$ bower install$ grunt serve 问题与解决方法如果你使用不了 npm install，保证你安装了最新的 node.js 和 npm。 这个版本库在 node v0.10.26 和 npm 1.4.3 上测试。 以下是一个安装最新版本的 node 和 node 版本管理器 n 的方法： 123$ sudo npm cache clean -f$ sudo npm install -g n$ sudo n stable]]></content>
      <categories>
        <category>翻译</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python × Qt 应用开发 · 5 -- 数据库 helper 类的编写]]></title>
    <url>%2Fpython-with-qt-application-development-5-database-helper%2F</url>
    <content type="text"><![CDATA[在 上一篇博文 中已经生成了数据库，而代码中的视图和模型也准备好了，但是怎么将两者联系起来呢？显然我们需要在其中做做文章，找一个 “中间人” 去读取数据库的数据并且转化为适合模型的数据。通常称这个 “中间人” 为数据库 helper 类。 什么是 helper 类顾名思义就是类似助手的一个类，数据库的 helper 类就是一个帮助程序员方便调用数据库的类。此类可以做的事情通常都是包括连接数据库，执行 SQL，转换数据类型等。 操作 Python 自带的 sqlite3 库可以自己纯手写 python 代码来全程管理数据库，需要操心的地方有点多。 databaseHelper在 app 包下新建一个 store 包，新建一个 databaseHelper.py 文件。 为帮助代码的理解，极其推荐先去阅读 Introduction to SQLite in Python 和Advanced SQLite Usage in Python，SQLite 的基本操作和进阶应用都有详细而清晰的介绍，在这就没必要重新再说。 经过以上的阅读，数据库的操作基本能掌握了，然而我们的目标是写出一个比较通用的类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#!/usr/bin/env python# -*- coding: utf-8 -*-__author__ = 'draco'import sqlite3class SqliteHelper(object): """""" @property def last_error(self): return self._last_error def __init__(self, db=":memory:"): super(SqliteHelper, self).__init__() self._last_error = None self._db = db self._con = None def config(self, db): self._db = db self._con = None def _connect(self): self.reset_error() self._con = sqlite3.connect(self._db, detect_types=sqlite3.PARSE_DECLTYPES|sqlite3.PARSE_COLNAMES, check_same_thread=True) # foreign key support self._con.execute("pragma foreign_keys = on") return self._con.cursor() def on_error(self, err): self._last_error = err def reset_error(self): self._last_error = None def execute(self, sql, param): lid = 0 cur = self._connect() with self._con: try: if param: cur.execute(sql, param) else: cur.execute(sql) self._con.commit() if cur.lastrowid is not None: lid = cur.lastrowid self.reset_error() except sqlite3.Error, e: if self._con: self._con.rollback() self.on_error(e) finally: return lid def get_raw(self, sql, param=None): cur = self._connect() data = None with self._con: try: if param: cur.execute(sql, param) else: cur.execute(sql) data = cur.fetchone()[0] self.reset_error() except sqlite3.Error, e: if self._con: self._con.rollback() self.on_error(e) finally: return data def query(self, sql, param=None): cur = self._connect() data = [] with self._con: try: if param: cur.execute(sql, param) else: cur.execute(sql) row = cur.fetchone() # format data if row: field_names = [f[0] for f in cur.description] data = dict(zip(field_names, row)) self.reset_error() except sqlite3.Error, e: if self._con: self._con.rollback() self.on_error(e) finally: return data def query_all(self, sql, param=None): cur = self._connect() data = [] with self._con: try: if param: cur.execute(sql, param) else: cur.execute(sql) rows = cur.fetchall() # format data if len(rows) &gt; 0: field_names = [f[0] for f in cur.description] data = [dict(zip(field_names, r)) for r in rows] self.reset_error() except sqlite3.Error, e: if self._con: self._con.rollback() self.on_error(e) finally: return data SqliteHelper 这个类是专门对应 SQLite 数据库的，如果要采用其他数据库就另外写对应的 Helper 类就行。 如果你有先阅读推荐的两篇文章，那么这段看似很长的代码其实一点都不难，无非就是 _connect() 连接数据库、execute() 执行 SQL 语句、query_all() 查询所有结果和 query() 查询一个结果这三个基本的功能。只是各种 try 和 except 比较多，因为数据库需要在操作失败的时候进行回滚。 query_all() 和 query() 函数中把原始的数据查询出来之后，将数据打包成了一个数组，使用字典保存每一行的数据，继而作为一个数组元素存在。所以在访问结果（一个表）的时候，通过下标可以访问每一行，通过字段名字访问值。 比较需要注意的是 _connect() 函数的第一行 sqlite3.connect(self._db, detect_types=sqlite3.PARSE_DECLTYPES|sqlite3.PARSE_COLNAMES, check_same_thread=True)。这个是让 sqlite 支持日期的设置。 另一个地方是连接数据库之后，必须手动执行一句 SQL 语句，使 sqlite3 支持外键。 1self._con.execute("pragma foreign_keys = on") 现在已经封装好了数据库的连接、查询和执行功能了，只需要一句语句就能查询 / 执行 SQL 语句了。 __init__.py接下来是为设计好的数据库编写特定的 API 了。 我希望直接使用 store 这个包来操作了，不再在包里面再另外弄文件。于是可以直接在包的 __init__.py 里面写一下静态的 API。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# in __init.py__import timeimport databaseHelper_db = databaseHelper.SqliteHelper("data.db")def error(): return _db.last_errorclass notebook(object): @staticmethod def new(name): return _db.execute("INSERT INTO notebook VALUES(null,?)", (name,)) @staticmethod def delete(id): return _db.execute("DELETE FROM notebook WHERE id=?", (id,)) @staticmethod def update(id, name): return _db.execute("UPDATE notebook SET name=? WHERE id=?", (name, id)) @staticmethod def get_all(): return _db.query_all("SELECT * FROM notebook ORDER BY id ASC")class chapter(object): @staticmethod def new(name, notebook_id=1): return _db.execute("INSERT INTO chapter VALUES(null,?,?)", (name, notebook_id)) @staticmethod def delete(id): return _db.execute("DELETE FROM chapter WHERE id=?", (id,)) @staticmethod def update(id, name): return _db.execute("UPDATE chapter SET name=? WHERE id=?", (name, id)) @staticmethod def get_all(notebook_id=None): if notebook_id: return _db.query_all("SELECT * FROM chapter ORDER BY id ASC WHERE nid=?", (notebook_id,)) else: return _db.query_all("SELECT * FROM chapter ORDER BY id ASC") 这样的话，只要执行了 import store，就可以用形似 store.notebook.new(...) 的 API 来操作文件夹，语义十分清晰。 在应用中需要得到的数据基本都能定下来，例如取所有的文件夹、取某文件夹下所有的文档等。为这些比较基础的写一下封装有利于避免在应用中写 SQL 语句，也能避免数据库有什么更改而连带造成应用中的代码也需要更改。 也就是，应用只需要知道调用什么 API 操作数据就行了，无需考虑应该数据怎么取。 随意插入几个数据，可以看到数据成功存入数据库了。 查看 SQLite 的数据库（一个 db 文件）可以使用‘SQLite Database Browser’。 是否可用 Pyside 提供的 QtSqlPyside 本身也提供丰富的数据库支持，如果源数据是比较平面，例如表格和列表，那么使用 Pyside 自带的 QSqlTableModel、QSqlRelationalTableModel、QSqlQueryModel 会比自己写更好，无需自己再造轮子。这些 Pyside 提供的 “轮子” 已经带有对数据库的操作，而且因为是官方写的，总比自己写出来的放心。 然而树状的阶级型数据，并没有原生 model 支持，过程都必定要涉及将数据库的表格型结构转化为树状，所以自己写也没差。 形象一点的话，数据的流向如下： treeModel &lt;--&gt; 自定义数据结构（数组） &lt;--&gt; 数据库 这是自己写操作数据库类的情况。 treeModel &lt;--&gt; QSqlTableModel/QSqlRelationalTableModel/QSqlQueryModel &lt;--&gt; 数据库 这是用原生 model 的情况。 需要注意的是上面的流中，treeModel 和数据库才是重要的，中间只是一个类似 adapter 的存在，那么明显直接用自定义的数据结构更方便。 类 QSqlTableModel、QSqlRelationalTableModel、QSqlQueryModel 都在 PySide.QtSql 下。 小记注意真的开发软件如果像这系列的想到一个功能就开发一个，写一段代码就运行一下来测试是不行。尤其是团队开发的时候，不可能每次写一段代码就整个应用运行一次。应用如果很大，编译起来时间长是一个问题，有些必要模块甚至还没开发出来也是一个问题。真正的软件开发还需要架构设计、写文档、画层次图和使用测试驱动开发等流程。此系列的文章只是入门和熟悉 python+QT 的开发，读者还需要额外学习更多的开发知识。]]></content>
      <categories>
        <category>技术</category>
        <category>编程语言</category>
        <category>python</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Qt</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python × Qt 应用开发 · 4 -- 数据库设计]]></title>
    <url>%2Fpython-with-qt-application-development-4-database-design%2F</url>
    <content type="text"><![CDATA[在上一篇探讨 MVC 模式使用的博文中，已经成功实现了 Tree Viewwidget 的数据显示。而实际上，其中的数据是我们自己硬编码的，显然不符合要求。节点中的 _data 域也只是简单的字符串，没有体现出 MVC 的优势。对于本应用中要求的比较有结构化的数据，很自然地考虑使用数据库来组织。 数据库的考虑作为本地应用，考虑使用 python 自带的嵌入式数据库 sqlite3。SQLite 跟普通数据库管理如 MYSQL 等大同小异，SQL 语句也是相差不大，一般有学习过数据库的读者找找资料大概就能轻松理解，而没有使用过数据库或者不懂数据库的读者则应该先补充好数据库的知识再来阅读本文。 在 python，只需要加上 import sqlite3 语句就能使用 SQLite，方便至极。 笔记本笔记本的数据结构是一棵棵树，叶子节点是章节。考虑使用一个名为 notebook 的表来保存笔记本数据，一个名为 chapter 的表来保存章节。 打开数据库设计工具，这里选用了一个在线的工具 WWW SQL Designer。画出以下设计图。 表 notebook 字段 内容 id 主键 name 笔记本名称 表 chapter 字段 内容 id 主键 name 章节名称 nid 所属笔记本 id，外键 表 document 字段 内容 id 主键 cid 章节 id，外键 title 文档标题 content 文档内容 last_update 文档最后更新时间 然后使用输出功能输出 sql 脚本文件，注意这里的代码在我的电脑上是能够运行的，但不一定能够在你的电脑上运行： 123456789101112131415161718CREATE TABLE &apos;chapter&apos; (&apos;id&apos; INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,&apos;name&apos; TEXT NOT NULL DEFAULT &apos;new group&apos;,&apos;nid&apos; INTEGER NOT NULL DEFAULT 0 REFERENCES &apos;notebook&apos; (&apos;id&apos;) REFERENCES &apos;notebook&apos; (&apos;id&apos;));CREATE TABLE &apos;document&apos; (&apos;id&apos; INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,&apos;cid&apos; INTEGER NOT NULL DEFAULT 0 REFERENCES &apos;chapter&apos; (&apos;id&apos;) REFERENCES &apos;chapter&apos; (&apos;id&apos;),&apos;title&apos; TEXT NOT NULL DEFAULT &apos;New document&apos;,&apos;content&apos; TEXT DEFAULT NULL,&apos;last_update&apos; NUMERIC NOT NULL);CREATE TABLE &apos;notebook&apos; (&apos;id&apos; INTEGER NOT NULL DEFAULT NULL PRIMARY KEY AUTOINCREMENT,&apos;name&apos; TEXT NOT NULL DEFAULT &apos;new notebook&apos;); 生成数据库保存 sql 脚本到工程根目录下的 data.sql 中，到 SQLite 官网下载 windows 版本的 CLI 文件 sqlite3.exe，同样放在工程根目录下。执行以下命令： 1sqlite3.exe data.db &lt; data.sql 如无报错则生成了一个 data.db 的数据库文件了。 小结文章只说明了各个表和字段的关系，字段的详细属性请查看 sql 语句。]]></content>
      <categories>
        <category>技术</category>
        <category>编程语言</category>
        <category>python</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Qt</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python × Qt 应用开发 · 3 -- MVC 中 model 的基本实现]]></title>
    <url>%2Fpython-with-qt-application-development-3-basic-model-in-mvc%2F</url>
    <content type="text"><![CDATA[上一篇博文中，界面是设计好了，也能运行了，但是这个应用还只是个空壳子，widget 里什么都没有。这篇博文就来充实其中一个的 widget，左边的文件夹列表。 MVC 大法好有过一些开发经验的读者肯定会听说过 MVC，这里不详细解释 MVC 了。Qt 中也有提供这样的模式，而且既有提供已经整合好的 widget，也有提供单单 view 而自己需要编写相应的 model 和 controller。后一种显然要比前一种麻烦，但是使用上可能后一种反而更多。为什么？因为在实际开发中，涉及到数据的显示很多时候都要附带上数据的操作，那些整合好的 widget——比如 List Widget 和 Tree Widget 和 Table Widget——能做到的基本只是将数据都转化为字符串来输出，一旦涉及到数据的修改的话…… 也不是不可以做到，但是编写出来的代码既繁琐又不通用。 从 Qt 的官方文档来看，这些 widget 的函数大多数都是操作 view 这个层面的，函数名字里面大多包含 item，比如插入数据核心步骤是使用 QTableWidgetItem(data) 生成一个包含单个数据——data 的 item 然后用 setItem (row, column, item) 将这个 item 设置在特定位置，这里的 item 其实相当于一个单元格了。但注意修改了这个 item 是并不能保证影响到原先的 data 的，而且这样单独地设置 item 的数据数据的操作，稍加思考便能明白，已经丢失了原来数据——也就是 data——跟其他可能存在的 data 的关系了。更进一步，如果修改了这个 item 的数据，要怎么找回原来的 data 也是个大问题。 根据之前博文的要求，如果编写文件夹列表这个 widget，我们考虑用 Tree View 然后自己编写 model 会比较好，因为文件夹本身就天然具备树的特征。另外文件夹还允许重名，我们不能只根据文件夹名来标识，而是需要另外的唯一标识，这就暗示了一个树节点所包含的数据是多个的了，最起码包含了节点的名称和节点的标识，单单 QTableWidgetItem 是比较难满足要求的。 实现一个简单的 model上一篇博文全程在用 QtDesigner，这次就转到 python 代码上了。在 app 包下新建 model 包，再在里面新建 treeModel.py。 接下来…… 怎么写啊…… 还是先来一些前置知识吧。 Qt 中 model 的基本概念 上图来自 Qt 官方文档，简单易懂。可以看到，三个基本的 model——List Model、Table Model 和 Tree Model——都有着类似的结构：有一个根 Root item，有 row（行）的概念，有列 column（列）的概念。 相似的结构暗示了 view 和 model 应该是可以自由配对的，因为可以基于某些规定的接口来结合在一起，而且这些接口估计跟根节点 Root item 和行列的属性（长度是最显著的特征了）有关。List Model 就是一个一维数组，以单下标确定位置；Table Model 是一个而为数组，以双下标确定位置；Tree Model 就是一棵树，以父节点和行数确定位置。或许你会觉得这跟普通的数据解结构没什么分别，但是注意了，途中的一个节点（就是一个正方格）是没有规定成什么数据类型，也就是不局限于是数字或者字符这样的基本类型，也可以是更复杂的对象甚至对象的数据结构形式。这些一个个的节点（正方格）只是在模型的层面上表现一致而已。 另外似乎除了 Table Model 以外并不能看出 column 的作用，实际上 List Model 和 Tree Model 也有 column 的概念，只不过基本上在模型层面上是只有一列。这个是什么意思呢？也就是说，对于 List Model 而言，最关心的特征是 row 也就是行数，但读取数据时非要加上 column 来定位的话应该在节点（正方格）内的数据上体现出数组来，对比 Table Model 则是在节点（正方格）上就体现出需要 row 和 column 同时定位。对于 Tree Model 而言也是同样。 文字太多不要觉得麻烦，当你先阅读了大概的描述，潜意识有了一些模糊的概念之后，立刻去写代码，理解起来比一边写一边看容易得多。 上代码我们来先用代码描述这些 “节点”（正方格），以 Tree Model 为例。 12345678class GenericNode(object): def __init__(self, data, parent=None): self._data = data self._parent = parent self._children = [] if parent is not None: parent.appendChild(self) 先写一个一般性的节点类 GenericNode，一个节点包含了三个必要的域：父节点、子节点列表和数据。一个节点在被创造出来的时候就可以决定其父节点和数据，而父节点是可以为空的（根节点或者孤立节点），若指定的父节点不为空则需要要求父节点将新创造的节点加入到它自身的子节点列表中。注意此时 appendNode 函数我们还没有实现。 然后立刻就是 appendNode 函数。 123def appendChild(self, child): self._children.append(child) child._parent = self 非常简单，将节点加入自身的子节点列表中。这里考虑到加入的子节点有可能并没有指定过父节点，所以追加了一句 child._parent = self。 接下来是数据的访问。 12345def data(self): return self._datadef setData(self, value): self._data = value getter、setter，没什么值得解释。 再来是对查询节点关系的回应。 123456789101112def parent(self): return self._parentdef child(self, row): return self._children[row]def childCount(self): return len(self._children)def row(self): if self._parent: return self._parent._children.index(self) 都是非常简单的函数。parent(self) 和 child(self, row) 分别是返回父节点和和指定的子节点（对应着上面的图可以明显看出应该通过数组方式访问子节点）。childCount(self) 是返回子节点长度以便能遍历子节点，row(self) 则是查询本节点在兄弟节点中的位置。 最后加入一个属性来跟其他类型的节点区别一下，因为其他节点将会继承自这个类。 1234@propertydef type(self): """custom function""" return "generic" 接着是特殊节点。 1234567891011class NotebookNode(GenericNode): @property def type(self): """OVERRIDE""" return "notebook"class ChapterNode(GenericNode): @property def type(self): """OVERRIDE""" return "chapter" 继承的同时重写了 type 属性来区分不同的节点，暂时不去写更详细的函数。 节点部分就基本写好了，接下来是模型结构部分。基本框架的代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class TreeModel(QtCore.QAbstractItemModel): def __init__(self, root=None, parent=None): super(TreeModel, self).__init__(parent) self._rootNode = GenericNode(None) if root is None else root def rowCount(self, parent): """IMPLEMENT""" if not parent.isValid(): parentNode = self._rootNode else: parentNode = parent.internalPointer() return parentNode.childCount() def columnCount(self, parent): """IMPLEMENT""" return 1 def index(self, row, column, parent): """IMPLEMENT""" if not parent.isValid(): parentNode = self._rootNode else: parentNode = parent.internalPointer() childNode = parentNode.child(row) if childNode: return self.createIndex(row, column, childNode) else: return QtCore.QModelIndex() def flags(self, index): """IMPLEMENT""" if not index.isValid(): return QtCore.Qt.NoItemFlags return QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsEditable def headerData(self, section, orientation, role=None): """IMPLEMENT""" pass def parent(self, index): """IMPLEMENT""" if not index.isValid(): return QtCore.QModelIndex() node = index.internalPointer() parentNode = node.parent() if parentNode == self._rootNode: return QtCore.QModelIndex() return self.createIndex(parentNode.row(), 0, parentNode) def data(self, index, role): """IMPLEMENT""" pass Don’t panic，待我慢慢解释。根据官方文档，继承 QtCore.QAbstractItemModel 和 init 函数没什么好说的，注意到其他函数里面，都注释有 IMPLEMENT 字眼，已经明显地说明这些函数需要重写实现的了。 rowCount(self, parent) 返回本层节点的个数。 columnCount(self, parent) 返回节点中数据的个数，直接返回 1 是因为数据显然只有 1 个。 index(self, row, column, parent) 这个函数实现 view 对 model 的访问，parent 是一个从 view 传过来的 QModelIndex 对象，通过参数 row 和 column 来确定访问其某一个子节点，isValid() 是其用以检测此对象是否有效的函数，取得了子节点之后需要将其包装成 QModelIndex 对象返回，也就是需要语句 self.createIndex(row, column, childNode) 的原因。由于包装的关系 parent 也需要使用 internalPointer() 得到真正的节点对象（在这里就是 GenericNode 或其子类）才能继续操作。 个人理解就这就相当于在 view 和 model 直接加入了一层数据访问实现层，官方文档称之为 index-based system。使用的时候不用管那么多，记得中间需要这样转换就是了。当然你要研究的话可以去看源码，但是显然文章的重点并不在这里。 flags(self, index) 概括来说，这个函数可以设定节点在 view 中的表现方式。从它需要返回的常量的名字可以看得出来，节点是有多种组合方式的，这里的代码表示了节点是 “可选择的”（Selectable）、“可交互的”（Enabled）和 “可编辑的”（Editable）。 常量列表： QtCore.Qt.NoItemFlags QtCore.Qt.ItemIsSelectable QtCore.Qt.ItemIsEditable QtCore.Qt.ItemIsDragEnabled QtCore.Qt.ItemIsDropEnabled QtCore.Qt.ItemIsUserCheckable QtCore.Qt.ItemIsEnabled QtCore.Qt.ItemIsTristate 多种属性的组合可以通过或运算 | 将其组合在一起，比如代码中的 QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled。 headerData(self, section, orientation, role) 是对于数据段的标题显示的设置，我们这里只有一个数据，又不需要显示标题，暂时不管。 parent(self, index) 根据官网所说，这个函数直接用官网的代码保证不会在 view 查询节点的时候得到根节点就可以了，所以这里的代码原封不动使用官网提供的例子。 data(self, index, role) 需要重点讲解的函数。顾名思义就是对数据的访问，参数 index 毫无疑问就是一个 QModelIndex，而 role 是什么呢？role 可以理解为 “角色”，它的值表明了 view 对于数据的要求，比如 QtCore.Qt.DisplayRole 说明 view 要求 model 提供一个可以供显示的字符串，会作为 view 中节点的名字；再比如 QtCore.Qt.DecorationRole 说明 view 要求提供一个图标作为节点中的装饰，等。我认为这个是 model 的精华所在，通过这样不同的角色的区分，同一个节点可以为 view 提供不同的数据类型，分别用作操作和显示等。比起 Tree Widget，使用这种方式无疑更具灵活性。更厉害的是，如果你觉得常量提供的角色不够，可以使用 QtCore.Qt.UserRole 和 QtCore.Qt.UserRole + 1、QtCore.Qt.UserRole + 2 这样来扩充。因为这些常量本质上只是数字而已。 一部分常量列表： QtCore.Qt.DisplayRole QtCore.Qt.DecorationRole QtCore.Qt.EditRole QtCore.Qt.ToolTipRole QtCore.Qt.StatusTipRole QtCore.Qt.WhatsThisRole QtCore.Qt.SizeHintRole …. 更详细的列表 现在来实现这个函数。 12345678910111213def data(self, index, role): """IMPLEMENT""" if not index.isValid(): return None node = index.internalPointer() if role == QtCore.Qt.DisplayRole: return node.data() elif role == QtCore.Qt.DecorationRole: pass elif role == QtCore.Qt.ToolTipRole: return node.type 要做的事情就是先判断一下 index 是否有效，然后就判断 role 的值，返回不同的数据。这里是名字显示数据 data，而悬浮提示则是节点的类型。 至此 model 基本实现了，最后是使用。 返回 MainWindow.py，在 MainWindow 类中加入： 12345678910111213def buildCatalog(self): root = treeModel.GenericNode("root") notebook1 = treeModel.NotebookNode("NotebookNode1", root) chapter2 = treeModel.ChapterNode("ChapterNode2", folder1) notebook3 = treeModel.NotebookNode("NotebookNode3", root) chapter4 = treeModel.ChapterNode("ChapterNode4", notebook3) self._folderModel = treeModel.CatalogTreeModel(root) self.ui.treeViewCatalog.setModel(self._folderModel) self.ui.treeViewCatalog.expandAll() 做的事情很简单，使用之前编写的代码建一棵树，结构是： notebook1┗chapter2notebook3┗chapter4 把根节点交给 model，使用 setModel 函数将 model 绑定到 view 上。为了好看把树全部展开。 最后在 __init__ 函数中调用这个函数，运行。 小结终于结束了本博文，使用 MVC 模式的代码也能工作了。回想文章开头的 “MVC 大法好”，这句话的可是有前提的，就是能理解好概念和驾驭到代码。]]></content>
      <categories>
        <category>技术</category>
        <category>编程语言</category>
        <category>python</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Qt</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python × Qt 应用开发 · 2 -- 界面初步设计]]></title>
    <url>%2Fpython-with-qt-application-development-2-preliminary-design%2F</url>
    <content type="text"><![CDATA[之前的一篇可以算是前置知识的快速介绍。从这篇开始就是正式地编写应用了。~~ 其实是因为之前我还没有想好要做什么应用。~~ 为了兼顾举举例子和真实性，选了这么一个应用：PQ 笔记。基本的功能如下： 笔记支持富文本粘贴 按文件夹分类笔记 画出大概的样子先来一个大概的设计图。 就是一个规规矩矩的三栏布局，左边是笔记本的目录树，中间是文档列表，右边是文档内容。这个只是现阶段的大概构思，最终做出来不一定是这样的，有可能在一些细节上会有所更改，但是整体界面几乎都可以定下来了。 打开 ui_mainwindow.ui，从 Containers 里拉出三个 Widget，分别命名为 widgetLeft、widgetMiddle 和 widgetRight。这就是左中右三栏的容器。 在左边栏中拖入一个 pushButton 和一个 treeView，分别对应设计图上的两个控件。注意，如果拖放位置正确（也就是 QtDesigner 知道你要将控件放进左边栏里面），你会看到左边栏 widgetLeft 会变暗了。 对着左边栏空白处点击右键，依次选择 布局 -&gt; 垂直布局。 可以看到控件非常听话地从上到下排列好了。这里为 widget 中的控件快速设定了一个布局，相当于告诉 widget 中的控件该如何显示自己。 注意，这个 “布局” 并不是 widget 中的属性，而是独立的另一个类 QLayout 及其子类的实例。在对象查看器中点选 widgetLeft 后在下面的属性编辑器中可以看到有一栏 Layout，这个才是控件们服服帖帖的原因。只不过，当为一个 widget 选择了布局之后，QtDesigner 自动给这个 widget 增加了一个布局，然后将 widget 里面的子控件加入到布局中，于是子控件们都知道应该如何显示了。 同理，在中间控件 widgetMiddle 中放入一个 LineEdit 和一个 ListView，在右边控件 widgetRight 中放入 TextEdit，并且设置好布局。 现在使用快捷键 Ctrl + r 预览，发现拉伸窗口的时候，里面的三栏控件没有任何反应，这可不是想要的效果。 注意整个窗口其实也是一个 widget，同样需要为其设置布局。 再预览，出现一个新问题：三个栏不能各自调整大小。 要实现这个功能需要另外一种布局管理，分裂器（QSplitter）。分裂器允许元素调整各自的大小。 先打破布局。 按着 ctrl 选择三个分栏 widget，注意是分栏 widget，再在其中一个 widget 的空白处点击右键，在布局中可以看到有 使用分裂器水平布局。 最后为窗口应用垂直布局就可以了。预览的时候当鼠标移动到分栏控件之间会发现可以调整大小了，同时调整窗口也能影响到三个分栏的大小。 从实际来说，调整窗口的大小的时候，更多是希望调整右边栏即文档显示栏的大小。 QSplitter 还能设置一些细节。 找到 QSplitter 的属性： orientation，控件排列方向，水平还是垂直 opaqueResize，是否实时显示调整 handleWidth，调整条的宽度 childrenCollapsible，控件调整成过小时是否会隐藏 似乎没有什么可以用的。 然而，问题的解决方法却不在 QSplitter 上，而在其子组件上。 实际上，几乎所有的 widget，都有一个 sizePolicy 的属性，而在此属性中，有子属性 Horizontal Stretch 和 Vertical Stretch，对应中文 水平伸展 和 垂直伸展，决定水平和垂直的缩放比例。 在属性编辑器中，可以看到 水平伸展 的值默认为 0，也就是左栏：中栏：右栏 = 0：0：0，现在将右栏的 水平伸展 值设为 1，也就是左栏：中栏：右栏 = 0：0：1。 预览一下，效果就出来了。 原理应该是这样的，在窗口缩放的时候，默认的配置是 0：0：0，表示变化被平均分配到两个组件上了。而修改后子组件们根据已经设定好的比例 0：0：1，所有的因窗口缩放而引起的大小变化 全部 被分配到文档编辑组件上了。 布局管理（Layout Management）布局可以在 Widget Box 里面看到，提供的有四个布局： Vertical Layout Horizontal Layout Grid Layout Form Layout 分别是垂直布局、水平布局、网格布局和表单布局。当然还有另外的自动布局，但是这四个基本能满足普通需要。 垂直 / 水平布局不用解释了。网格布局是类似表格，一个控件占据一个单元格位置；表单布局是类似平常表单，从上到下排成多行，每行分两栏，左边放标签控件，右边放输入框控件。 菜单在新建一个窗体的时候，QtDesigner 就已经为窗体添加上了 QMenuBar，在窗体的标题栏下面可以看到一个经典的菜单栏，上面有 在这里输入 字样。只要双击并填上你希望显示的菜单名字，QtDesigner 会自动生成一个菜单，在下拉列表上继续双击 在这里输入 将会自动生成 QAction。QAction 才是真正代表着菜单里的某个动作。 在下拉菜单里面，还能看到一个 添加分隔符，是添加一个分割线的意思。当生成了一个 QAction 之后，可以看到右边有一个类似加号的图标，是将当前 QAction 转化为 QMenu 的意思，换句话说可以生成子级菜单。子级菜单的操作跟上面描述的菜单操作一模一样。 另外给各个 action 对象修改好名字，以供日后调用。]]></content>
      <categories>
        <category>技术</category>
        <category>编程语言</category>
        <category>python</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Qt</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python × Qt 应用开发 · 1 -- 基本界面]]></title>
    <url>%2Fpython-with-qt-application-development-1-basic-view%2F</url>
    <content type="text"><![CDATA[至少出来一个窗口既然是 GUI，那么最起码能运行并显示一个窗口出来。 首先在 python 的工程里面建好工程结构。 结构并非必要，只是个人习惯这样建而已。下面来解说一下。 main.py，整个应用的入口 app 包，用来放应用的文件 app.view 包，用来放应用 ui 相关的文件 打开 QtDesigner，会有一个自动弹出框，直接选择其中的“Main Window”，然后点 create，一个窗口就出来啦。QtDesigner 的主界面暂时没什么好说的，有经历过 GUI 设计的读者估计也很熟悉。 现在我们先保存，文件名为 ui_mainwindow.ui，保存到 app.view 下。 接下来是比较重要的一步，也是之后经常用到的步骤：将. ui 文件编译成. py 文件。 执行以下命令。1pyside-uic mainwindow.ui -o mainwindow.py 非常好理解，使用 pyside-uic 将 ui_mainwindow.ui 编译，输出为 ui_mianwindow.py。 以后每一次更改了. ui 文件，都要这样执行一下取得. py 文件。我自己为了方便，写了一个批处理文件，要编译. ui 文件的时候就可以直接拖到这个批处理文件上自动编译了。代码如下，保存为 ui2py.bat。1pyside-uic %1 -o %~n1.py 好的，现在我们已经拥有这个窗口的类的基本代码了。好奇的你可能想知道生成了什么。 哇，一堆代码。都是编译生成的，无需做修改，只是要留意类名 Ui_MainWindow，之后要使用这个类。 OK 下面来调用这个 Ui_MainWindow 类。在 app 包下新建 MainWindow.py，写入以下代码。 12345678from PySide import QtCore, QtGuifrom view.ui_mainwindow import Ui_MainWindowclass MainWindow(QtGui.QMainWindow): def __init__(self, parent=None): super(MainWindow, self).__init__(parent) self.ui = Ui_MainWindow() self.ui.setupUi(self) 这个就是最基本的对窗口类的使用。从代码上可以看出，自定义的 MainWindow 类继承了 QtGui.QMainWindow 并且初始化，接着调用 Ui_MainWindow 来生成 ui。一个窗口其实就创建好了。这里超前说一下，以后的功能实现代码基本都写在这个类里面了，所以这个类并不是 ui 类，而是类似于 MVC 中的 Controller，ui 类是 Ui_MainWindow。 窗口创建之后还要显示出来，注意应用程序跟窗口是两个概念。现在，在 main.py 中写入如下代码。 12345678910import sysfrom PySide import QtCore, QtGuifrom app.MainWindow import MainWindowif __name__ == "__main__": app = QtGui.QApplication(sys.argv) window = MainWindow() window.show() sys.exit(app.exec_()) 写过 python 代码的读者应该很熟悉这个判断的代码了，就是入口嘛。代码生成了一个变量名为 app 的 QApplication 实例，生成了 MainWindow 实例（自己写的），然后最后一句是运行 app 实例，等待其返回的状态码来关闭程序。实际上在程序运行的时候，代码是会卡在 app.exec_() 这里的，一旦执行了什么关闭程序的操作之后才会执行 sys.exit()，所以这里并不是显示窗口之后立刻结束。 啊，终于可以运行了。 啥都没有，正常，我们还没有加入控件呢。 加入一些控件回到 QtDesigner，从左边的 Widget Box 里面找到到 Label、Line Edit、Push Button 这三个 widget，点击拖动到中间的窗口设计上。 从右上角的 Object Inspector 中可以看到刚刚添加的 widget，每一个都有自己唯一的标识，现在来把这些标识改成符合自己风格或者标准的新标识。双击标识或者点选 widget 之后在右下角的 Property Editor 里面的 objectName 进行修改。 进行以下修改： label -&gt; labelTest lineEdit -&gt; lineEditTest pushButton -&gt; pushButtonTest / buttonTest 可以看出是偏向 “类型 + 自定义标识” 的命名，这样修改的好处是使用的 IDE 有自动补全功能的话，只要输入例如 pushBu，IDE 就会自动列出所有的 pushButtonwidget 供选择。至于自定义标识单词首字母大写，则是个人习惯而已。 保存 &amp; 编译一下，回 IDE 运行查看。（以后不会再提醒保存 &amp; 编译了） 现在除了输入框可以输入、按钮可以按之外，没什么可以做的事，因为我们还没有指定这些操作会触发哪些事件。接下来就是比较难的部分：使用 Qt 的信号 &amp; 槽机制。 Signals &amp; Slots(信号 &amp; 槽)接下来的步骤可能有点难以理解，我尽量解释。先贴一段从 IBM 上找到的文字。原文 所有从 QObject 或其子类 ( 例如 Qwidget) 派生的类都能够包含信号和槽。当对象改变其状态时，信号就由该对象发射 (emit) 出去，这就是对象所要做的全部事情，它不知道另一端是谁在接收这个信号。这就是真正的信息封装，它确保对象被当作一个真正的软件组件来使用。槽用于接收信号，但它们是普通的对象成员函数。一个槽并不知道是否有任何信号与自己相连接。而且，对象并不了解具体的通信机制。 简单来说，只要对象继承于 QObject 或其子类，就可以发射（emit）信号和使用槽来接收信号。对象可以通过 emit signal（发射信号）来告诉外界自己正在做什么或者某种状态，而能够接收到信号的 slot（槽）则会被信号激活而调用（因为其本身是一个对象成员函数）。那么顺理成章地，widget（显然是从 QObject 继承下来的）可以通过 emit signal 来报告状态，然后我们只要用 slot 来接收就行了。 具体一点，在我们在上面写的简单界面中，输入框的内容改变了，应该能够发射信号告诉外界这件事，而我们只要编写一个 slot 来接收这个信号就可以做爱做的事了。 如果有 GTK 编程经历的读者可能发现跟 GTK 的信号和回调函数有点像。 直接 Google 关键字 QLineEdit（widget 前都会加上一个 Q），从官方文档中可以查出在输入框文字变化的时候会 emit 一个 textEdited 的 signal。 在 MainWindow.py 里简单实现一下。 123456789101112131415161718class MainWindow(QMainWindow): def __init__(self, parent=None): super(MainWindow, self).__init__(parent) self.ui = Ui_MainWindow() self.ui.setupUi(self) # initialize ui self.initUI() def initUI(self): self.ui.lineEditTest.textEdited[str].connect(self.updateLabelText) self.ui.pushButtonTest.clicked.connect(self.buttonClick) def buttonClick(self): QMessageBox.about(self, 'title', 'content') def updateLabelText(self, text): self.ui.labelTest.setText(text) 添加了一个 initUI(self) 作为自己对窗口初始化的函数和一个 buttonClick(self) 和 updateLabelText(self, text) 作为 slot。 慢慢来解释。首先是两个 slot，buttonClick(self) 的作用是弹出一个消息框，标题是“title”，内容是“content”；updateLabelText(self, text) 的作用是将接收到的文字更新到 label 上。 注意这里调用窗口中的某个叫 xxx 的 widget 是使用 self.ui.xxx 来调用的，简单易懂。 initUI(self) 函数是专门用来自定义的 ui 的（注意只是自己写的并不是什么必要的函数）。函数内第一行和第二行的代码的意思是将 widget 上的一些信号“connect”（连接）到我们自己定义的 slot。通过将 signal 和 slot 连接起来，emit signal 的时候这些 slot 就会被触发，也就是相当于执行了。但是！第一行代码到 textEdited[str] 可能有读者就开始不明白了，为什么比下面的信号 clicked 多了 [str]？在上面就已经说明过 textEdited 是代表文本变化的 signal，于是 signal 里面携带上变化后的文本也是理所当然的事情，但是问题就在这里了：普遍来说，signal 里面是可以包括不同数据 / 多个数据的（或者说，你可以理解成不同类型的参数 / 多个参数），在 C++ 上有类似重载的机制来分辨，但是在 python 里面是没有提供重载（为什么不提供，来自知乎)，如何分辨？我猜测 PySide 是使用了 map 来解决的，实际上在系列之后的文章中也会使用到一个叫 QSignalMapper 的类来实现从多个无参数的 signal 转换成有参数的 signal。 那说了那么多，那这里的 [str] 究竟是怎么回事？我认为，这里可以理解为假定这个 signal 有可能携带一个数据，但这个数据可以有几种类型，用 [str] 就是选定了其中带文本类型的数据的 signal 来进行跟 slot 的连接。就像取数组里面的一个元素，不是吗:) 而 clicked 就容易理解了，就是点击了按钮呗，无需要传参，直接连接到 buttonClick。 下面来运行一下，记得运行的文件是 main.py。gif 动态图展示。 小记这篇博文实际涉及的东西不多，但是就是后面开发的基础，特别是 signal&amp;slot 的概念，有不清楚的，尽量去问 Google。本系列的重点也不在这些概念上，以后的博文就不再作解释了。 最后来总结一下重点： 工程结构 QtDesigner 的基础使用 ui 文件编译 应用运行的最小代码和 widget（包括窗体）的调用 Signals &amp; Slots]]></content>
      <categories>
        <category>技术</category>
        <category>编程语言</category>
        <category>python</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Qt</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python × Qt 应用开发 · 0 -- 序]]></title>
    <url>%2Fpython-with-qt-application-development-0-prologue%2F</url>
    <content type="text"><![CDATA[python？python 是个很好用的语言，即使学校没有教，很多同学也会自己学。虽然比较少用 python 来做桌面程序，但是某些情况下需要用到 python 的数学或者统计功能的时候，又需要用有 GUI 的程序来交差。个人比较推荐用 C# 来做桌面应用程序（Windows 平台的话），只是 VS 这庞大的 IDE 和各种库还是会让某些有独特癖好的人侧目。这个时候用大家都比较喜欢的 python 就最好啦，搭配 Qt 来做 GUI 实在是方便。 于是就有了本系列。对比起其他教程 / 指南里只有单独的控件编写实例，在系列中我会使用 python 和 Qt 真实地编写出一个应用来，一边写应用一边写本系列的博文。途中遇到的问题也会记录下来并且尽量还原解决过程，希望能让读者有开发的真实感。实际上我在自主学习的时候在找资料和控件的测试使用上已经疲于奔命，也希望本系列能够总结出一个比较有效和固定的流程。 Qt？其实要在 python 实现 GUI 并不一定要使用 Qt，python 原生自带的 Tkinter 和下载一个 wxPython 库也可以。只是 Tkinter 嘛，做出来的界面实在难看，你看 python 自带的 IDLE 就知道了；wxPython 嘛，似乎没有什么比较成型的 GUI 设计工具。Qt 的话有一个 QtDesigner，比较好用。于是这里就是用 Qt 了。（实际上是以前写 C++ 的时候 GUI 用 Qt，不想转了 = =） OK，现在选定了 Qt 之后还有一件事，就是用 PyQt 还是 PySide。为什么有两个呢？嗯，我没有仔细去研究过，Qt 本身的历史就比较复杂。这里我选用 PySide 来，没别的，因为之前的一个科创项目 Micro XenServer Manager 中已经用了 PyQt，这里就尝试使用另外一个。在网上搜寻过相关资料，PySide 和 pyqt 的差别可以说在普通情况下影响不大，所以打算使用 pyqt 的读者也可以看本系列的博文来共同学习。 至于安装 python 和 PySide，不在这里详述，在 Windows 下 python 和 PySide 的安装就是两个 exe 文件的事情而已，Linux 下的话会用的人比我还专业。注意 QtDesigner 也要安装上，方法自己 Google 去。（最新版的 PySide 似乎会附带上） 系列博文使用的是 python2.7.3，PySide1.2.1。]]></content>
      <categories>
        <category>技术</category>
        <category>编程语言</category>
        <category>python</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Qt</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Chrome（谷歌浏览器）个人详细教程——提高篇]]></title>
    <url>%2Fchrome-tutorial-advance%2F</url>
    <content type="text"><![CDATA[本篇教程介绍一些我在日常使用 Google Chrome 时发现的小技巧（当然这些技巧在网上一搜一大把，但是介绍我在实际使用中经常使用的比介绍所有的技巧更有用）。运用这些技巧，你会发现使用 Chrome 浏览网页是一件惬意的事情。 标签页是可以随意拖动的有些时候会开很多的标签页，比如我在编程的时候：查在线的 API 文档，查使用技巧，查详细使用教程等等，一开就是上十个标签页。有时有一些标签页使用的频率并不高，切换起来就很麻烦。如果经常使用的两个标签页离得太远，总觉得太累。不过，只要你左键点击某个标签并且按住，然后左右拖动，你会发现标签页是可以左右移来移去的。呵呵这样就可以重新调整标签页的位置了，切换也变得方便了。 标签页变窗口有时候便签页真的太多了，或者同时几个任务一起进行：一边查资料，一边上 twitter/facebool/google+/weibo，还要看博客，看视频。那么就把主题相同的标签页弄到一个浏览器窗口吧～左键按住标签页向下拖动，是不是发现标签页被 “拉” 出来了？一松手，标签页立刻变窗口！而且，你能将一个浏览器窗口中的标签页 “拉” 出来，“放”到另外一个浏览器窗口上，这不就是标签页分类了么？！具体做法是先 “拉” 出一个标签页作为新的浏览器窗口，然后再 “拉” 出一个标签页，拖动到后一个浏览器窗口的标签栏上，如果 “嵌” 进去了就成功了～ 强制 https有些时候嘛，有些网站嘛，可以使用 https 加密协议访问，但是每次都需要手动在网址前面加，麻烦。应用商店里面有解决这个问题的应用，但是我介绍一个不用任何应用的方法。新建一个标签页，网址输入 chrome://net-internals，回车，来到一个页面如下图：左边选择“HSTS”，在左边的 Domain 填入你想自动使用 https 的网址，比如 www.google.com，下面的选项 Include subdomains 是包括子域名的意思，就是所有在该网址下的页面都是用 https 协议访问。最后点击按钮 Add 就行了。 右键翻译如果你还记得之前介绍浏览器设置的时候有提到过的自动翻译，那么这里其实不需要，因为浏览器会自动提醒。但是以防万一，我还是说一下，在遇到一些使用不是你懂的语言的网页，只要在空白出点击右键，有一个翻译的选项，点击之后就会开始对网页进行翻译了，不过机器翻译的质量。。。通常惨不忍睹，所以还是好好学外语吧～嘛有的时候临时用一下也是够给力的。]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Chrome（谷歌浏览器）个人详细教程——扩展程序篇]]></title>
    <url>%2Fchrome-tutorial-extension%2F</url>
    <content type="text"><![CDATA[从这篇个人教程开始，就是 Google Chrome 的进阶使用了，如果你只是偶尔使用浏览器上上网电脑小白，看了之前的教程基本就可以流畅地使用这个浏览器了，大可不再追看。只是，接下来所要涉及的，才是 Google Chrome 的迷人之处。 不知道大家还是否记得 IE 时代的时候，如果你安装软件不留神，就有可能给 IE 装上不少所谓的“插件”，而且还删除不了（有点还是赤裸裸的病毒、木马），就是所谓的流氓插件了。其中最著名的似乎是“3721 中文上网助手”，大家上网一搜就知道这东西当年多么的难缠，用到的手段比如改注册表，注册系统内核，挂全局钩子，进程守护，简直就是木马和病毒了。如果知道了这东西是谁搞出来的你就会觉得非常滑稽，不过这话题不在本教程讨论的范围内，还请大家自己去了解。 总之，插件存在的意义应该是辅助浏览器更好地工作的，而 IE 这样对于插件的容忍的方式却不能被大众所容忍。其实 IE 上只有很少有用的插件，比如各种下载工具添加在右键的下载选项，可以说几乎不需要插件。 在插件上著名的就是 FireFox（火狐）了，其中最著名的插件大概是 FireBug 了。这是一个可以对网页进行各种 “解剖” 的插件，能让你了解每一个网页元素的所有属性、看清楚 DOM 树、看脚本的执行情况、查看文件的加载时间等。这是一个开发者必备的插件（前提是你使用火狐）。火狐的插件还有很多很多，在新版的火狐里有一个专门的页面指导你搜索和安装插件。在我的记忆里，火狐的插件然而，有一个恼人的弊病，那就是——安装了插件要重启火狐插件才能工作。其实，这也没办法，毕竟名字是“插件”，顾名思义大概就是要主程序加载的东东（个人理解，有误请指正）。还有，插件越装得多，浏览器就越慢，因为进程要处理的东西变多了。 来看看 Google Chrome 如何？在 Chrome 上也有所谓的 “插件”，但是名字是“扩展程序”，也就是并不是插件，虽然也是能起到辅助浏览器的工作。Chrome 上的扩展程序安装了之后不需要重启浏览器，立刻就能使用，这是个优点。另外，根据官方的介绍，扩展程序都运行在分离的进程中，并不会影响浏览器的性能（当然还要看你的电脑的性能，这跟开很多个程序的情况差不多），也不会影响浏览器的安全性。让人不太爽的大概就是打开任务管理器会看到很多名字是“chrome.exe” 的进程，还有主进程占用内存比较多。 现在就介绍怎么为 chrome 装上扩展程序。点击“扳手”-&gt;“工具”-&gt;“扩展程序”，浏览器会自动打开一个标签，其实就是设置里面的“扩展程序”。如果你并没有安装任何应用程序，那么右边的列表是空的，只有一个超链接。以下是我的 chrome 扩展程序截图：点击超链接来到 Google Chrome 网上应用商店。页面非常友好，左边有分类和搜索框，你可以根据自身需要来选择。比如我要安装这个应用（别吐槽有些图片加载不了，中国网络你懂的）点击“添加至 CHROME”，弹出确认安装的对话框，按“安装”等按钮变成“已添加至 CHROME”，就搞掂了。 要管理扩展程序，同样是在设置里面的 “扩展程序” 就可以进行卸载或者配置。 至于每个扩展程序的配置，就不再讨论了。 下面是个人推荐的扩展程序： speed dial 2快捷工具易词典ireaderProxy Switchy!read later fast图片搜索]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Chrome（谷歌浏览器）个人详细教程——日常使用篇]]></title>
    <url>%2Fchrome-tutorial-daily-use%2F</url>
    <content type="text"><![CDATA[如果你看到这篇教程，那就假定你已经在电脑上安装了 Google Chrome 浏览器了。如果不是，我想最好请你先浏览一下这个教程系列的前两篇：总论篇和安装篇。 好，下面开始日常使用的教程。 总体格局现在，打开你的浏览器看看：最上面是便签栏，可以看到经典的梯形标签；下面就是长长的地址栏，地址栏里面的左边有一个放大镜的图案（会变化的，打开了网页是灰色地球的图案；使用 https 加密方式是一个锁的图案），右边有一个星号，那个是将当前页面添加为标签的按钮；地址栏左边分别是后退前进刷新按钮，右边是一个扳手按钮，其实就是设置按钮了，以后的教程约定称为“扳手”。页面框内会看到你当前安装的一些应用和最常访问的网页（8 个格子），这样你可以快速打开曾经打开过的网页和应用。 网站访问好了，现在可以输入网址来访问网站了，想必很多人一上网就习惯先打开搜索引擎吧？例如 Google（谷歌）、yahoo!（雅虎）和 bing（必应）。如果你是这样，那么这里有一个技巧：如果你在安装浏览器的时候选择了默认的搜索引擎，那么在地址栏输入搜索的关键字就可以直接以默认的搜索引擎搜索了，省去了先访问搜索网页的一步。实际上，你可以随时随地这样做，只要你输入的关键字并不像网址，譬如一个词或者一句话什么的，没有明显的 “.com”“.org” 之类的后缀，chrome 都会认为是搜索关键字。但是要注意，如果你输入的是英文而你之前访问过网址含有你输入的英文字符串，chrome 会智能地帮你补全网址，虽然能减少了网址字母的输入量，但是搜索就变得麻烦了，幸亏在自动弹出的下拉框里可以选择不同的网址或者搜索你输入的字符串。默认搜索引擎可以在 “扳手”-&gt;“选项”-&gt;“基本设置”-&gt;“搜索” 处修改。 右键菜单现在你可以像其他使用浏览器一样使用 Google Chrome 了：打开网页，点开链接等等。而在网页的空白处点击右键，你可以看到： “另存为”，是指将当前网页保存在你的电脑上，以便没有联网也可以查看。 “打印”，不用解释了吧。 “查看网页源代码”，就是另外打开一个页面查看网页的 HTML 代码。 “查看网页信息”，是否使用加密链接之类的信息。 “审查元素”，是一个类似 firefox 里面 firebug 的功能，之后会详细说。 而如果你是对着链接点击右键，那么弹出的菜单选项就不同了： “在新标签中打开链接”，就是新建一个标签打开链接，但留在当前页面。 “在新窗口中打开链接”，新建一个浏览器窗口打开链接。 “在隐身窗口中打开链接”，采用隐身模式浏览打开的链接，此模式下浏览器不会记录你的浏览历史并会删除 cookie，具体参见这里 。 “链接另存为”，将链接所指的文件下载到本地，一部分情况下相当于传统意义的“下载” “复制链接地址”，顾名思义就是将链接复制。这个选项非常有用，因为 Chrome 在不加插件的情况下点击下载是不会自动加载迅雷等下载工具的，不像 IE 那样迅雷会接管下载申请。这是为了安全着想，防止网页调用病毒或者木马。但是迅雷的设置里面不是有 “监控剪切板” 的功能么？结合这个来用就解决用下载工具下载的问题了。 书签管理书签就是收藏一个网页以供你日后快速访问。想收藏一个网页只需要点击地址栏里面右边的星号就行。而且你可以分不同的文件夹存放书签，十分人性化。 点击 “扳手”-&gt;“书签”-&gt; 书签管理器可以实现对书签的总体管理。可以导出导入书签，新建删除移动书签等。 快捷键使用电脑要快要方便，快捷键必不可少。下面介绍一些常用的： F5、Ctrl+F5 刷新、强制刷新。强制刷新是无视缓存彻底重新载入页面。不明白？呃，有时候页面刷新几次还是错误就试试强制刷新吧。 Ctrl+C、Ctrl+X、Ctrl+V 分别是复制、剪切和粘贴。 Ctrl+F 快速查找。这个快捷键几乎全软件通用，可惜半数以上使用电脑的人不知道。按快捷键，页面右上方会出现一个输入框，输入要找的文字浏览器就会在页面上找出来并统计个数和高亮，最适合在大段文字中找东西。 Home、End 移到页面最上、最下。 Ctrl+S 保存当前页面 Ctrl+W 关闭当前标签。你的鼠标不用移上去标签栏了，多方便啊。 Ctrl+T 新建一个标签。你的鼠标不用移上去标签栏了，多方便啊。 Ctrl+Tab、Ctrl+Shift+Tab 转到下一个标签、上一个标签。你的鼠标不用移上去标签栏了，多方便啊。 Ctrl+1、2、3…. 分别对应转到第一个标签、第二个标签… 你的鼠标不用移上去标签栏了，多方便啊。 你可能觉得记住快捷键很麻烦，不过，我可以保证，当使用电脑久了你就反而觉得移动鼠标跨过屏幕更麻烦。尤其是你在双手打字的时候，移开手简直是浪费时间。快捷键只要多用就能记住了，不需要刻意去记。左右开弓总比只用一只手舒服。 基本设置点击“扳手”-&gt;“选项”。我们来关注一些日常的设置。 基本设置 启用时：设置浏览器第一次打开的时候动作 主页：就是设置主页了 工具栏：建议将”显示 “主页” 按钮 “、“总是显示书签栏” 都选上 搜索：建议默认为 Google 默认浏览器：设置 Google Chrome 为默认浏览器 个人资料 密码：设置是否保存你输入的密码和管理密码 浏览数据：从其他浏览器导入你的书签等数据 主题：就是改皮肤了 高级选项 隐私设置：这里可以清楚你的上网记录以及产生的垃圾 翻译：建议选上。当你浏览外文网站浏览器就会询问你是否需要翻译，或者点右键也可以翻译当前页面 下载内容：修改下载文件保存的位置 在线同步如果你有一个 Google 帐号，那你用 Chrome 就有福了。Chrome 提供了帐号同步服务，可以在线保存你的浏览器上的书签、设置、应用等。知道这意味这什么吗？简单来说就是无论你在哪上网，使用哪台电脑上网，只要你使用 Chrome 并且登录你的 Google 帐号，那么 Chrome 就会自动变成你日常使用的那个 Chrome——你的设置、书签、应用全部都会自动“回来“，无需重新设置，也不用怕辛辛苦苦找的书签丢失。 点击 “扳手“-&gt;” 登录到 chrome 浏览器 “，输入邮箱和密码登录。接着可以选择同步的内容，一般选书签、应用程序、扩展程序、主题和偏好设置就行。然后你可以想象你已经“保存游戏” 了～当在其他电脑上安装新的 chrome 时，直接登录你的帐号，chrome 就会自动 “读取游戏”。如果你想登出帐号，在个人资料 -&gt; 登录处可以断开。]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Chrome（谷歌浏览器）个人详细教程——安装篇]]></title>
    <url>%2Fchrome-tutorial-setup%2F</url>
    <content type="text"><![CDATA[安装一个软件本来无需什么教程的，因为很多人接触电脑时间不短了，这些基本操作还是应该会自动学会的。但是，Google Chrome 在安装上与其他软件稍微有所不同，安装篇就是来打消安装过程中的疑虑和不安的。 首先是下载安装文件。Google Chrome 有两种安装方式：一、到国内的比较知名的软件下载站下载离线版，比如天空、华军、zol 上。不推荐这种方法，原因后面解释。二、在 Google 的 官网 上下载在线安装版。 现在你可以看到右上角大大的按钮 “下载 Chrome 浏览器”，先别激动，我想你应该先好好看看页面靠下的地方，看见右边的“先去 Chrome 网上商店瞅瞅” 么？你可以点进去先感受一下 Chrome 的庞大的应用，想得到的想不到的都应有尽有。提示：访问有可能比较慢，一部分原因是使用了 https 加密浏览的缘故（ 你可以看到网址前面 https://），因为这个应用商店可以跟你的 Google 帐号相关联，所以安全性是必须要保障的。另外的原因大概是中国网络的缘故。 再来看看左边的 “翻翻绘本，看看 20 件关于浏览器和互联网的事儿。” 如果你并不想花时间深入浅出了解浏览器和互联网，这里的链接可以无视。大概看了看，写得不错，我自己也很有收获。好了，现在你可以去点击“下载 Chrome 浏览器”，然后来到一个服务条款页面，浏览一下服务条款然后点击“接受并下载”。如无意外，你会看到以下的画面： 接下来就就只是等待。在等待的时候，我解释一下为什么选择在线安装版本。我承认，这个在线安装耗时比较长，并不是网页上说的“安装程序将在几秒钟内完成”。我认为是因为中国网络的原因，Google 退出中国市场之后就似乎剩下香港和北京有服务器，所以下载慢也是没有办法的事。 那为什么不去软件站下载？因为在软件站上下载的是离线安装包，而离线安装包是没有升级功能的，所以如果网络不是太差，还是去安装在线官方版为好。 如果你的下载已经完成，那么 chrome 浏览器会自动打开并且系统会显示 “欢迎使用 Google Chrome 浏览器” 对话框，并提示您选择要在浏览器中默认使用的搜索引擎。还有导入主页设置和浏览器历史记录，够贴心了吧？ 好了，到现在你就已经安装了 Google Chrome 浏览器了。如果还有什么不明白可以参阅官方的详细帮助]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Chrome（谷歌浏览器）个人详细教程——总论篇]]></title>
    <url>%2Fchrome-tutorial-preface%2F</url>
    <content type="text"><![CDATA[考试之前就承诺了写关于 Google Chrome 的使用教程，趁着刚放假还有动力就快快搞掂吧～教程会有点长，因为我想让看的人能逐步深入而不是看得云里雾里的并且力求内容够丰富。如果你看完后对电脑上必然有的网页浏览器有更深的认识，我就觉得值了。 网页浏览器，在现今接入网络非常容易的时代，是一个必不可少的软件。就本人来说，一开始接触网络是使用 IE（Internet Explorer）的，相信基本上和我差不多年龄或者比我大的都是这样的情况。如果你知道有一个浏览器叫做 Netscape，那么你也应该对网页浏览器有比较深的了解了。不少人以为浏览器就是 IE，这个想法大错特错，甚至可以说是井底之蛙之见解。这样就好比说起操作系统就只知道 Windows 而不知道 Linux 和 Mac OS（好吧还有 Unix），说起手机只知道诺基亚而不知道苹果一样。 IE 是微软公司捆绑在 Windows 操作系统里面的一个网页浏览器，IE 的流行很大程度上是托了 Windows 流行的福。IE 其实并不是指一个网页浏览器，它有不同的版本，常见的是：IE6、IE7、IE8、IE9、IE10。IE6 是捆绑在 WindowsXP 里面的，而 XP 在中国有不少用户（可以说基本上个人电脑上的使用率极大），所以 IE6 是最多人用的一个网页浏览器，注意，只是在中国。 然而，随着网络越来越普及，接入越来越方便，网页浏览器也越来越重要，无论是对于商家还是对于个人。因此，也就出现了许多新的网页浏览器。本人使用浏览器的经历是（均是使用时间比较长的）：IE6-&gt;世界之窗 -&gt;Maxthon2.x-&gt;Google Chrome。不过本人实际使用过的浏览器有：IE6、IE7、IE8、IE9、IE10、Firefox5、Firefox7、Opera、Safari、腾讯 TT、世界之窗、Maxthon2.x、Maxthon3、搜狗浏览器、360 安全浏览器、Google Chrome。不得不说，各款网页浏览器都其自身认为的 “特点” 和“卖点”，即使是同一款浏览器，不同的版本都有不同的功能侧重和改进，这本身代表着浏览器的发展和对开发人员对使用者的心理以及习惯的探索过程。 总而言之，现在的网页浏览器多得满地都是，但主流的还是能数得出来。 如果你对浏览器的历史还感兴趣，请去看下面的图片，非常清晰明了。图片较大，就只给链接了。大图慎入 那么，究竟怎么样的浏览器适合我们使用呢？ 这是个见仁见智的问题，基本回答都是“我觉得好用就好用咯”“习惯的最好”。无可置疑，使用得最舒服、最顺手的就是好浏览器，只是，没有使用过之前，你知道某款浏览器好用吗？你第一次使用网页浏览器你觉得习惯吗？不可能吧？使用的习惯需要一个长时间的养成，但是最开始的时候却是随机的选取。所以，使用习惯固然重要，但是并不能够成为你不使用其他浏览器的理由，因为你不知道其他浏览器是不是真的让你不习惯，真的不够你正在使用的浏览器好用。这是我使用过很多浏览器之后的感受。 还是回到那个问题：用什么浏览器？或者，好的浏览器应该具备什么特点？以下是个人见解。 1、打开网页的速度这个很重要，我想没有人会否定。没有人能忍受打开一个网页需要长时间的载入（当然，这也取决于网站自身的设计和优化），但是，打开同一个网页，速度快的浏览器无疑占有极大的优势。主流浏览器页面加载速度可以参考太平洋网的评测 2、界面设计好的软件界面能让使用者愉悦，也能吸引新使用者。现在的主流是简洁。简洁的软件界面能使软件打开的更快，使用户更好地集中于所要做的事情上，而不是纠结于工具栏和各种按钮上。看看各种浏览器较新的版本吧，你会发现基本上都是有多简洁就多简洁：一个地址栏，一个便签栏，没了，从而有更大的空间来显示网页。Chrome 从一开始就是这个风格，让用户更好地忘记自己在用浏览器，更多地关注在网页上。说到底，浏览器不就是让你看网页的工具而已么？ 3、可扩展性我想一般人不会考虑到这个方面。只是，广义上说，除了让你浏览网页外的功能应该就是扩展了（个人意见），例如广告拦截、鼠标手势、沙箱模式、云同步什么的。以前给 IE 装这个那个的插件其实也是给 IE 弄上扩展了，但是后来各种流氓插件和主页劫持之类的让很多人都对其深恶痛绝。现在很多浏览器都支持安装官方提供的扩展应用，使浏览器的功能更加强大，firefox 和 chrome 在这方面就做得很好。相比国内的浏览器在此方面就弱势了或者甚至没有这种功能。但是可以预见，这将是浏览器的竞争优势。有了扩展，浏览器可以做更多的事，甚至取代电脑上的软件。 4、安全性鉴于某些浏览器标榜自己拥有安全上网的功能，我就发表一下自己的见解。实际上，浏览器搞安全功能还不如给电脑装上一个杀毒软件和防火墙。安全上网，只是针对 IE6 而言的。众所周知，在普遍使用 IE6 的时候，经常出现浏览器安全漏洞和浏览到挂病毒挂木马的网站。这是没有办法的事，因为 IE6 的漏洞实在是太多了，而杀毒软件对于病毒的检测都还是处于“后知后觉”。后来杀毒软件都加上了主动防御和防火墙，上网中毒已经很少见了。而且通常中病毒的都是使用 IE 内核的浏览器，说安全上网什么在现在浏览器多极化发展的时候作用已经不大了。 5、自身的亮点上面说到的所谓的 “安全上网” 就是浏览器自身的亮点例子之一。真的，也许功能并不实用，但是能吸引用户，就算是成功了。一个毫无自身特点的浏览器也就等同于可以被替换的浏览器。要知道新颖新奇永远能吊起人的好奇。当然，有些浏览器的高使用率也不是其自身有什么特别之处，而是其推广手段很强势甚至流氓，例如非要说你的原有的浏览器这不行那不行，必须使用它提供的才安全才好，或者每次软件升级就要在安装文件里面加上附加的它自家的浏览器安装什么的这一类推广手段实在令人恶心。 打算写的是 Google Chrome 的使用教程，为什么谈了那么多？ 如果你压根没有尝试使用新的浏览器的勇气和念头，我希望我谈的能让你有兴趣去试一下。浏览器一定会变得越来越重要，因为网络正在变得越来越重要。浏览器并不是 “无所谓” 了，相反，更应该受到重视和了解。如果你还是懒得去尝试的，OK，继续使用你的 IE、搜狗、whatever… 起码这篇文章你看到了这里，我想你在用原先的浏览器的时候也会闪过某些不曾有过的念头。传说上一次体育抢课用 Chrome 的都登陆进去了，其他的悲剧，于是 Chrome 党多了不少… 虽然从理论上来说这不是太靠谱，但是想想网页没有打开之前你按个按钮都不行，我只要打开网页比你更快就能先登陆了… 我要尝试用其他浏览器了，但是为什么用 Chrome？ 好吧，在经历过这么多浏览器之后（前文有提到喔），说真的，我对 Chrome 是一见钟情，无法自拔。它来自于一个浏览器开源项目，名字是 chromium。Chrome 可以说是 chromium 的稳定版。 还记得我提到的好的浏览器的标准吗？从前文的评测你可以看得出，chrome 打开网页的速度基本都是最快的，在屏蔽了广告后更快（以后会提到）。界面也是率先设计得简洁和漂亮的，换皮肤换打开界面这些功能老早就有了。可扩展性好得没话可说，chrome 的应用商店就像苹果的应用市场一样可以随意下载应用供浏览器使用（免费！！）。而且 Google 是什么？是一个全球互联网巨头，全球的人都会发布应用在上面，所以应用的数量也是足够的多。你甚至可以用给浏览器装上游戏，例如：愤怒的小鸟。安全性有保障，使用的内核并不是传统的 IE 内核而是大部分的 webkit 内核，此内核下几乎没有病毒可言，而且浏览器也会在你浏览危险网页的时候阻止你。以上的特点其实就是它的亮点：能符合这么多的标准并不是轻松的事。但，Chrome 的魅力并不只有如此的少，不然就不少网站不会有专门研究 Chrome 的专区了。实际上，Google 想把 chrome 更多地作为一个应用的平台而不单单只是浏览器。Google 推出的上网本系统其实看起来就像一个浏览器。]]></content>
      <categories>
        <category>技术</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《来自风平浪静的明天》人物关系简单理清和个人简单分析]]></title>
    <url>%2Fnagiasu-relationship-between-charactors%2F</url>
    <content type="text"><![CDATA[凪のあすから可能是10月番里面人物关系最乱的一个番？现在看来似乎还有一个季度可以给岡田麿里来玩，但是里面的人物关系发生了一些变化，各种CP的支持者都对自己支持的CP有所期待，我认为能做到这样这番就算是良作了。 现在暂时更新到14集，刚刚是发生剧情转折的一集，从一期（1-13）的贵圈真乱要变成二期（14-）的贵圈更乱了。于是先来理清一下人物关系。 世界简介：有两类人类，分别住在陆地上和大海里。大海人有“胞衣”保护可以在水里面生存，陆地人是很久以前上岸的人，“胞衣”已经消失。两类人之间总的来说关系不太好。 大海人如果跟大陆人联姻的话会被赶出大海，因为陆上人和大海人的孩子不能在大海里面生存。 基本的5人贵圈（名字能简写就简写了，免得太复杂）： 男一：光 女一：爱花 男二：纺 女二：千 男三：要 5人中除了男二是陆上人，其他4个都是大海人并且是青梅竹马的关系。均是初中生（一期）。大海的4人因为大海里面的中学被废校而转学到陆上的中学。 在一期里面，能看出来的5人基本关系是（-&gt;表示喜欢）： 男三-&gt;女二-&gt;男一-&gt;女一?-&gt;男二 要-&gt;千-&gt;光-&gt;爱花?-&gt;纺 注意这里使用了-&gt;的都是符号前面的角色已经对符号后面的角色表白了，而爱花和纺之间使用了?-&gt;是因为动画里面暂时没有清楚表达爱花的意向，女二（爱花）似乎对男二有憧憬，但是又很在乎男一（光）。另外被表白的人都没有对表白做出正面的回应。正所谓“不表白就不会死”，为什么不明白。 OK，到现在为止，人物关系其实还并不太复杂，跟另外一部《在盛夏等待》差不多。 继续添加上其他人的关系。男一（光）有个姐姐叫明里， 喜欢一个叫至的陆上人。而这个叫至的陆上人，曾经跟一个现已去世了的叫美织的大海人结婚并生下一个叫美海的女孩子。明里和美织从初中开始关系就很好，因此跟至及美海关系也很好。然后美海（小学生）喜欢男一（光）。 还能跟上吗？ 美海有一个经常在一起的朋友纱由（小学生），应该是喜欢男三（要）。 再补上一些其他信息。男一的父亲（灯），不赞成明里（男一姐姐）的婚姻。男三有个非直属的爷爷，曾经是大海人。 不要问为什么能够出现这样的关系，具体剧情请自行去补番。 接下来就是一期（1-13）转二期（14-）的人物关系变化了，总的来说就是5人内贵圈，7人外贵圈。 因为暂时还不明的天气转冷的原因，大海人决定冬眠来度过。13集中明里（男一姐姐）在举办祭奠（一个陆上人和大海人之间的传统祭奠）上顺便举办婚礼，由于海神(？)的干预，不慎落水，男一女一下海救人；男二落水，女二下海救人，男三也去帮忙。最后的结果是女一代替了明里被海神带走，明里被救，女二带着男二上岸，男一和男三消失在大海里面。 实际上可以这样理解，除了女二，其他大海人都冬眠了。 于是14集开始蛋疼了。根据我推测剧情大概是过了4-5年，女二被男二的爷爷（曾是大海人）收留，男二女二两人均上了大学，明里和至结婚（男一和美海成了舅甥/舅侄），美海和纱由成了初中生。至此大概就是开始7人贵圈了。而由于时间的流逝和物理上的阻隔，人物的心理和关系也有了变化。 从14集可以明显看出三点信息。一、男二（陆上人，纺）明显喜欢女二（千）的，但是知道女二喜欢男一（因为之前两人谈论过相关的话题），一直没有表露。而女二由于一直跟男二及男二爷爷生活，对他们也是当家人看待（大概能从三处很明显的场景可以看出） ，对男二的态度还不明朗。二、美海还是喜欢男一（光），有同学跟她告白也是立即拒绝，并说“放弃什么的……不可能”。虽然这句话极有可能是最后成为苦逼的flag，但是暂时还不能断言。三、美纱（美海的朋友）很有可能还是喜欢着男三（要）。 14集的最后，男一（光）由于幻月这个天文现象而从海里苏醒回来了，美海因为他刚回来的时候没有呼吸而做了人工呼吸。但是男一是能够生活在大海里面的怎么会溺水呢，所以我认为这里更多是情不自禁的意味。注意在日本动画里面，人工呼吸是比较特别的事件，因为涉及接吻。从出现了这个事件这一点来看，美海要加入贵圈是无疑的了。 根据现有的剧情，大概推测一下之后的发展。我认为岡田非常狡猾地使用了时间这个大杀器，给乱糟糟的人物关系一个终结的推动力。时间上的错位，导致本来的同龄人变成了类似不同辈份的人，这里应该就打消了女二（千）和男一（光）的可能，加上女二对男一的表白本来就有放弃的意味，而男一的回归也极有可能让女二放下心结，最后从了喜欢她的男二（纺）；也导致本来不同龄的人变成了同龄人，男一男三还是保持着初中的时间，而喜欢男一的美海（男一的外甥女）和喜欢男三（要）的纱由刚好就是变成了初中生，从而出现凑成CP的可能性。然而我认为男一跟美海的可能性实在是极小，一是因为男一自此至终都显示出只喜欢女一（爱花），二是因为双方比较特殊的辈份，三是因为美海也有追求者并且在动画中会成为苦逼的flag相对比较明显（岡田就是喜欢和精通苦逼的感情戏）。男三和纱由的戏份实在很少，比较难预测。最后来说说被海神带走的女一的情况，无非就是回归与否。若回归，极其有可能跟男一组成一对，即使中途会和男二发生各种事件。因为基本上女一是个对感情比较迟钝的人，也不愿意伤害朋友，有可能看出男二喜欢女二而下定决心回应男一。若不回归，那就没什么可说了，和另一个爱花（绝园的暴风雨中的女主，CV同样是花泽香菜）一样了。 总的来说，虽然过程会很乱，但是结局通常还会正常的。个人看好如下组合：男一（光）X女一（爱花）、男二（纺）X女二（千），最多加上一个男三（要）X纱由，最后是美海一个苦逼。 正是： 多角恋爱 看岡田笔下结局 风平浪静 最后附岡田麿里的一些信息： 曾经是《true tears》、《龙与虎》、《花开物语》和《那朵花》的系列构成，难怪对写青春期男女感情纠结之类的非常在行。在访谈中曾经透露自己小时候经常会妄想故事，甚至会被自己的故事感动到哭，会以五十音的顺序来妄想跟班里的男生约会的场景和故事。]]></content>
      <categories>
        <category>ACGN</category>
        <category>动画</category>
      </categories>
      <tags>
        <tag>anime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PSO2/鬼斬/剑灵，网游个人分析和感受]]></title>
    <url>%2Fpso2-onigiri-bladesoul-personal-comment%2F</url>
    <content type="text"><![CDATA[我玩的网游很少，而且都只玩免费网游。目前为止，曾经坚持玩下去的网游就只有洛奇、洛奇英雄传、Phantasy Star Online 2、鬼斬和剑灵。其中洛奇和洛英玩了比较短的一段时间后已弃，原因是玩得太寂寞。重点说说个人对后三个游戏的感受好了。受游戏知识和运行环境的影响，个人观点难免有所偏差。简单介绍（非常短，详细请自行Google去） PSO2：如果我说Phantasy Star的中文名字是梦幻之星的话，会不会有很多人恍然大悟。游戏类型是ARPG，游戏背景是宇宙，有剑士枪手魔法师等职业选择。 鬼斬：十分新的一个网游，13.12.12才正式运营。中文资料很少，台服官网介绍是“和风无锁定MMORPG”。何谓无锁定，后面会大概说说。公司是Cyberstep（没听过……），题材大概是奇幻系列，NPC的名字是什么“靜御前”“義經”之类的日本古人名字。 剑灵：近来在中国很火啊，大概玩过网游的人都知道，不多说了。 玩的理由&amp;近况PSO2：在PSP上玩过《梦幻之星2》，既然出了online版那就去玩一玩，结果发现不错，于是就一直玩了。后来SEGA限制了非日本IP的登录，我没有日本VPN于是玩不了了。近来看到有英文版的主页，估计会出欧服或者美服？不知何年何月了。 鬼斬：在网上偶然看到介绍，画风十分讨喜，游戏官网也做得很好（是旧的日服官网，参考台服官网），看宣传片也觉得有兴趣。游戏当时宣布是点卡制，后来改成了无料，不玩似乎说不过去（锚定效应起作用了）。只是这货更新很成问题，我挂VPN更新经常失败，也不知道为什么，暂时在靠贴吧的雷锋过日子。但是一旦更新好了，玩起来是不成问题的。 剑灵：听说跳票了很久的一个游戏，实验室里面曾经有朋友说这个游戏公测了就和我一起玩，现在公测了就只有我下载了来玩。在某个区开了一个号，因为太寂寞了就换了另外一个班里的同学都在的区。现在一边追赶班里的同学的级数一边合武器和首饰中。 操作PSO2：上手容易，打怪有准星锁定，但是只要打中怪就能扣血。特色是怪是有弱点的，如果能瞄准弱点，则事半功倍，反之事倍功半，所以打boss都是瞄准弱点打。网上有1血挑boss的神触视频。不同类型的武器都有特定的招式，招式需要事先组合好，通过左右键发出。 鬼斬：无锁定，就是不会帮你将武器的输出自动定位到怪上。虽然也有准星，但是作用只是提示你怪在武器的有效距离以内而已，跟怪物猎人比较像，也是我很欣赏的一点。上手比较难，但是能以技巧挑boss，娱乐性更强。武器的普通招式是固定的，长按或者多次按左键连击发出，但是不同武器是有不同的三种特殊攻击，通过123键或者q键切换，右键发出。 剑灵：什么都不说了，上手极其容易，等级和武器决定一切。虽然有一个合击和打断，但是比起等级和武器的重要性，实在是比较低。不同职业有不同的招式，1到4和z到v，八种招式随便放，合击要配合空格和f，实在是要人精分……当然有组织的出招才能保证打得怪起不来。 声音PSO2：背景乐不错啊，重点是NPC的配音请了有名的声优！名声优的声音包也是作为商品还是赠品来着。 鬼斬：不同地图音乐不同，在副本任务中音乐也一直有。感觉很是配合这个游戏的和风风格，反正听起来很舒服。 剑灵：在记忆中似乎是不错来着，可惜好像只是出现在跑地图的时候。在副本任务中好像没啥背景音乐？我现在是关掉音乐然后在nico听广播来玩的。 画面（我的机子烂，不敢妄评）PSO2：我只开中级画面，已经很好看了。曾经试过开高级画面，机子温度狂飙升。但是高级画面下的水面超漂亮。 鬼斬：非常恶心的没有调整画质等的选项，只有全屏和桌面两种切换，切换的时候还会崩溃。 剑灵：除了不用最低配置外，所有质量调最低，保证操作顺畅。长期二十来帧……PS：我的机子还是只用来编程算了…… 武器系统-使用（太庞大，挑重点和特点说）PSO2：可以设定几种武器，战斗的时候随时切换以适应地形和怪物。鬼斬：可以设定最多4种武器，随时切换，因为很有可能一种武器都打烂了还没有打通…… 剑灵：一个职业只能用一种武器，而几乎所有人都是用同一把武器…… 武器系统-进化PSO2：大概没有人不会痛恨负责武器研磨的大叔。这游戏打出了武器之后，有时需要鉴定，并且可以通过研磨石使武器逐渐进化上最高的十星级，但是研磨是会失败的，失败的时候那个大叔还会嘲讽说“你的运气真差啊”。有可能你挥霍了99个一组的研磨石，最后武器反而变差了，实在是比较坑。另外也可以给武器附加属性什么的。同一类武器有很多种，不同武器样子也不一样。除了职业限定的武器，你尽管用，自由得很。在游戏里看到的不同人行头和武器都很不一样，个人感很是强烈。 鬼斬：玩的时间不长，拿到的武器不多。武器掉落后需要给“靜御前”来鉴定，“義經”来强化或者修理。是“武器喂武器”的模式，武器的种类也比较多。 剑灵：相信几乎每个人都是拿着体制武器的吧，也就是只要职业形同，那么基本上必定是洪门、妖魔这样升上去，毫无新意。武器的成长和进化需要大量其他同种武器的堆砌和各种稀有辅助材料。而这一切的结果，最后也不过是得到了跟别人一模一样的行头和能力，但你要在这个游戏里面生存下去，就不得不这样干。这模式是不是很熟悉？要我说在游戏里面也得这样做也实在太悲哀了。 辅助系统PSO2：一定等级可以拿到一只玛古，就是宠物了，喂各种各样的东西可以成长和进化。因为喂不同的东西进化的路线不同，所以有专门的研究。我是随便喂的了……身上三个地方可以加上辅助道具。战斗前可以加官方提供的buff，而且是要钱的。 鬼斬：暂时来说无宠无坐骑，估计以后也不会有。只有勾玉这一样辅助道具。比较特殊的还有有时间限制的“酒”。 剑灵：无宠无坐骑。有一个独特的八卦牌的设定可以得到多种辅助加成，凑齐一套有套装加成。配合跟武器一样是体制式的首饰（喂武器还不够……），基本都是RPG的一贯设定了。 任务&amp;副本PSO2：任务都是在飞船内找NPC领任务然后传送到星球上进行，集中方便，利于同一个服务器的玩家们交流。任务都是一些以“探索”和“讨伐”为主题，这都是由梦幻之星的世界观设定决定的。任务可以选择难度，以适应不同等级的玩家。地图应该都是随机地图，但多走几次可以发现其实地图的走向也是有一定的大趋势的。不定时会出现“紧急任务”，通常就是特殊地图供你练级，个人或者队伍打地图boss。大更新比较频繁，新的地图和boss足够你去玩。 鬼斬：支线随主线走，做完了就没了。地图副本随便进去刷，可以选择“仁”“皇”“神”三种难度，地图固定，怪物固定。 剑灵：支线伴随这主线走，有所谓的“每日任务”，其实就是告诉你埋头刷就是了。等级一高就成了机械重复的劳动。有很重要的副本系统，进去之后就是无脑刷，完全脱离了游戏内的时空设定，让人忍不住吐槽主角你究竟是不是为师门报仇的？现在我玩都已经不看剧情的了。 个人在这里重点说一下，我认为PSO2和鬼斬这样的任务安排比较合情合理，而剑灵给我的感觉就是刷刷刷，无聊。本质同样是刷副本，对比起另外两个副本任务能自然而然地发生，剑灵则是赤裸裸地鼓励玩家去刷。而副本难免会带剧情，剑灵的剧情安排却使得玩家一刷得多就会觉得脱离了游戏。比如我消灭了黑龙寨的那个头目，名字叫做暗黑龙（在这里名字很重要，它是物品的独立标识），第二天我又可以消灭她一遍，嗯？我这算是穿越了吗？打死同一个人两次？如果是打副本更离谱，几分钟就可以打死同一个boss两次了，带来的影响就是重复经历同一段时间的错觉，怎么也分不开。PSO2和鬼斬则不是，怪物都是没有名字的，boss也只是比较强的怪物，这一次打跟下一次可以解释成是不一样的怪。正是其独特的世界观，容易解释任务的重复是内容的重复而非时间的重复。时间的非重复保证了时间流是正常一条的，而反观剑灵则是多条叠加的。如果你看过命运石之门，那么这里的情况就跟凶真一次又一次看着真由里死的情况差不多。最后凶真都说自己麻木了，同样剑灵玩家也麻木了。人会因重复而麻木，重复的内容会越来越不重要，而重复的内容刚好是构筑世界的剧情的话，那么人就越来越脱离这个世界了。 队伍PSO2：随着主线的进行，玩家可以跟某些NPC互动，提升其好感度至一定程度就可以在任务中一起组成队伍，并且同一个地图里面NPC应该是不会出现两个的。更厉害的是不在线好友也是可以作为队友加入的。个人认为这个很赞，可以令玩家更加沉浸在游戏世界中。NPC也会在队伍中扮演好真正队友的角色，会说一些符合情景的对话。每个NPC的性格不同又鲜明，即使玩家是一个人玩也不会寂寞。即使是玩家和玩家之间的交流也是很多的，我在同一个服务器的某个工会qq群上观察到他们经常都组队去玩，在大厅里面交流，整个工会在游戏里面照相留念什么的。 鬼斬：跟PSO2一样，NPC也是可以增加好感度和加入队伍。不知道这是不是日本网游的特点。可惜暂时玩家人数太少，可供交流的选项也几乎没有，不知之后会不会加入相关的功能。 剑灵：只有在刷副本和PK的时候需要队伍，队伍就是一个为降低副本难度而存在的临时组织。人员的流动性非常强，有可能你一进入副本，队友就跑了。很多时候，即使是组成了队伍，大家也是各打各的毫无交流，因为进了副本的人，基本就是来刷物品。 PS：近来在剑灵里面跟着熟人打副本还是挺有意思的，因为我等级太低，打起来比较吃力。 买卖PSO2：需要付费才能开店卖东西。其实没用的都可以用来喂玛古自己消化掉。 鬼斬：貌似暂时只能跟NPC进行买卖，而且很多时候物品都紧缺，基本没有出售的欲望。 剑灵：没啥特别的，玩家间可以互相买卖物品。只是拍卖行是个很蛋疼的设定，通常人们缺东西要用了才会想去买，急着要用的东西还要等实在说不过去。 娱乐性PSO2：高。除了任务打怪还有很多其他可以做的。比如可以自己画画作为自定义表情发出去，在大厅经常可以看到有人发漂亮的图画。之前有一段时间很多人会在大厅里面一起跳舞。最令我印象深刻的是有一次大厅的大屏幕在播miku的视频，非常多的玩家坐在一起看，我想那是我在其他网游里从来没有看见过的、如此生活化的景象。舍得花钱的话也可以付费开通自己的房间，装饰上战利品，邀请好友来房间聊天或者游玩。 鬼斬：暂时不好评价。12号正式运营，19号加入付费物品，系统也不太完善。但是但就剧情和游玩来说还过得去。 剑灵：低。疯狂刷副本和PK占了整个游戏很大的一部分，如此单调和狂热带来的就是累和空虚。也没有其他有趣的东西，实在是可惜。即使有服装系统，在每个人都在奔波刷怪的时候，又有谁留意你身上穿了啥？不过话说回来，剑灵好像是个PVP的游戏，我暂时也没有打算去玩PK，所以也不敢肯定剑灵就不好玩，只能说我不太合适玩这类游戏。 免费游戏的大问题是游戏的娱乐性，如果RMB玩家太过“叼”，影响了游戏的平衡性，那么游戏总是会无聊的；而不能激起玩家付费的欲望，那么游戏又是会经营不下去的。这些游戏基本上都能使用金钱来加快角色或者加强角色，而PSO2在基础的武器购买、经验购买和钱财使用上吸引玩家付费外，还有各种相比起来更加注重“精神消费”的无形消费，免费玩家可以玩得开心，付费玩家也付得高兴。剑灵的话，你不想付费，那么就麻木地刷，刷到麻木吧。 一句话评论PSO2：很好玩，但是玩不了。 鬼斬：可以玩，看以后发展。 剑灵：可以玩，什么时候受不了就不玩。 个人喜爱度：PSO2&gt;鬼斬&gt;剑灵]]></content>
      <categories>
        <category>ACGN</category>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>pso2</tag>
        <tag>鬼斬</tag>
        <tag>剑灵</tag>
        <tag>MMORPG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[segmentfault光棍节闯关攻略]]></title>
    <url>%2Fsegmentfault-1111-quiz-walkthrough%2F</url>
    <content type="text"><![CDATA[第一关/第二关密码都在页面的源代码里面。 第三关页面里面啥都没有，js和css文件也没有，还能藏东西的地方是cookie和localstorage什么的？最后发现http header里面有个the-key-is，好吧…… 第四关第三关的时候就发现get的k=值好像是加密的字符串，32位，猜测应该是md5，不过第三关的值去解密解不出来。这关解出来是4，那么将5加密后复制到地址栏就是啦。 第五关二维码……这么显然，扫出来果然是个坑。又是什么都没有，唯一能用的资源就是那图片了，嘛以前玩过类似的游戏的都知道密码基本就在图片里面，下载回来用notepad差不多在文件末尾就看到了。 第六关f4de502e58723e6252e8856d4dc8fc3b，扔去解密竟然要收钱，靠，直接Google之，找不到什么有用的，百度之，找到了……就是这一串：1573402aa6086d9ce42cfd5991027022，替换后下一关。 第七关按照提示继续Google/百度，啥都没有，于是，直接将那串东西替换到地址栏，过关。 第八关将get方法改成post方法提交……我的做法是直接用chrome改页面代码。 第九关一大坨1和0，八个一组，有的有空缺，二进制嗯。大概看了一下，左边第一位都是0，可能是ascii码。应该能转出字符来，空缺的地方补1（这里比较坑，补0是不行的）。写段js搞出来看看。1var tag= document.getElementsByTagName('pre ')[0].innerText.replace(/_/g, '1 ').split(/\n|\s/g).forEach(function(ele)&#123;tag=tag+String.fromCharCode(parseInt(ele,2))&#125;) 最后tag是一串东西，注意到有+、/还有最后有一个=，哈哈哈，应该是base64了。 上http://www.opinionatedgeek.com/dotnet/tools/base64decode/ 解出一个文件。 接下来应该是判断文件类型了咯？估计也是gzip什么的压缩包，手头没工具，直接丢sublime text里面，搜索了一下文件开头的1f8b 0800，似乎真的是gzip的格式（以后要记住哈）。7zip打开后看见里面有图片，解压出来看知道下一关了。顺便说图片里面的似乎蒼井そら？]]></content>
      <categories>
        <category>技术</category>
        <category>黑客</category>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>11.11</tag>
        <tag>segmentfault</tag>
        <tag>walkthrough</tag>
        <tag>quiz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里智勇大闯关第三季答案]]></title>
    <url>%2Fanswers-for-alibaba-quiz3%2F</url>
    <content type="text"><![CDATA[几个星期之前在 v2ex 上看到有人发帖说有有关前端的网页游戏玩，于是去看了看，发现挺有趣的，打算通关之后就发一下答案。无奈公司网络不行，宿舍没有网络，所以拖到现在。 第一关看控制台提示要调用 xxx，不过追踪了一下调用的函数发现似乎疑似是显示指纹的代码被注释掉。于是看了一下前后的代码，发现有一段判断密码是否相等的代码，显然就不需要折腾了，直接将相等时执行的代码复制到控制台运行就可以了。不过要注意 decode 中的字符串要在页面的 #page 元素中的 data-t 属性的值取出来。 答案（location = 后的字符串视你自己的 data-t 属性值为准）：1window.location=Base64.decode('L3F1aXozL2luZGV4LnBocD90PU9UY3lNMkUwTUdSRGFuVXhNVzlCUVZWR1ZrRlJSMEZSTlZKVlFtZEI=') 第二关意思是要你将那两个灰色的所谓的 “镜子” 通过移位和旋转将红色光线反射过黑色的点。需要用到 CSS3 的属性，先用审查元素找到镜子的 css 属性，直接将我修改过的属性复制进去。 答案： #mirror1 top: 560px; -webkit-transform: rotate(-82deg); #mirror2 top: 430px; -webkit-transform: rotate(172deg); 第三关一看显然就是二维码了。控制台中的一大坨数字其实是二维码中黑点的位置信息。结合 canvas 这个 html5 标签元素，意思就是要我们把位置信息解析出来，操纵 canvas 画出二维码。直接上代码吧，复制到控制台运行就 ok 了。 答案：12345678strr='0,0,12,12 12,0,12,12 24,0,12,12 36,0,12,12 48,0,12,12 60,0,12,12 72,0,12,12 120,0,12,12 132,0,12,12 144,0,12,12 168,0,12,12 180,0,12,12 192,0,12,12 204,0,12,12 216,0,12,12 228,0,12,12 240,0,12,12 0,12,12,12 72,12,12,12 96,12,12,12 108,12,12,12 120,12,12,12 144,12,12,12 168,12,12,12 240,12,12,12 0,24,12,12 24,24,12,12 36,24,12,12 48,24,12,12 72,24,12,12 120,24,12,12 132,24,12,12 144,24,12,12 168,24,12,12 192,24,12,12 204,24,12,12 216,24,12,12 240,24,12,12 0,36,12,12 24,36,12,12 36,36,12,12 48,36,12,12 72,36,12,12 96,36,12,12 108,36,12,12 144,36,12,12 168,36,12,12 192,36,12,12 204,36,12,12 216,36,12,12 240,36,12,12 0,48,12,12 24,48,12,12 36,48,12,12 48,48,12,12 72,48,12,12 108,48,12,12 144,48,12,12 168,48,12,12 192,48,12,12 204,48,12,12 216,48,12,12 240,48,12,12 0,60,12,12 72,60,12,12 96,60,12,12 132,60,12,12 168,60,12,12 240,60,12,12 0,72,12,12 12,72,12,12 24,72,12,12 36,72,12,12 48,72,12,12 60,72,12,12 72,72,12,12 96,72,12,12 120,72,12,12 144,72,12,12 168,72,12,12 180,72,12,12 192,72,12,12 204,72,12,12 216,72,12,12 228,72,12,12 240,72,12,12 108,84,12,12 0,96,12,12 12,96,12,12 24,96,12,12 36,96,12,12 48,96,12,12 72,96,12,12 84,96,12,12 96,96,12,12 132,96,12,12 156,96,12,12 180,96,12,12 204,96,12,12 228,96,12,12 0,108,12,12 24,108,12,12 36,108,12,12 60,108,12,12 120,108,12,12 132,108,12,12 144,108,12,12 156,108,12,12 168,108,12,12 216,108,12,12 240,108,12,12 12,120,12,12 36,120,12,12 48,120,12,12 60,120,12,12 72,120,12,12 84,120,12,12 108,120,12,12 120,120,12,12 144,120,12,12 168,120,12,12 180,120,12,12 228,120,12,12 24,132,12,12 36,132,12,12 60,132,12,12 84,132,12,12 96,132,12,12 108,132,12,12 120,132,12,12 132,132,12,12 144,132,12,12 156,132,12,12 168,132,12,12 204,132,12,12 216,132,12,12 0,144,12,12 12,144,12,12 24,144,12,12 48,144,12,12 72,144,12,12 84,144,12,12 96,144,12,12 108,144,12,12 144,144,12,12 180,144,12,12 204,144,12,12 228,144,12,12 96,156,12,12 108,156,12,12 120,156,12,12 144,156,12,12 180,156,12,12 204,156,12,12 216,156,12,12 228,156,12,12 240,156,12,12 0,168,12,12 12,168,12,12 24,168,12,12 36,168,12,12 48,168,12,12 60,168,12,12 72,168,12,12 96,168,12,12 108,168,12,12 120,168,12,12 132,168,12,12 156,168,12,12 192,168,12,12 204,168,12,12 216,168,12,12 228,168,12,12 0,180,12,12 72,180,12,12 108,180,12,12 180,180,12,12 192,180,12,12 204,180,12,12 216,180,12,12 228,180,12,12 0,192,12,12 24,192,12,12 36,192,12,12 48,192,12,12 72,192,12,12 96,192,12,12 108,192,12,12 120,192,12,12 132,192,12,12 156,192,12,12 192,192,12,12 228,192,12,12 0,204,12,12 24,204,12,12 36,204,12,12 48,204,12,12 72,204,12,12 96,204,12,12 120,204,12,12 132,204,12,12 144,204,12,12 156,204,12,12 168,204,12,12 180,204,12,12 204,204,12,12 216,204,12,12 0,216,12,12 24,216,12,12 36,216,12,12 48,216,12,12 72,216,12,12 96,216,12,12 144,216,12,12 168,216,12,12 180,216,12,12 204,216,12,12 216,216,12,12 0,228,12,12 72,228,12,12 96,228,12,12 132,228,12,12 144,228,12,12 156,228,12,12 168,228,12,12 180,228,12,12 204,228,12,12 216,228,12,12 0,240,12,12 12,240,12,12 24,240,12,12 36,240,12,12 48,240,12,12 60,240,12,12 72,240,12,12 96,240,12,12 108,240,12,12 120,240,12,12 144,240,12,12 228,240,12,12'arr=strr.split(' ');newarr=[];arr.map(function(n)&#123;newarr.push(n.split(','))&#125;);var c=document.getElementById("qr-canvas");var ctx=c.getContext("2d");ctx.fillStyle="#000";newarr.map(function(n)&#123;ctx.fillRect(n[0],n[1],n[2],n[3])&#125;); 第四关看图猜字。比较坑爹的一关，我有一次卡在一幅不太认识的图上了。这个看运气吧。自己多次做刷出来的部分答案列表： grunt-contrib-cssminwww.stackoverflow.comsublime textvwww.github.comwordpressCSS Spritesjadelessunderscore.js 第五关做过其他网页游戏例如 python 的话对这关就不陌生了，就是要你不断地请求 url 而已，控制台也提示提供 jQuery 了。答案：先运行如下代码，第一行代码 “index.php?t=” 和“&amp;room=”中间的那串字符串换成自己地址栏同样位置的字符串，第二行代码的 “24” 也是：12345678910url='index.php?t=OTk1ZDJjYjhyMzRsRldWd2NDVlF4UkRRNWNCRTlW&amp;room=';urlreal=url+'24';strr='';$.get(urlreal, function(data)&#123; var mess=$(data).find('#message').text(); var number=$(data).find('#next-room').text(); strr=strr+mess; urlreal=url+number; console.log(strr);&#125;) 可以看到控制台会输出一些字，接着不断执行如下代码：1234567$.get(urlreal, function(data)&#123; var mess=$(data).find('#message').text(); var number=$(data).find('#next-room').text(); strr=strr+mess; urlreal=url+number; console.log(strr);&#125;) 直到控制台输出的文字没有再变化了，你也就看到了下一关的网址了。为什么我做得这么麻烦是因为懒，不想写判断和循环了，况且手动复制粘贴运行也很快。而且过关时间是有限制的。 最后一关我是直接看了一下 html 和 js 源代码，发现其实要过关就一个跳转而已，于是直接复制网址过的。其实是要提交 script 代码利用 xss 将那个图片移走来过关的。我的答案：将 #page 的 data-p 属性值复制到地址栏替换类似字符串跳转过关。 最后审查元素发现比基尼美女的下身是可以点击的，就是链接到邮箱了，恶趣味。]]></content>
      <categories>
        <category>技术</category>
        <category>黑客</category>
        <category>编程语言</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>walkthrough</tag>
        <tag>quiz</tag>
        <tag>alibaba</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#实现简单的控件动画]]></title>
    <url>%2Fcsharp-simple-animation-component%2F</url>
    <content type="text"><![CDATA[在学习.net编程的时候，做作业经常要求有一个界面。而在做局域网五子棋游戏这个作业的时候，客户端的界面既有登录界面又有用户列表界面，做一个动画来切换就再好不过了。不过翻查了一下MSDN和一些资料，对于C#怎么实现控件的动画效果都没怎么提及，于是参考了一下javascript在网页上实现动画的原理，自己尝试着写了。 动画原理什么的不详细解释了，大家都知道是每一张静态的图片在同等时间间隔内快速地播放，利用视觉停留现象造成一系列视觉印象，从而出现会动的感觉。 而应用到控件的动画上又是如何呢？从最简单的直线匀速移动开始考虑吧。比如，需要将实现一个标签从距离窗体左方30px移动到距离左方300px，在500毫秒内完成，那么，就需要具体计算出每一个时间间隔需要将这个标签移动多少距离，然后在每经过这样的一段时间之后，通过改变控件的距离左边的属性的值来实现控件的微小移动。只要在500毫秒内移动的次数足够的多，那么控件看起来就是在连续地移动。 OK，其中重要的概念有几个。1、将那最小的一小段时间叫做一帧，也就是说整体的移动是通过一帧一帧的小移动叠加出来。2、时间控制。需要一个函数，在每一帧将控件的属性重新设置。这里可以通过使用计时器来实现。3、动画状态。需要将当前动画进行的状态记录下来，以便下一帧到达的时候被更改到下一个帧的状态。 了解了基本原理之后，下面开始编写代码。 首先定义一个存储动画状态的类AnimationStatus，其中：_attribute是控件的属性名称，_initValue是控件动画前的值，_endValue是控件动画后的最终值，_totalValue是整个动画变化的值，_totalFrames是动画所有帧的数量，_currentFrames是代表动画进行到多少帧。将字段封装好，能从外面修改的只有_currentFrames。构造函数没什么好说的，就是初始赋值，注意_totalValue是正数而_currentFrames默认是1。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/// &lt;summary&gt;/// A class that store a set of animation of the control/// &lt;/summary&gt;class AnimationStatus&#123; AnimationType _animationType; string _attribute; int _initValue; int _endValue; int _totalValue; int _totalFrames; int _currentFrames; /// &lt;summary&gt; /// type of the animation, such as liner, Ease... /// &lt;/summary&gt; public AnimationType AnimationType &#123; get &#123; return _animationType; &#125; &#125; /// &lt;summary&gt; /// attribute of control that the contrl will change /// &lt;/summary&gt; public string Attribute &#123; get &#123; return _attribute; &#125; &#125; /// &lt;summary&gt; /// current value of the attribute that is ready to change /// &lt;/summary&gt; public int InitValue &#123; get &#123; return _initValue; &#125; &#125; /// &lt;summary&gt; /// final value of the attribute that is ready to change /// &lt;/summary&gt; public int EndValue &#123; get &#123; return _endValue; &#125; &#125; /// &lt;summary&gt; /// total value that changed /// &lt;/summary&gt; public int TotalValue &#123; get &#123; return _totalValue; &#125; &#125; /// &lt;summary&gt; /// total frames the animation should play, READONLY /// &lt;/summary&gt; public int TotalFrames &#123; get &#123; return _totalFrames; &#125; &#125; /// &lt;summary&gt; /// current frames the animation has played /// &lt;/summary&gt; public int CurrentFrames &#123; get &#123; return _currentFrames; &#125; set &#123; _currentFrames = value; &#125; &#125; // contructor public AnimationStatus(string attribute, int initValue, int endValue, int totalFrames, AnimationType animationType) &#123; this._attribute = attribute; this._animationType = animationType; this._initValue = initValue; this._endValue = endValue; this._totalValue = Math.Abs(this._endValue - this._initValue); this._totalFrames = totalFrames; this._currentFrames = 1; &#125;&#125; 接下来写的是处理每一帧的通用动画函数。12345678910111213141516171819202122232425262728293031323334353637/// &lt;summary&gt;/// common function of moving control/// &lt;/summary&gt;/// &lt;param name="contorl"&gt;the control to be moved&lt;/param&gt;/// &lt;param name="timer"&gt;the timer that control the time of animation&lt;/param&gt;/// &lt;param name="animationStatue"&gt;current statue of animation&lt;/param&gt;private static void Animate( System.Windows.Forms.Control contorl, System.Windows.Forms.Timer timer, AnimationStatus animationStatue)&#123; if (contorl == null || contorl.IsDisposed || animationStatue.CurrentFrames &gt; animationStatue.TotalFrames) &#123; timer.Enabled = false; return; &#125; // perform animation Type _tp = contorl.GetType(); System.Reflection.PropertyInfo _pi = _tp.GetProperty(animationStatue.Attribute); if (_pi != null) &#123; double _progress = (double)animationStatue.CurrentFrames / (double)animationStatue.TotalFrames; int _newValue = animationStatue.InitValue &lt; animationStatue.EndValue ? animationStatue.InitValue + Convert.ToInt32(Math.Round(animationStatue.TotalValue * CalculateValue(animationStatue.AnimationType, _progress))) : animationStatue.InitValue - Convert.ToInt32(Math.Round(animationStatue.TotalValue * CalculateValue(animationStatue.AnimationType, _progress))); _pi.SetValue(contorl, _newValue, null); &#125; else &#123; timer.Enabled = false; return; &#125; animationStatue.CurrentFrames++;&#125; 一开始的判断是防止被操作的控件已经销毁了，并且在动画已经播完了的时候将定时器暂停并返回。从”// perform animation”这个注释之后的代码应用到C#的反射机制。为什么？简单来说就是因为要写出一个通用的动画函数，所以不能在函数里面事先规定要修改的Control对象的属性，但是在实际运行的时候还是需要得到Control对象的具体属性才能修改其中的值，于是使用反射来得到这个对象的某个属性，进而修改这个属性的值。 那么这个“值”如何计算出来呢？首先需要得知动画现在的进度，于是就用当前的动画进度（animationStatue.CurrentFrames）除以总进度（animationStatue.TotalFrames）。然后是利用这个进度（一个百分比）计算出在此进度下属性的值，只要在这里稍微调整计算的方程y=f(x)，就能实现各种各样的效果了，例如最常见的线性和回弹效果。这里的函数CalculateValue就是做这样的事情，它根据传入的AnimationType决定使用什么方程，而进度_progress作为方程的x值，然后返回计算后的y值，这个y值同样是一个百分比，要和动画总变化值（totalValue）相乘，最后加上属性初始值就是当前进度的动画变化值。注意这里设定的方程定义域应该是(0,1]，而值域则最好是从零开始，最后当x=1时，y=1，这样动画效果才不会奇奇怪怪。还有就是属性值的变化不一定是从小到大的所以要做判断决定是加还是减。 CalculateValue函数：1234567891011121314151617181920private static double CalculateValue(AnimationType animationType, double x)&#123; double _y = 1; switch (animationType) &#123; case AnimationType.Liner: _y = x; break; case AnimationType.Ease: _y = Math.Sqrt(x); break; case AnimationType.Ball: _y = Math.Sqrt(1.0 - Math.Pow(x - 1, 2)); break; case AnimationType.Resilience: _y = -10.0 / 6.0 * x * (x - 1.6); break; &#125; return _y;&#125; OK，现在可以写实际动画的函数了。以下是水平移动的例子：1234567891011121314public static void HorizontalMove( System.Windows.Forms.Control control, int endLeft, int lastTime, AnimationType animationType)&#123; System.Windows.Forms.Timer _timer = new System.Windows.Forms.Timer(); _timer.Interval = 15; // CAUSION, this value may not work for you int _frames = lastTime % _timer.Interval &gt; 0 ? lastTime / _timer.Interval + 1 : lastTime / _timer.Interval; AnimationStatus animationStatue = new AnimationStatus("Left", control.Left, endLeft, _frames, animationType); _timer.Tick += delegate &#123; Animate(control, _timer, animationStatue); &#125;; _timer.Enabled = true; _timer.Start();&#125; 做的事情就是初始化定时器、动画状态，然后将通用动画函数和参数作为一个委托绑定到定时器上，打开定时器。 时间控制使用System.Windows.Forms.Timer这个定时器。C#中有三种定时器，这个是唯一一个单线程执行的定时器，也就是说会在UI主线程上执行绑定触发事件，而且它的精度是55ms，也就是说不能很精确地控制动画的进度。最重要的一点，因为是在UI主线程上执行的关系，如果绑定的触发事件执行时间过长，会造成UI假死。但是这里做的控件动画是应用在界面切换或者为控件增加小型动态效果上，动画量少而且持续时间不长，途中的假死是可以无视的。 最后来看一下效果吧。GUI： 按钮事件：1234private void button1_Click(object sender, EventArgs e)&#123; ControlAnimation.HorizontalMove(label1, 300, 500, AnimationType.Resilience);&#125; 动画效果：]]></content>
      <categories>
        <category>编程语言</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
</search>
