<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>exoticknight&#39;s blog</title>
  
  <subtitle>年寿有时而尽，荣乐止乎其身，二者必至之常期，未若文章之无穷</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.e10t.net/"/>
  <updated>2023-03-04T09:29:58.669Z</updated>
  <id>https://blog.e10t.net/</id>
  
  <author>
    <name>exoticknight</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018 年的日本旅游笔记</title>
    <link href="https://blog.e10t.net/japan-travel-notes-in-2018/"/>
    <id>https://blog.e10t.net/japan-travel-notes-in-2018/</id>
    <published>2023-03-04T04:15:11.000Z</published>
    <updated>2023-03-04T09:29:58.669Z</updated>
    
    <content type="html"><![CDATA[<p>整理手机里的笔记的时候发现很久以前的笔记，突然就有点怅然。也忘记写完没有了，继续补充了一点发了罢。现在好多人都去过日本，参考作用不大了。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>靠某省份的户籍很容易办到签证，好像是小程序里找的熊猫签证，买个套餐就行。如果条件不太好可以尝试办信用卡金卡，总之看签证套餐哪个容易办哪个。本来特定办了张招商金卡想加快办理流程，但是后来发现用自己户籍更快，就用要求户籍的套餐了。</p><p>当时还在开水团工作，同行的是开水团的同事朋友。有个相互照应也是挺好的。</p><p>我们用 Google Map 事先 mark 了感兴趣的景点和游览路线，见<a href="https://www.google.com.hk/maps/@35.6607426,139.9349532,11z/data=!3m1!4b1!4m2!6m1!1s1hiWxh9uaFd6BFQE3cSSvcrXPx7MLU87o?hl=en" target="_blank" rel="noopener">地图</a>。虽然最后有一些景点最后并没有去，但整个行程几乎都跟着计划来，所以事先规划好非常有用。</p><h1 id="住"><a href="#住" class="headerlink" title="住"></a>住</h1><p>从酒店来说，房间比较小，但什么都全，比较舒适。旅行只需要带衣服就行。刚到日本是住在浅草寺附近的一家酒店，后来是住新宿。</p><p>最好找对中国人友好的酒店，新宿那一家前台有个中年人会中文，沟通简单不少。</p><p>住的是大床房，但是同行的人不愿意一起睡，我也嫌床太软就睡硬一点的沙发了。</p><p>酒店的厕所让我比较深印象，不到两三平就整合了马桶浴缸洗手盆。马桶是比较电子化的，可以按钮用水冲菊花，不过我终究是没有尝试。</p><h1 id="建筑"><a href="#建筑" class="headerlink" title="建筑"></a>建筑</h1><p>一般建筑很有特色。常见很窄但比较高的独栋。然后通常一层一个店，于是招牌也是很窄很高地贴在墙边。</p><p>看不到残破的建筑，听说是因为规定要定期交修缮费的缘故。</p><h1 id="吃"><a href="#吃" class="headerlink" title="吃"></a>吃</h1><p>为省钱没怎么吃贵的东西。大部分时候是便利店买几个饭团，或者便当。</p><p>在歌舞伎町出来后，去了对面的一家拉面店，吃起来也就那样吧。对比中国的拉面，就是汤底味道好，面却是不及中国的。</p><p>吉野家好吃又便宜。便利店的便当便宜也不错。</p><p>按本人口味来看，吃的东西都比北京好，而且似乎对比本地的收入，便宜。</p><p>当然也不是都便宜。旅途后面有一天在<a href="https://zh.wikipedia.org/zh-hk/%E5%BE%A1%E5%8F%B0%E5%A0%B4" target="_blank" rel="noopener">台场</a>附近的时候，我们想过去吃帝王蟹，终究还是觉得太贵而作罢。</p><h1 id="便利店"><a href="#便利店" class="headerlink" title="便利店"></a>便利店</h1><p>全家/711/罗森周围都是，走十五分钟能遇到四五家…里面有常用药，喝的，吃的，日用品，漫画，八卦杂志，成人杂志…可以说靠便利店就能活下去了（感觉不少人的确是这样）。</p><p>店员服务态度非常非常好。第一次付费的时候，我用了特地申请的 visa，但怎么都刷不过，最后换了银联金卡才行。于是我就堵在了收银台前，但店员好像还很抱歉一样。</p><h1 id="自动贩卖机"><a href="#自动贩卖机" class="headerlink" title="自动贩卖机"></a>自动贩卖机</h1><p>基本都是卖喝的，数量比便利店还多。一瓶喝的也就一百多日元吧。咖啡，汽水，有味道的饮料，都有。</p><h1 id="水"><a href="#水" class="headerlink" title="水"></a>水</h1><p>日本的自来水是能直接喝（日语：水道水），这没什么奇怪的，中国的自来水在出厂的时候也似乎是可以喝的，只是输送的时候经过的管道不干净。所以日本这边是没有喝热水的习惯的，甚至店里提供的就是冰水。热水似乎就用来洗澡和泡面。</p><p>酒店里毕竟还是有煮水壶的，但我们也懒得用，在附近小超市买了不少打折的大瓶装モモ水——我俩叫它毛毛水——其实就是桃汁——直接当水喝了。</p><p>后来在一个公园里发现了一个饮水器，样子像一个洗手盘，立在远离树木的泥土地上，因此上方没有什么遮挡。出水的地方就是倒转的水龙头，水流向上喷，凑过嘴去喝即可。</p><h1 id="人"><a href="#人" class="headerlink" title="人"></a>人</h1><p>年轻人基本不怎么会英文。老人反而会英文，比如秋叶原扭蛋会馆的老店长，新宿便利店的老店员。这就是所谓的昭和男儿，平成废物？</p><p>东京是个国际化城市，因此很多国外游客，尤其是欧美的，在街上一眼就能认出。</p><h1 id="街道"><a href="#街道" class="headerlink" title="街道"></a>街道</h1><p>左行，但是习惯就好。但是上下楼梯有时右行有时左行，很奇怪。</p><p>一般很宽，不怎么堵车，车都很有礼貌会优先礼让行人，比广州的车还礼貌。什么你问北京？没被撞死就烧香吧。</p><p>路面很干净，是真的。至少在旅游渠道的地方，无论早上晚上都基本看不到垃圾。特别厉害的是小街巷里也不太可能见到垃圾。但是街上垃圾桶很少，随身垃圾就只能要不到便利店外面扔要不拿回酒店房间扔。</p><h1 id="空气"><a href="#空气" class="headerlink" title="空气"></a>空气</h1><p>好得离谱。首都最繁华的几个地方，银座新宿池袋涉谷尽管人多车多，但是空气质量好得根本无需检测，在北京经常上百的指数在这每天都是十。每天都是极其蓝色的天空和干净的白云。天空的颜色在照片里是不需要PS的。</p><p>虽然我没什么感觉，当时同行人某天说鼻子感觉很不舒服，可能是花粉症。</p><h1 id="地铁-铁路"><a href="#地铁-铁路" class="headerlink" title="地铁/铁路"></a>地铁/铁路</h1><p>线路很多，去主要景点基本都有直达，不用担心交通问题（不像北京只有上下左右方向，又远又累）。但是搭乘比较复杂，同一个月台可以有三个方向的车，或者六种停靠方式的列车…最后一天我们坐错了三次车…</p><p>座椅全部是软座，真的非常舒服。</p><h1 id="公园"><a href="#公园" class="headerlink" title="公园"></a>公园</h1><p>城市绿化很好。这次去了日比谷公园，新宿御苑公园，上野恩赐公园，代代木公园这四个。都是很大很漂亮的公园，很多古树，高树（两三层楼），没有任何垃圾，人不会特别多，吹着风舒服到感觉可以待一天。</p><p>旅游的时候是刚好遇到了綠之日（みどりの日，每年5.4），收费的公园免费了，挺爽。</p><h1 id="购物"><a href="#购物" class="headerlink" title="购物"></a>购物</h1><p>普通人最好去银座新宿/池袋/涉谷/表参道，玩可以去迪士尼或者台场。从新宿出发，到这几个地方都只需半小时左右，不像北京那样去一个地方出行就占了一半时间般坑爹。优衣库总店在银座，有十层。</p><p>如果你喜欢ACG，在池袋和秋叶原，你想到没想到的都有，会迅速流失大量钱财，请注意。</p><p>药妆店很多地方都有，里面经常有中国人扫货代购。</p><h1 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h1><p>西瓜卡很有用，可以对付地下铁（蓝色m字LOGO）/JR（绿色LOGO）/部分列车，看见IC卡就能刷，出门就靠它了。还能用在一些贩卖机上。</p><p>信用卡就不用说了，也请带多一点现金，至少一万日元。因为各类门票，非全球连锁的当地特色饭馆，西瓜卡充值，都需要现金。</p><p>银联用在免税店较多，实际通用程度不高。微信和支付宝也是差不多。</p><blockquote><p>2023 更新，看现在日本的视频，支付宝微信好像发展得还可以，日本商家也期望中国游客爆买，估计现在这两种支付手段也可以轻松旅游吧。</p></blockquote><p>也准备好会收到很多硬币，因为纸币最低面额是1000，500及以下都是硬币。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理手机里的笔记的时候发现很久以前的笔记，突然就有点怅然。也忘记写完没有了，继续补充了一点发了罢。现在好多人都去过日本，参考作用不大了。&lt;/p&gt;
&lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/
      
    
    </summary>
    
      <category term="生活" scheme="https://blog.e10t.net/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="杂" scheme="https://blog.e10t.net/categories/%E7%94%9F%E6%B4%BB/%E6%9D%82/"/>
    
    
      <category term="life" scheme="https://blog.e10t.net/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>5 分钟速成古埃及神明</title>
    <link href="https://blog.e10t.net/learn-ancient-egyptian-gods-in-5-minutes/"/>
    <id>https://blog.e10t.net/learn-ancient-egyptian-gods-in-5-minutes/</id>
    <published>2019-05-21T14:18:29.025Z</published>
    <updated>2019-05-24T01:58:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>古埃及的宗教是多神教，他们认为自然现象、客观事物甚至动物，都存在神明。在新王国时期法老阿肯那顿将阿顿作为唯一神，古埃及曾短暂地存在一神教时期。这部分详细可以阅读<a href="/learn-ancient-egyptian-history-in-30-minutes">30 分钟速成古埃及历史</a>。</p><p>三千年的存在时间和政权的多次更迭造成古埃及神明种类繁多，系统复杂，甚至可能互相矛盾，但总的来说有三个神话系统。</p><h2 id="九柱神"><a href="#九柱神" class="headerlink" title="九柱神"></a>九柱神</h2><p>九柱神是古埃及宗教中一般都采用的神话系统。</p><h3 id="拉（Ra）"><a href="#拉（Ra）" class="headerlink" title="拉（Ra）"></a>拉（Ra）</h3><p>太阳神，埃及神话中的最高神。生舒和泰芙努特。九柱神之一。</p><p><img alt="拉 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0d/Re-Horakhty.svg/218px-Re-Horakhty.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/0/0d/Re-Horakhty.svg"></p><h3 id="舒（Shu）"><a href="#舒（Shu）" class="headerlink" title="舒（Shu）"></a>舒（Shu）</h3><p>风神，拉的儿子，与泰芙努特生盖布和努特。九柱神之一。</p><p><img alt="舒 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e1/Shu_with_feather.svg/224px-Shu_with_feather.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/e/e1/Shu_with_feather.svg"></p><h3 id="泰芙努特（Tefnut）"><a href="#泰芙努特（Tefnut）" class="headerlink" title="泰芙努特（Tefnut）"></a>泰芙努特（Tefnut）</h3><p>雨神，拉的女儿，舒的妻子。九柱神之一。</p><p><img alt="泰芙努特 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8b/Tefnut.png/273px-Tefnut.png" data-original="https://upload.wikimedia.org/wikipedia/commons/8/8b/Tefnut.png"></p><h3 id="盖布（Geb）"><a href="#盖布（Geb）" class="headerlink" title="盖布（Geb）"></a>盖布（Geb）</h3><p>大地之神，与努特生欧西里斯、赛特、艾西斯、奈芙蒂斯。九柱神之一。</p><p><img alt="盖布 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/53/Geb.svg/219px-Geb.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/5/53/Geb.svg"></p><h3 id="努特（Nut）"><a href="#努特（Nut）" class="headerlink" title="努特（Nut）"></a>努特（Nut）</h3><p>天神，盖布的妻子。九柱神之一。</p><p><img alt="努特 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/Nut.svg/236px-Nut.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/d/df/Nut.svg"></p><h3 id="奥西里斯（Osiris）"><a href="#奥西里斯（Osiris）" class="headerlink" title="奥西里斯（Osiris）"></a>奥西里斯（Osiris）</h3><p>冥王，也是农业之神。九柱神之一。</p><p><img alt="奥西里斯 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cc/Standing_Osiris_edit1.svg/221px-Standing_Osiris_edit1.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/c/cc/Standing_Osiris_edit1.svg"></p><h3 id="伊西斯（Isis）"><a href="#伊西斯（Isis）" class="headerlink" title="伊西斯（Isis）"></a>伊西斯（Isis）</h3><p>死者的守护神，也是生育之神，奥西里斯的妻子。九柱神之一。</p><p><img alt="伊西斯 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Isis.svg/218px-Isis.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/e/ec/Isis.svg"></p><h3 id="赛特（Seth）"><a href="#赛特（Seth）" class="headerlink" title="赛特（Seth）"></a>赛特（Seth）</h3><p>干旱之神，风暴之神。有时也被认为是战神。九柱神之一。</p><p><img alt="赛特 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7a/Set.svg/231px-Set.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/7/7a/Set.svg"></p><h3 id="奈芙蒂斯（Nephthys）"><a href="#奈芙蒂斯（Nephthys）" class="headerlink" title="奈芙蒂斯（Nephthys）"></a>奈芙蒂斯（Nephthys）</h3><p>死者的守护神，赛特的妻子。九柱神之一。</p><p><img alt="奈芙蒂斯 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a7/Nepthys.svg/218px-Nepthys.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/a/a7/Nepthys.svg"></p><h3 id="阿努比斯（Anubis）"><a href="#阿努比斯（Anubis）" class="headerlink" title="阿努比斯（Anubis）"></a>阿努比斯（Anubis）</h3><p>赛特和奈芙蒂斯，负责制作木乃伊和评判死去的人该不该永生。</p><p><img alt="阿努比斯 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Anubis_standing.svg/224px-Anubis_standing.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/6/6d/Anubis_standing.svg"></p><h3 id="荷鲁斯（Horus）"><a href="#荷鲁斯（Horus）" class="headerlink" title="荷鲁斯（Horus）"></a>荷鲁斯（Horus）</h3><p>奥西里斯和伊西斯的儿子，一般是代表法老的权威。</p><p><img alt="荷鲁斯 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c2/Horus_standing.svg/210px-Horus_standing.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/c/c2/Horus_standing.svg"></p><h3 id="哈索尔（Hathor）"><a href="#哈索尔（Hathor）" class="headerlink" title="哈索尔（Hathor）"></a>哈索尔（Hathor）</h3><p>爱神、美神，荷鲁斯妻子。</p><p><img alt="哈索尔 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/47/Hathor.svg/203px-Hathor.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/4/47/Hathor.svg"></p><h3 id="荷鲁斯的四个儿子"><a href="#荷鲁斯的四个儿子" class="headerlink" title="荷鲁斯的四个儿子"></a>荷鲁斯的四个儿子</h3><p>为木乃伊保存四个内脏。伊姆塞特保护肝脏，哈庇保护肺，杜阿木忒弗保护胃，克贝克塞努弗保护肠。</p><p><img alt="荷鲁斯的四个儿子 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Four_sons_of_Horus.svg/535px-Four_sons_of_Horus.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/2/29/Four_sons_of_Horus.svg"></p><h3 id="神明之间的关系"><a href="#神明之间的关系" class="headerlink" title="神明之间的关系"></a>神明之间的关系</h3><p>拉是众神之始，生出舒和泰芙努特。</p><p>舒与泰芙努特生盖布和努特。</p><p>盖布在下为地，努特在上为天，舒在中间撑着。</p><p><img alt="舒，盖布和努特 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0b/Geb%2C_Nut%2C_Shu.jpg/640px-Geb%2C_Nut%2C_Shu.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/0/0b/Geb%2C_Nut%2C_Shu.jpg"></p><p>盖布与努特生奥西里斯、赛特、伊西斯、奈芙蒂斯。奥西里斯和伊西斯成夫妻，赛特和奈芙蒂斯成夫妻。</p><p>赛特嫉妒哥哥奥西里斯，举办了一个宴会，做一个刚好哥哥能躺进去的棺材，让别人躺进去试试。奥西里斯躺进去就封上扔进尼罗河溺死他。</p><p>伊西斯和奈芙蒂斯找回尸体复活，但赛特又一次杀死了奥西里斯并分尸十四块，藏在世界各地。伊西斯找了很久，除了下体凑足了尸体，负责做木乃伊的阿努比斯帮助她复活奥西里斯。伊西斯之后生下荷鲁斯，然后奥西里斯成了冥界之主。有些文献说是因为他的下体被鱼吃了，伊西斯使用木头代替导致复活不完全。</p><p>奥西里斯的经典造型是绿脸，双手握权杖交叉胸前，经常出现在法老为自己建造的陵墓门口。</p><p>荷鲁斯被秘密抚养长大之后，向赛特复仇并打败了他，过程中扯下了他的一颗睾丸，自己则失去一只眼睛。那只眼睛就被视为著名的「荷鲁斯之眼」。</p><p><img alt="荷鲁斯之眼 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/32/Eye_of_Horus_Right.svg/624px-Eye_of_Horus_Right.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/thumb/3/32/Eye_of_Horus_Right.svg/624px-Eye_of_Horus_Right.svg.png"></p><h2 id="八元神"><a href="#八元神" class="headerlink" title="八元神"></a>八元神</h2><p>八元神其实是四对分雌雄的神。关于八元神的故事并不多。</p><p>代表自然水，纳乌涅特（Naunet）和 努恩（Nu）、<br>代表空气或隐蔽或虚无，阿玛乌涅特（Amaunet）和 阿蒙（Amun）、<br>代表黑暗，卡乌凯特（Kauket）和 库克（Kuk）、<br>代表永恒或无限空间，哈乌赫特（Hauhet）和 胡（Huh）。</p><p>在这个体系中，拉是在四对神的相互作用下诞生的。</p><h2 id="底比斯诸神"><a href="#底比斯诸神" class="headerlink" title="底比斯诸神"></a>底比斯诸神</h2><p>底比斯经常作为古埃及的首都，其当地的神话和神明在古埃及宗教上占有很重的地位，甚至排挤其他神明的地位。</p><h3 id="阿蒙（Amun）"><a href="#阿蒙（Amun）" class="headerlink" title="阿蒙（Amun）"></a>阿蒙（Amun）</h3><p>本身只是地方神祇，但是十八王朝开始随着王室的崇拜和古埃及版图扩张而逐渐成为到了主神的地步。</p><p>有时又会和拉结合，成为众神之王。</p><p><img alt="阿蒙 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/57/Amun.svg/181px-Amun.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/5/57/Amun.svg"></p><h3 id="姆特（Mut）"><a href="#姆特（Mut）" class="headerlink" title="姆特（Mut）"></a>姆特（Mut）</h3><p>阿蒙之妻，生下孔斯，一起成为底比斯三柱神。</p><p><img alt="姆特 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Mut.svg/214px-Mut.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/9/9d/Mut.svg"></p><h3 id="孔斯（Khonsu）"><a href="#孔斯（Khonsu）" class="headerlink" title="孔斯（Khonsu）"></a>孔斯（Khonsu）</h3><p>阿蒙和姆特之子，一代月神。</p><p><img alt="孔斯 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bf/Khonsu_as_falcon.svg/218px-Khonsu_as_falcon.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/b/bf/Khonsu_as_falcon.svg"></p><h3 id="麦里特塞盖尔（Meretseger）"><a href="#麦里特塞盖尔（Meretseger）" class="headerlink" title="麦里特塞盖尔（Meretseger）"></a>麦里特塞盖尔（Meretseger）</h3><p>不是太重要的神，负责守卫帝王谷。</p><p><img alt="麦里特塞盖尔 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/04/Meretseger.svg/236px-Meretseger.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/0/04/Meretseger.svg"></p><h3 id="托特（Thoth）"><a href="#托特（Thoth）" class="headerlink" title="托特（Thoth）"></a>托特（Thoth）</h3><p>智慧之神。二代月神同时也是数学、医药之神，负责守护文艺和书记的工作。相传他是古埃及文字的发明者。</p><p><img alt="托特 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Thoth.svg/249px-Thoth.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/c/c3/Thoth.svg"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://en.wikipedia.org/wiki/Egyptian_mythology" target="_blank" rel="noopener">Egyptian mythology</a><br><a href="https://en.wikipedia.org/wiki/Ennead" target="_blank" rel="noopener">Ennead</a><br><a href="https://en.wikipedia.org/wiki/Ogdoad_(Egyptian" target="_blank" rel="noopener">Ogdoad_(Egyptian)</a>)<br><a href="埃及神话">埃及神话</a><br><a href="https://zh.wikipedia.org/wiki/九柱神" target="_blank" rel="noopener">九柱神</a><br><a href="https://zh.wikipedia.org/wiki/八元神" target="_blank" rel="noopener">八元神</a><br><a href="http://travelm.tw/egypt-god" target="_blank" rel="noopener">埃及旅遊｜一起認識複雜的埃及神祇吧！九柱神與重要神祇們</a><br><a href="https://myancientegyptpractice.wordpress.com/2015/07/18/神話簡介" target="_blank" rel="noopener">古埃及主要神話體系簡介</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;古埃及的宗教是多神教，他们认为自然现象、客观事物甚至动物，都存在神明。在新王国时期法老阿肯那顿将阿顿作为唯一神，古埃及曾短暂地存在一神教时期。这部分详细可以阅读&lt;a href=&quot;/learn-ancient-egyptian-history-in-30-minutes&quot;&gt;3
      
    
    </summary>
    
      <category term="知识" scheme="https://blog.e10t.net/categories/%E7%9F%A5%E8%AF%86/"/>
    
      <category term="古埃及" scheme="https://blog.e10t.net/categories/%E7%9F%A5%E8%AF%86/%E5%8F%A4%E5%9F%83%E5%8F%8A/"/>
    
    
      <category term="ancient-egypt" scheme="https://blog.e10t.net/tags/ancient-egypt/"/>
    
      <category term="god" scheme="https://blog.e10t.net/tags/god/"/>
    
  </entry>
  
  <entry>
    <title>30 分钟速成古埃及历史</title>
    <link href="https://blog.e10t.net/learn-ancient-egyptian-history-in-30-minutes/"/>
    <id>https://blog.e10t.net/learn-ancient-egyptian-history-in-30-minutes/</id>
    <published>2019-05-15T12:46:26.449Z</published>
    <updated>2019-06-01T06:03:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天在 bilibili 上看了一个 up 主的埃及旅游系列 <a href="https://www.bilibili.com/medialist/play/ml454556918" target="_blank" rel="noopener">vlog</a>，了解了一些关于古埃及历史的知识，再通过维基什么学习，写下本文以做笔记。</p><p>本文基本来源中英文维基，英文为主中文为辅，精简了大量不太重要的细节，比较适合快速了解和学习古埃及历史。如果对内容有什么疑问或者质疑，请务必留下评论或者联系我做讨论。</p><div class="note info">            <p>PDF 版见文章末尾。</p>          </div><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>时间上只会覆盖到中世纪之前，个人认为古埃及在阿拉伯人入侵之后就算是玩完了，所以之后的时期不做记录。</p><p>首先，整个古埃及基本就是沿着尼罗河建立的。尼罗河的走向是自南向北，古埃及也经常因为统治的原因，一段时期分成上埃及和下埃及，一段时期则是统一，正所谓分久必合，合久必分。上埃及是在南边即上游，而下埃及则是在北边即下游。</p><p>埃及学者一般根据托勒密王朝早期古埃及祭祀曼涅托的《埃及史》将古埃及历史分成八到九个时期，三十一个王朝（一个王朝不一定只有一位法老），而古埃及人则似乎是不划分历史时期的。另外考古出来的历史也各国不一，这里以维基为准。</p><p>这几个时期分别是前王朝时期、早王朝时期、古王国时期、第一中间期、中王国时期、第二中间期、新王国时期、第三中间期和古埃及后期。实际并不需要将所有的时期都记得一清二楚，只需要记得一些时期和王朝比较有名的事件和法老即可。</p><p>另外古埃及到了第三中间期之后的后期，已经无力回天，被外族来回入侵，再之后又来了马其顿和罗马，最后被阿拉伯完全控制后到现在基本就已经是一个穆斯林国家了。</p><p>古埃及年表在时间上的认定也不一，相差会有几十年，不过其开始一般都在 BC（before century，公元前）3100 左右。</p><div class="note info">            <p>点击图片查看清晰大图</p>          </div><p><img alt="古埃及地图，显示主要城市和地图 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/17/Ancient_Egypt_map-en.svg/293px-Ancient_Egypt_map-en.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/1/17/Ancient_Egypt_map-en.svg"></p><h2 id="前王朝时期（BC3100-之前）"><a href="#前王朝时期（BC3100-之前）" class="headerlink" title="前王朝时期（BC3100 之前）"></a>前王朝时期（BC3100 之前）</h2><p>经历了旧石器时代和新石器时代，大概 BC3600 年开始，尼罗河沿岸出现几十个「诺姆」，相互各自斗争。</p><blockquote><p>诺姆：nome，源自希腊语 Νομός，意为 “行政区”；埃及语：Gau，中译「州」。</p></blockquote><h2 id="早王朝时期（Early-dynastic-period-BC3100-BC2686）"><a href="#早王朝时期（Early-dynastic-period-BC3100-BC2686）" class="headerlink" title="早王朝时期（Early dynastic period, BC3100 - BC2686）"></a>早王朝时期（Early dynastic period, BC3100 - BC2686）</h2><h3 id="第一王朝建立者，美尼斯"><a href="#第一王朝建立者，美尼斯" class="headerlink" title="第一王朝建立者，美尼斯"></a>第一王朝建立者，美尼斯</h3><p>传说中美尼斯（Menes）统一了上下埃及开创古埃及王朝。但从考古证据上则很难支持有这么一个人，反而认为是纳尔迈（Narmer）才是统一埃及第一人，或者说两者是同一个。</p><p>包含一至二王朝，两个王朝，2 / 31。</p><h2 id="古王国时期（Old-Kingdom-BC2686-BC2181）"><a href="#古王国时期（Old-Kingdom-BC2686-BC2181）" class="headerlink" title="古王国时期（Old Kingdom, BC2686 - BC2181）"></a>古王国时期（Old Kingdom, BC2686 - BC2181）</h2><h3 id="第一个建造金字塔，左塞王"><a href="#第一个建造金字塔，左塞王" class="headerlink" title="第一个建造金字塔，左塞王"></a>第一个建造金字塔，左塞王</h3><p>现在看到的著名金字塔基本就在这个时期被建造。</p><p>此时期第一个法老（pharaoh）左塞王（King Djoser）开始建造阶梯金字塔（最常见最有名那种），位置在萨卡拉（开罗以南约 30 公里）。</p><p>阶梯金字塔据说是是伊姆霍特普（Imhotep）设计的。</p><blockquote class="blockquote-center"><p>伊姆霍特普，出身平民，但因智慧过人，学识渊博，受到法老的破格重用。他在整个法老时代受到崇拜，死后被尊为神，名号被刻在法老左塞雕像的基座上。…… 古埃及医学的奠基人…… 被誉为历史上第一位留下姓名的建筑师与医师，被奉为医学之神<br><em>维基百科</em></p></blockquote><p>甚至有伊姆霍特普博物馆，见 <a href="https://en.wikipedia.org/wiki/Imhotep_Museum" target="_blank" rel="noopener">维基</a>，<a href="https://egyptsites.wordpress.com/2009/02/21/imhotep-museum/" target="_blank" rel="noopener">egyptsites 博客</a>。</p><p><img alt="左塞尔金字塔 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/60/Saqqara_BW_5.jpg/640px-Saqqara_BW_5.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/6/60/Saqqara_BW_5.jpg"></p><h3 id="最大的金字塔，胡夫金字塔"><a href="#最大的金字塔，胡夫金字塔" class="headerlink" title="最大的金字塔，胡夫金字塔"></a>最大的金字塔，胡夫金字塔</h3><p>胡夫是第四王朝的第二位法老，是首位在吉萨建造金字塔的法老。今天去埃及旅游看的三座大金字塔就在吉萨，其中最大的就是胡夫下令修建。</p><p>胡夫金字塔塔高大概 146.5 米，现为大概 137 米，边长接近 230 米，由 230 万块巨石搭建而成，最重的可达 50 吨，最小的也有 1.5 吨。</p><p>胡夫金字塔是古代世界七大奇迹中最为古老和唯一尚存的建筑物。</p><p>有一个入口，但是现在被封禁，只使用某位哈里发在 CE820 开凿的盗墓通道作为入口。</p><blockquote><p>尽管建造了最大的金字塔，但胡夫本人的雕像却是考古发掘中所有法老雕像中最小的。</p></blockquote><p><img alt="胡夫金字塔，又名吉萨大金字塔 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d1/Gizeh_Cheops_BW_1.jpg/640px-Gizeh_Cheops_BW_1.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/d/d1/Gizeh_Cheops_BW_1.jpg"></p><h3 id="第二大金字塔，卡夫拉金字塔"><a href="#第二大金字塔，卡夫拉金字塔" class="headerlink" title="第二大金字塔，卡夫拉金字塔"></a>第二大金字塔，卡夫拉金字塔</h3><p>卡夫拉是胡夫的孙子。尽管看起来卡夫拉金字塔比胡夫金字塔小一点，但是卡夫拉金字塔底座更高了 10 米，塔周边也更多附属设施。</p><p>狮身人面像斯芬克斯就属于附近的建筑，但并不是问路人问题杀人那只。</p><p><img alt="卡夫拉金字塔 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Pyramid_of_Khufu.jpg/640px-Pyramid_of_Khufu.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/a/af/Pyramid_of_Khufu.jpg"></p><p><img alt="狮身人面像斯芬克斯 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Cairo%2C_Gizeh%2C_Sphinx_and_Pyramid_of_Khufu%2C_Egypt%2C_Oct_2004.jpg/640px-Cairo%2C_Gizeh%2C_Sphinx_and_Pyramid_of_Khufu%2C_Egypt%2C_Oct_2004.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/a/a5/Cairo%2C_Gizeh%2C_Sphinx_and_Pyramid_of_Khufu%2C_Egypt%2C_Oct_2004.jpg"></p><h3 id="孟卡拉金字塔"><a href="#孟卡拉金字塔" class="headerlink" title="孟卡拉金字塔"></a>孟卡拉金字塔</h3><p>孟卡拉是第四王朝时期的第 16 位法老，孟卡拉金字塔远小于前两座金字塔，它的高度只有大约 65 米，总体积大约只有卡夫拉金字塔 1/10。</p><p>萨拉丁的儿子奥斯曼曾试图拆除孟卡拉金字塔，最后太过困难而作罢，给金字塔北面留下很大的垂直裂缝。</p><p><img alt="孟卡拉金字塔 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ab/Menkaures_Pyramid_Giza_Egypt.jpg/640px-Menkaures_Pyramid_Giza_Egypt.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/a/ab/Menkaures_Pyramid_Giza_Egypt.jpg"></p><p><img alt="金字塔俯视图，从右上到左下分别是胡夫金字塔，卡夫拉金字塔，孟卡拉金字塔，狮身人面像在右边与卡夫拉金字塔有一条堤道相连。via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e7/Giza_pyramid_complex_%28map%29.svg/614px-Giza_pyramid_complex_%28map%29.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/e/e7/Giza_pyramid_complex_%28map%29.svg"></p><p>包含三至六王朝，四个王朝，6 / 31。</p><h2 id="第一中间期（First-Intermediate-Period-BC2181-BC2055）"><a href="#第一中间期（First-Intermediate-Period-BC2181-BC2055）" class="headerlink" title="第一中间期（First Intermediate Period, BC2181 - BC2055）"></a>第一中间期（First Intermediate Period, BC2181 - BC2055）</h2><p>古王国时期后期出现严重干旱，国力下降，封建制度也削弱了中央权利，出现第一个黑暗时期，极其混乱的一个时期。这个时期法老权力被极度削弱，地方官员权利变大，在自己领地几乎就成了法老。</p><p>七八王朝极度混乱，史书记录不清。</p><h3 id="曼图霍特普二世（Mentuhotep-II）重新统一"><a href="#曼图霍特普二世（Mentuhotep-II）重新统一" class="headerlink" title="曼图霍特普二世（Mentuhotep II）重新统一"></a>曼图霍特普二世（Mentuhotep II）重新统一</h3><p>古埃及也分成了上下埃及，下埃及经历九十两个王朝，上埃及则是十和十一王朝。最终上埃及由曼图霍特普二世（Mentuhotep II）向北进攻击败下埃及统治者再次统一古埃及，并继续主持十一王朝，进入中王国时期。</p><p>经历大概第七王朝到第十王朝，四个王朝，10 / 31。</p><h2 id="中王国时期（Middle-Kingdom-BC2030-BC1650）"><a href="#中王国时期（Middle-Kingdom-BC2030-BC1650）" class="headerlink" title="中王国时期（Middle Kingdom, BC2030 - BC1650）"></a>中王国时期（Middle Kingdom, BC2030 - BC1650）</h2><p>十一王朝再次统一之后，开始重新收复失地，包括南边曾经在古王国和中间时期失落给努比亚的土地。</p><blockquote><p>努比亚相当于今天埃及和苏丹交界位置。</p></blockquote><p>十二王朝迁都底比斯（今卢克索）。</p><h3 id="塞索斯特利斯三世（Sesostris-III）扩张到努比亚"><a href="#塞索斯特利斯三世（Sesostris-III）扩张到努比亚" class="headerlink" title="塞索斯特利斯三世（Sesostris III）扩张到努比亚"></a>塞索斯特利斯三世（Sesostris III）扩张到努比亚</h3><p>塞索斯特利斯三世（Sesostris III）是十二王朝法老，善战，向努比亚扩张，然后还建造了很多堡垒，被认为是这个王朝最强大的法老。</p><p>之后他的儿子阿蒙涅姆赫特三世（Amenemhat III）的统治时期被认为是中王国时期经济最好的时期。不过他从西亚邀请了希克索人（Hyksos）到尼罗河下游三角洲定居，也给后面十三十四王朝的结束埋下了隐患。其实十二王朝末期尼罗河洪水减少也为国家带来打击。</p><h3 id="第一位可考的女法老，塞贝克涅弗鲁（Sobekneferu）"><a href="#第一位可考的女法老，塞贝克涅弗鲁（Sobekneferu）" class="headerlink" title="第一位可考的女法老，塞贝克涅弗鲁（Sobekneferu）"></a>第一位可考的女法老，塞贝克涅弗鲁（Sobekneferu）</h3><p>阿蒙涅姆赫特四世（Amenemhat IV）去世后，其子年幼，于是其姐妹塞贝克涅弗鲁（Sobekneferu）成为了历史考证上第一位女法老。她在位三年后去世，政权持续衰弱，是十二王朝最后的法老。</p><p>奥西里斯在这个时期成为了最重要的神。</p><p>经历十一王朝到十三王朝，三个王朝，13 / 31。</p><h2 id="第二中间期（Second-Intermediate-Period-BC1650-BC1550）"><a href="#第二中间期（Second-Intermediate-Period-BC1650-BC1550）" class="headerlink" title="第二中间期（Second Intermediate Period, BC1650 - BC1550）"></a>第二中间期（Second Intermediate Period, BC1650 - BC1550）</h2><p>十三王朝的继续衰弱导致尼罗河三角洲（属于下埃及）的政权脱离并独立，是为十四王朝。统治者可能是迦南人（闪米特人）血统。</p><p>注意十三王朝和十四王朝几乎是共存的，直到 BC1650 希克索人全面控制下埃及，攻占了古首都孟菲斯。</p><h3 id="希克索人的外族统治"><a href="#希克索人的外族统治" class="headerlink" title="希克索人的外族统治"></a>希克索人的外族统治</h3><p>希克索人对下埃及的统治被视为十五王朝，而南边的底比斯统治者也趁十三王朝的真空宣布独立并宣布十六王朝。</p><p>希克索人继续南下把十六王朝打败后，北退，上埃及建立十七王朝与希克索共存。</p><p>十七王朝学习希克索人的战术和武器，在十七王朝最后两个法老统治期间反攻北面希克索人。</p><p>阿赫摩斯一世（Ahmose I）是十七王朝最后一个法老的弟弟，继续父亲和兄长意志将希克索人赶出埃及，开创十八王朝，进入新王国时期。</p><p>包含十四王朝到十七王朝，共四个王朝，17 / 31。</p><h2 id="新王国时期（New-Kingdom-BC1570-－-BC1070）"><a href="#新王国时期（New-Kingdom-BC1570-－-BC1070）" class="headerlink" title="新王国时期（New Kingdom, BC1570 － BC1070）"></a>新王国时期（New Kingdom, BC1570 － BC1070）</h2><p>这个时期有很多有名的法老。宗教上也有不少的变动。</p><p>在神明崇拜上，由于此时统一埃及十七王朝的统治者就是底比斯的家族，所以底比斯的地方神祇阿蒙（Amun）被推举到了主神的地位。由于古埃及一直以来一般都认为主神是太阳神拉（Ra），所以这段时期又经常将阿蒙和拉结合为同一个神，叫阿蒙-拉。</p><p>古埃及历史上最强盛的十八王朝就在这个时期内。</p><h3 id="阿赫摩斯一世（Ahmose-I）赶走外族，统一上下埃及"><a href="#阿赫摩斯一世（Ahmose-I）赶走外族，统一上下埃及" class="headerlink" title="阿赫摩斯一世（Ahmose I）赶走外族，统一上下埃及"></a>阿赫摩斯一世（Ahmose I）赶走外族，统一上下埃及</h3><p>十八王朝第一任法老阿赫摩斯一世（Ahmose I），他登基的时候可能只有十岁，并可能在二十岁左右完成了「驱逐胡虏」，恢复了埃及对努比亚的统治。</p><p>之后是阿赫摩斯一世的儿子阿蒙霍特普一世（Amenhotep I）继位。</p><p>接下来的法老图特摩斯一世（Thutmose I）的身世则有点模糊，有可能是阿蒙霍特普一世的儿子，或者是他的军队指挥官。他意图扩大埃及版图，并第一个在帝王谷建造坟墓。</p><p><img alt="Valley of the Kings，帝王谷。via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2a/ValleeDesRois.JPG/800px-ValleeDesRois.JPG" data-original="https://upload.wikimedia.org/wikipedia/commons/2/2a/ValleeDesRois.JPG"></p><p>图特摩斯一世儿女中有一个儿子，图特摩斯二世（Thutmose II），是由妃子所生；其中有一个女儿，哈特谢普苏特（Hatshepsut），是由王后所生。</p><p>王后没有儿子，于是图特摩斯二世娶了他的姐姐哈特谢普苏特并登上王位，但很快就死了，而哈特谢普苏特只生了一个女儿，所以又从图特摩斯二世的妃子中找了个儿子当图特摩斯三世（Thutmose III）。</p><h3 id="古埃及的「武则天」，哈特谢普苏特"><a href="#古埃及的「武则天」，哈特谢普苏特" class="headerlink" title="古埃及的「武则天」，哈特谢普苏特"></a>古埃及的「武则天」，哈特谢普苏特</h3><p>或许是因为图特摩斯三世太幼小，又或者是因为哈特谢普苏特觉得自己是正统王室之后，因此虽然作为摄政王，但是肯定是想自己当甚至极有可能当上了法老。而且考古学者从资料和建筑中考据，亦基本承认了她法老的地位（同时图特摩斯三世仍然在位）。</p><p>哈特谢普苏特在位期间的贡献主要为重新建立被希克索人入侵时破坏的贸易路线，以及大兴土木建造了很多建筑。她停止了土地扩张，使埃及在叙利亚及巴勒斯坦的统治权动摇（死后更丢失了统治权，但后来图特摩斯三世重新收复），但加强了和邻国的贸易，使埃及变得富庶。</p><p>她在卡纳克神庙建造了两个方尖碑，其中之一是埃及现存方尖碑中最高的，约 29 米高。</p><p>她在曼图霍特普二世神庙旁建造的哈特谢普苏特神庙，是古埃及建筑杰作以及热门景区。</p><p><img alt="卡纳克神庙，埃及现存最大神庙，中王国时期开始建造，一直是法老们建造崇拜神明和歌颂自己的建筑的地方 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3b/Temple_Complex_at_Karnak.jpg/640px-Temple_Complex_at_Karnak.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/3/3b/Temple_Complex_at_Karnak.jpg"></p><p><img alt="哈特谢普苏特方尖碑 via www.obelisks.org" src="http://www.obelisk.co3.jp/thumbnail/karnak_hatshepsut_south.jpg" data-original="http://www.obelisk.co3.jp/karnak_hatshepsut_south.jpg"></p><p><img alt="左为曼图霍特普二世神庙，已倒塌，右为哈特谢普苏特神庙 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/42/SFEC_AEH_-ThebesNecropolis-2010-Hatshepsut-023.jpg/640px-SFEC_AEH_-ThebesNecropolis-2010-Hatshepsut-023.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/4/42/SFEC_AEH_-ThebesNecropolis-2010-Hatshepsut-023.jpg"></p><p><img alt="哈特谢普苏特神庙正面照 via www.egypt.travel" src="http://www.egypt.travel/media/1717/temple-of-hatshupsut_800x600.jpg" data-original="http://www.egypt.travel/media/1717/temple-of-hatshupsut_800x600.jpg"></p><p>经历王女、王后、摄政王和法老，哈特谢普苏特让人联想起中国的「武则天」。</p><h3 id="埃及的拿破仑，图特摩斯三世"><a href="#埃及的拿破仑，图特摩斯三世" class="headerlink" title="埃及的拿破仑，图特摩斯三世"></a>埃及的拿破仑，图特摩斯三世</h3><p>图特摩斯三世在哈特谢普苏特统治二十一到二十二年后重新归来，并积极扩充军队和埃及版图，征服了地中海沿岸的以色列和叙利亚地区，甚至让邻国给其纳贡。图特摩斯三世也被后人称为「埃及的拿破仑」。</p><p><img alt="新王国时期古埃及在公元前15世纪的最大领土范围 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a8/Egypt_1450_BC.svg/520px-Egypt_1450_BC.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/a/a8/Egypt_1450_BC.svg"></p><p>图特摩斯三世重获权力后，通过破坏纪念碑等方式极力抹除哈特谢普苏特的存在。后面的王朝在王表编纂上也似乎故意忽略了这个法老。</p><blockquote><p>哈特谢普苏特和图特摩斯三世之间的关系，一般认为图特摩斯三世怨恨哈特谢普苏特。但最近一些研究进展称此说法不准确，并声称图特摩斯三世一直担当哈特谢普苏特的军事统治领袖，哈特谢普苏特也没有取其性命；而且损毁行动在图特摩斯三世统治晚期集中进行，哈特谢普苏特的资料也不是唯一被损毁的资料；从而推测图特摩斯三世是为了巩固继承人地位而作出如此的行为，他本人和他的继母并没有过节。这部分说法维基暂时没有找到证据支持。</p></blockquote><p>埃及在图特摩斯三世以及几位法老的努力下，终于在阿蒙霍特普三世（Amenhotep III）治下达到艺术和国力顶峰。阿蒙霍特普三世一生建造了很多宏伟的建筑和雕像，其中有著名的门农巨像。门农巨像座落在是蒙霍特普三世神庙的门口守卫。而阿蒙霍特普三世神庙是埃及最大最华丽的建筑群，可是后来因为地震和被拆除的缘故，现在已经不存在了，剩下两尊残破的门农巨像。</p><p><img alt="门农巨像正面照 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ee/Colossi_of_Memnon_May_2015_2.JPG/640px-Colossi_of_Memnon_May_2015_2.JPG" data-original="https://upload.wikimedia.org/wikipedia/commons/e/ee/Colossi_of_Memnon_May_2015_2.JPG"></p><p><img alt="阿蒙霍特普三世神庙鸟瞰图，门农巨像在右边 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/Amenhotep_III_mortuary_Temple.jpg/640px-Amenhotep_III_mortuary_Temple.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/b/ba/Amenhotep_III_mortuary_Temple.jpg"></p><p>帝国的强盛、对阿蒙神的崇拜和皇家经常修建神殿，令阿蒙神庙的祭司获得极大的财富和权力，祭司们不免出现腐败和干预朝政的行为。</p><h3 id="被后继者视为异端的宗教改革者，阿蒙霍特普四世"><a href="#被后继者视为异端的宗教改革者，阿蒙霍特普四世" class="headerlink" title="被后继者视为异端的宗教改革者，阿蒙霍特普四世"></a>被后继者视为异端的宗教改革者，阿蒙霍特普四世</h3><p>于是阿蒙霍特普三世的儿子，阿蒙霍特普四世，相信是为了打击祭司和权贵，进行了宗教改革。他简化多神系统，要求全国改为崇拜唯一的太阳神阿顿（Aten），甚至把自己的名字改为阿肯那顿（Akhenaten），迁都埃赫塔顿（Akhetaten），摧毁阿蒙神庙。有学者认为这表明了他创造了世界上最早的一神教。但他沉迷新兴宗教事务，以至于对边疆情况置若罔闻，而此时地中海北面的赫梯人正值盛时。于是古埃及逐渐失去了西亚地区的影响力。</p><p>他的大皇后，娜芙蒂蒂（Nefertiti），很有可能和他一同统治埃及。</p><p><img alt="有名的半身像 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Nofretete_Neues_Museum.jpg/328px-Nofretete_Neues_Museum.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/1/1f/Nofretete_Neues_Museum.jpg"></p><p>阿肯那顿的后继者在他死后又把旧宗教恢复回来，并大力抹消新兴宗教的记录和影响。</p><p><img alt="阿顿 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Aten.svg/640px-Aten.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/a/af/Aten.svg"></p><h3 id="生前不出名，死后却最出名的法老，图坦卡蒙"><a href="#生前不出名，死后却最出名的法老，图坦卡蒙" class="headerlink" title="生前不出名，死后却最出名的法老，图坦卡蒙"></a>生前不出名，死后却最出名的法老，图坦卡蒙</h3><p>阿肯那顿之后经过了一个或者两个短暂统治的法老（可能是他儿子或者王后摄政），王位传到了最著名的法老——图坦卡蒙（Tutankhamun）。</p><p><img alt="图坦卡蒙的木乃伊面具 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e5/TUT-Ausstellung_FFM_2012_47_%287117819557%29.jpg/360px-TUT-Ausstellung_FFM_2012_47_%287117819557%29.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/e/e5/TUT-Ausstellung_FFM_2012_47_%287117819557%29.jpg"></p><p>图坦卡蒙曾用名图坦卡顿（Tutankhaten），从名字的更改可以看出信仰的更改。他将首都迁回底比斯，重开神庙，重新恢复阿蒙神的崇拜。</p><p>图坦卡蒙的出名是因为所有法老的坟墓都几乎被盗空了，而唯有他在帝王谷的坟墓三千多年来从没被盗，以至于发掘出近五千件文物，令法老以及图坦卡蒙成为流行文化。</p><p>关于有名的「法老的诅咒」，可以说没有任何证据表明诅咒存在，坟墓内也没有发现任何诅咒的存在。打开坟墓和棺材的在场 58 人，据研究只有 8 - 10 人在十几年内死亡，根本不足为诅咒的依据。</p><div class="note info">            <p>2019 年（本年） 1 月，图坦卡蒙坟墓向游客开放。</p>          </div><h3 id="混乱的最后几任十八王朝法老"><a href="#混乱的最后几任十八王朝法老" class="headerlink" title="混乱的最后几任十八王朝法老"></a>混乱的最后几任十八王朝法老</h3><p>然而图坦卡蒙似乎一直疾病缠身，18 岁就死了，死因有各种猜测，包括疟疾、腿疾或者被谋杀。他与其异母姐姐安克姗海娜曼的两个女儿也早年夭折，因此图特摩斯家族就绝后了。安克姗海娜曼似乎曾经写信给赫梯国王苏庇路里乌玛一世要求他要一个王子嫁给她，但是王子还没到就被杀了。</p><p>之后是阿肯那顿和图坦卡蒙大臣，甚至可能是其背后的操纵者，阿伊（Ay），极有可能娶了安克姗海娜曼，当上了法老，统治了一个很短暂的时期。之后就被图坦卡蒙的将军，霍朗赫布（又或者哈伦海布，Horemheb）夺取了法老位置。</p><p>霍朗赫布以孟菲斯为首都，继续抹除阿顿以及其前任等人的痕迹，算是个解决宗教动荡和国家分裂等麻烦的人。</p><p>霍朗赫布跟王室没有关系，也没有儿子，法老位置传给了当时的大臣门帕提拉（原名普拉美斯，Paramesse），即十九王朝的第一任法老拉美西斯一世（Ramesses I）。</p><h3 id="被儿子盖住名声的塞提一世"><a href="#被儿子盖住名声的塞提一世" class="headerlink" title="被儿子盖住名声的塞提一世"></a>被儿子盖住名声的塞提一世</h3><p>拉美西斯一世的儿子塞提一世（Seti I）和她父亲重建了王国的秩序，并在叙利亚和迦南地区打击赫梯人的势力。从纪念碑上可以找到他的伟大功绩，虽然一般来说都是倾向于夸大。总的来说，塞提一世可以说是恢复新王国时期的荣光。</p><p>塞提一世也兴建了很多建筑，包括位于底比斯的塞提一世祭庙、位于阿拜多斯的塞提一世纪念庙以及大柱式大厅，虽然大部分应该是在拉美西斯二世时期完成的。</p><p><img alt="塞提一世神庙 via www.egypt.travel" src="http://www.egypt.travel/media/1297/temple-of-seti-1.jpg" data-original="http://www.egypt.travel/media/1297/temple-of-seti-1.jpg"></p><p>阿拜多斯的塞提一世纪念庙虽然外表其貌不扬，但是内部壁画精美，而且有不少壁画仍然有颜色。其中一面墙上按时间顺序记录了大多数王朝的法老的名字，从美尼斯到塞提一世共 76 个，被称为阿拜多斯王表，是后世研究历史的主要来源之一。</p><p><img alt="塞提一世纪念庙 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/3/33/AbydosFacade.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/3/33/AbydosFacade.jpg"></p><p><img alt="阿拜多斯王表，法老的名字是圈起来的 via pharaoh.se" src="https://pharaoh.se/hiero/ABY1200.jpg" data-original="https://pharaoh.se/hiero/ABY1200.jpg"></p><p><img alt="阿拜多斯王表，法老的名字是圈起来的 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/AbydosKinglistDrawing.png/640px-AbydosKinglistDrawing.png" data-original="https://upload.wikimedia.org/wikipedia/commons/f/f1/AbydosKinglistDrawing.png"></p><p><img alt="大柱式大厅、神龛大厅 via www.egypt.travel" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5c/Pillars_of_Great_Hypostyle_Hall_in_Karnak_Luxor_Egypt.JPG/800px-Pillars_of_Great_Hypostyle_Hall_in_Karnak_Luxor_Egypt.JPG" data-original="https://upload.wikimedia.org/wikipedia/commons/5/5c/Pillars_of_Great_Hypostyle_Hall_in_Karnak_Luxor_Egypt.JPG"></p><h3 id="鼎鼎大名的拉美西斯二世"><a href="#鼎鼎大名的拉美西斯二世" class="headerlink" title="鼎鼎大名的拉美西斯二世"></a>鼎鼎大名的拉美西斯二世</h3><p>塞提一世的儿子就是赫赫有名的拉美西斯二世（Ramesses II）了。他如此的有名以至于后来有九位法老使用了拉美西斯这名字。他在位长达 66 到 67 年，执政的时期是新王国最后的强盛年代。</p><p>但凡古埃及强盛的时期，统治的法老无不是领土争端和宏伟建筑这两方面有所建树，拉美西斯二世也不例外。他打败从地中海入侵的海盗，向东北占领迦南地区和南叙利亚地区，和北面的强敌赫梯国王穆瓦塔利二世（Muwatalli II）来回地打拉锯战，最后分庭抗礼；稳定南边的努比亚。他在位时间比较长，也在埃及各地建造非常多的建筑，甚至在不是他建造的建筑上也留下标志。</p><p>卡迭石战役是埃及和赫梯之间比较著名的战役。战役的情况很可能是这样：埃及想进军占领卡迭石，但被赫梯战车袭击并击溃；法老在营地受困的时候雇佣兵到了，反击了赫梯，导致赫梯军败退；埃及虽然赢了这场战斗但是也无法攻克卡迭石，战略上算是输了。之后双方一直僵持不下。卡迭石战役有非常详细的记录，但基本都是埃及方面一面之词，因此也存在夸大拉美西斯二世的可能性。</p><p><img alt="两个帝国接壤的卡迭石（Qadesh） via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/Hitt_Egypt_Perseus.png/310px-Hitt_Egypt_Perseus.png" data-original="https://upload.wikimedia.org/wikipedia/commons/e/e9/Hitt_Egypt_Perseus.png"></p><p>之后穆瓦塔利二世病逝，拉美西斯二世和继位的哈图西里三世（Hattusili III）缔结埃及赫梯和约，此时距离卡迭石战役已经十五六年了。</p><p>埃及赫梯和平条约，或称卡迭石条约、永恒条约、银条约，是古代近东（即今西亚、中东地区）地区协议双方都有保存下来的最古老的条约。缔结和约结束了长期的冷战实际上对签署双方都有利益。埃及的目的，很可能是为了吹嘘法老功绩，并成立军事同盟以共同对抗西亚更东边的新贵力量亚述；而赫梯的目的，则可能是新王为了巩固地位以及利用法老的国际影响力提升自己的国际地位。</p><p><img alt="赫梯人版本的和约 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0d/Treaty_of_Kadesh.jpg/200px-Treaty_of_Kadesh.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/0/0d/Treaty_of_Kadesh.jpg"></p><p><img alt="埃及人版本的和约 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/93/%C3%84gyptisch-Hethitischer_Friedensvertrag_Karnaktempel.jpg/200px-%C3%84gyptisch-Hethitischer_Friedensvertrag_Karnaktempel.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/9/93/%C3%84gyptisch-Hethitischer_Friedensvertrag_Karnaktempel.jpg"></p><p>拉美西斯二世的闻名也许也来自于他遍布埃及的大型建筑和到处刻画自己的荣光事迹。</p><p>比较有名的建筑是拉美西姆神庙、哈布城神庙和阿布辛贝勒神庙。</p><p>拉美西姆神庙现今已经是废墟，往日的样子只能靠门口和后面的建筑来想像了。</p><p><img alt="拉美西姆神庙鸟瞰图 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/80/SFEC_AEH_-ThebesNecropolis-2010-RamsesII-021.jpg/640px-SFEC_AEH_-ThebesNecropolis-2010-RamsesII-021.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/8/80/SFEC_AEH_-ThebesNecropolis-2010-RamsesII-021.jpg"></p><p><img alt="门口的四个奥西里斯雕像 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/SFEC-RAMASSEUM-2009-11-14-0034.JPG/640px-SFEC-RAMASSEUM-2009-11-14-0034.JPG" data-original="https://upload.wikimedia.org/wikipedia/commons/1/1c/SFEC-RAMASSEUM-2009-11-14-0034.JPG"></p><p>比较值得注意的是庙内有一副拉美西姆国王名单（Ramesseum king list），列出了新王朝的大部分法老。</p><p><img alt="拉美西姆国王名单手绘图 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2a/Ramesseum_King_list.png/800px-Ramesseum_King_list.png" data-original="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2a/Ramesseum_King_list.png/1920px-Ramesseum_King_list.png"></p><p>哈布城神庙（Medinet Habu）离哈特谢普苏特神庙不远，很多法老都在这修建过建筑，刻过壁画。然而拉美西斯二世应该是其中最张扬的了，似乎很害怕被人遗忘。</p><p><img alt="哈布城神庙鸟瞰图 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/SFEC_AEH_-ThebesNecropolis-2010-RamsesIII036.jpg/640px-SFEC_AEH_-ThebesNecropolis-2010-RamsesIII036.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/4/4e/SFEC_AEH_-ThebesNecropolis-2010-RamsesIII036.jpg"></p><p>拉美西斯二世本身就喜欢乱改别人的壁画，因此他也害怕别人抹掉他的壁画，于是他的壁画都刻得非常深。</p><p><img alt="哈布城壁画 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/93/Habu_Temple_court_in_sesson.JPG/640px-Habu_Temple_court_in_sesson.JPG" data-original="https://upload.wikimedia.org/wikipedia/commons/9/93/Habu_Temple_court_in_sesson.JPG"></p><p>阿布辛贝勒神庙（Abu Simbel temples）应该是很多人从电视媒体等看到过的神庙之一，整个神庙在岩石上开凿而成，门口四个雕像也是其标志之一。</p><p><img alt="阿布辛贝勒神庙正面 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/28/Abu_Simbel%2C_Ramesses_Temple%2C_front%2C_Egypt%2C_Oct_2004.jpg/640px-Abu_Simbel%2C_Ramesses_Temple%2C_front%2C_Egypt%2C_Oct_2004.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/2/28/Abu_Simbel%2C_Ramesses_Temple%2C_front%2C_Egypt%2C_Oct_2004.jpg"></p><p>神庙东北面是法老为哈索尔（Hathor，古埃及女神）和妮菲塔莉（Nefertari，拉美西斯二世的大王后）所建的小庙（the Small Temple）。妮菲塔莉的雕像跟拉美西斯二世一样高，表明地位跟他几乎平起平坐，也是几乎唯一一位在世就被神格化的埃及王后。其他同样有名的王后是克利奥帕特拉七世（埃及艳后）、娜芙蒂蒂（阿肯那顿的大王后）和哈特谢普苏特（埃及「武则天」）。</p><p><img alt="左为阿布辛贝勒神庙，右为小庙 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/63/Panorama_Abu_Simbel_crop.jpg/640px-Panorama_Abu_Simbel_crop.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/6/63/Panorama_Abu_Simbel_crop.jpg"></p><p>近代由于在阿斯旺兴建水坝，联合国筹钱将阿布辛贝勒神庙和小庙搬离到比原地高 200 米处。</p><p><img alt="搬迁前后位置对比 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/06/Abu_Simbel_relocation_by_Zureks.jpg/640px-Abu_Simbel_relocation_by_Zureks.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/0/06/Abu_Simbel_relocation_by_Zureks.jpg"></p><p>频繁的战争、大兴土木，造就了巨大的国库开销，加大了国力下降。在拉美西斯二世死后，埃及就立刻开始走下坡路。</p><h3 id="第二十王朝的祭司当权"><a href="#第二十王朝的祭司当权" class="headerlink" title="第二十王朝的祭司当权"></a>第二十王朝的祭司当权</h3><p>过了几任法老后，到了第二十王朝第二任法老拉美西斯三世的统治。他抵抗了几次地中海和利比亚的入侵，治下还出现了人类历史上第一次有记录的劳工罢工。他的一个妃子还曾试图毒杀他，最后是失败了。</p><p>拉美西斯五世，土地和财政基本就已经被阿蒙神庙的祭司所控制了。</p><p>拉美西斯六世在建造坟墓时无意间将图坦卡蒙坟墓埋在了地下，避免了其日后被盗掘。</p><p>第二十王朝，古埃及陷入内忧外患，尼罗河水位下降、内政动乱、法老坟墓被盗、官员腐败，又丢了叙利亚和巴勒斯坦，最后法老基本就没有统一埃及的权力了。</p><p>包含十八王朝到二十王朝，共三个王朝，20 / 31。</p><h2 id="第三中间期（3rd-Intermediate-Period-BC1069-BC664）"><a href="#第三中间期（3rd-Intermediate-Period-BC1069-BC664）" class="headerlink" title="第三中间期（3rd Intermediate Period, BC1069 - BC664）"></a>第三中间期（3rd Intermediate Period, BC1069 - BC664）</h2><p>拉美西斯十一世死后，结束二十王朝，斯门代斯一世（Smendes I）开创二十一王朝，然而此时法老权力已经极弱，基本被赶到下埃及去了，上埃及和中埃及地区则是由底比斯阿蒙神庙的大祭司们所控制。</p><h3 id="利比亚人的二十二、二十三、二十四王朝"><a href="#利比亚人的二十二、二十三、二十四王朝" class="headerlink" title="利比亚人的二十二、二十三、二十四王朝"></a>利比亚人的二十二、二十三、二十四王朝</h3><p>之前二十王朝已经在尼罗河三角洲定居的利比亚人，在舍顺克一世（Shoshenq I）统领下统一埃及，创立二十二王朝，这里的法老已经不是本土埃及人了。然后二十三王朝二十四王朝，王室和内政仍然比较动荡，南方起源于库施（kush）的努比亚王国趁乱北上把整个埃及打了下来，赶走了利比亚人，建立二十五王朝。</p><h3 id="努比亚人的二十五王朝"><a href="#努比亚人的二十五王朝" class="headerlink" title="努比亚人的二十五王朝"></a>努比亚人的二十五王朝</h3><p>努比亚人重新恢复了古埃及的的宗教传统，修复和建造了不少寺庙和纪念碑，还在家乡（位于现在的苏丹）重新建造起金字塔来。</p><p><img alt="二十五王朝的库施帝国 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1a/Egypt_kush.svg/523px-Egypt_kush.svg.png" data-original="https://upload.wikimedia.org/wikipedia/commons/1/1a/Egypt_kush.svg"></p><p>包含二十一王朝到二十五王朝，共五个王朝，25 / 31。</p><h2 id="古埃及晚期-波斯帝国时期（Late-Period-BC664-BC332）"><a href="#古埃及晚期-波斯帝国时期（Late-Period-BC664-BC332）" class="headerlink" title="古埃及晚期 / 波斯帝国时期（Late Period, BC664 - BC332）"></a>古埃及晚期 / 波斯帝国时期（Late Period, BC664 - BC332）</h2><p>之后西亚的亚述人开始入侵古埃及，努比亚人不敌，向南退回努比亚。亚述人可能对占着古埃及没有兴趣，在洗劫一番后退了回去，扶植了普萨美提克一世（Psammetichus I）作为法老。</p><h3 id="古埃及本土最后的荣光，二十六王朝"><a href="#古埃及本土最后的荣光，二十六王朝" class="headerlink" title="古埃及本土最后的荣光，二十六王朝"></a>古埃及本土最后的荣光，二十六王朝</h3><p>之后，普萨美提克一世趁亚述帝国忙于战乱，联合古希腊的雇佣军，又重新统一了古埃及，建立二十六王朝，恢复了繁荣稳定。之后亚述被内部独立的新巴比伦帝国推翻，普萨美提克一世也曾想恢复西亚的霸权，但被尼布甲尼撒二世（Nebuchadnezzar II）统治的新巴比伦帝国打了回来。</p><p>那个古埃及法老用婴儿做实验，实验听不到别人说话怎么学语言的故事，就是普萨美提克一世的故事，记录在希罗多德写的书「历史」第二卷中。</p><p><img alt="亚述帝国最大版图 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/e/eb/Assy3.JPG" data-original="https://upload.wikimedia.org/wikipedia/commons/e/eb/Assy3.JPG"></p><p>然而二十六王朝已经是最后一个埃及本土王朝了。更东边的波斯阿契美尼德帝国（波斯第一帝国）灭了新巴比伦帝国，接着吞并了古埃及，波斯国王冈比西斯二世（Cambyses II）成了法老，称为二十七王朝。</p><p>之后二十六王朝后裔推翻波斯的统治，先后建立短暂的二十八、二十九、三十王朝。</p><p>然后波斯人再次征服古埃及，是为三十一王朝。</p><p>包含二十六王朝到三十一王朝，共六个王朝，31 / 31。</p><h2 id="马其顿的亚历山大解放埃及-gt-托勒密王朝（Macedonian-and-Ptolemaic-Egypt-BC332-BC30）"><a href="#马其顿的亚历山大解放埃及-gt-托勒密王朝（Macedonian-and-Ptolemaic-Egypt-BC332-BC30）" class="headerlink" title="马其顿的亚历山大解放埃及 -&gt; 托勒密王朝（Macedonian and Ptolemaic Egypt, BC332 - BC30）"></a>马其顿的亚历山大解放埃及 -&gt; 托勒密王朝（Macedonian and Ptolemaic Egypt, BC332 - BC30）</h2><h3 id="埃及解放者，亚历山大"><a href="#埃及解放者，亚历山大" class="headerlink" title="埃及解放者，亚历山大"></a>埃及解放者，亚历山大</h3><p>当无人不知的亚历山大击溃波斯大军并来到埃及的时候，根本没有遇到什么抵抗，埃及当地的波斯管理者就直接将埃及献给他了，埃及人民还视其为埃及的解放者。</p><p>亚历山大尊重当地信仰，去绿洲朝圣得到神谕。神谕宣称他是阿蒙的儿子。实际上就是得到了祭司等有权势的人的承认。他成立了一个新的希腊城市名为亚历山大（他到哪就在哪建亚历山大城），并任命希腊人——而不是埃及人——作为高官。</p><p>亚历山大没有在埃及待很久，就去征服其他地方了，从此再没有回来过。他的部下托勒密留在埃及统治，并从亚历山大死后分崩离析的亚历山大帝国中独立出来，创立托勒密王朝统治了近三百年。</p><h3 id="希腊法老，托勒密王朝"><a href="#希腊法老，托勒密王朝" class="headerlink" title="希腊法老，托勒密王朝"></a>希腊法老，托勒密王朝</h3><p>托勒密王朝中，男性都叫托勒密（Ptolemy），女性一般叫克利奥帕特拉（Cleopatra）、贝勒尼基（Berenice）和阿尔西诺伊（Arsinoe），因此所有统治者都是这四个名字的加几世这样的称呼。最为人知的就是末代法老，埃及艳后，克利奥帕特拉七世。</p><p>托勒密王朝没有使用希腊文明取代埃及文明，反而扶持其延续，修建埃及风格的神庙，维护传统宗教仪式。当然也带来了希腊文明的影响，这个时期很多文艺作品都有两个文明融合的风格。</p><h3 id="罗塞塔石碑，托勒密五世诏书"><a href="#罗塞塔石碑，托勒密五世诏书" class="headerlink" title="罗塞塔石碑，托勒密五世诏书"></a>罗塞塔石碑，托勒密五世诏书</h3><p>罗塞塔石碑本来并不是什么比较特别的石碑，只是托勒密五世加冕一周内纪念所制，但碑上同时使用了三种语言，分别是圣书体（埃及象形文字）、埃及草书（世俗体）和古希腊文，令后世学者可以做参考比对，通过古希腊文来解读圣书体，从而使这块石碑无比珍贵，也因此罗塞塔石碑在现代也被引申为「暗喻」、「翻译」和「关键线索」等的含义。</p><p><img alt="罗塞塔石碑 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Rosetta_Stone.JPG/410px-Rosetta_Stone.JPG" data-original="https://upload.wikimedia.org/wikipedia/commons/2/23/Rosetta_Stone.JPG"></p><h3 id="艳后与凯撒"><a href="#艳后与凯撒" class="headerlink" title="艳后与凯撒"></a>艳后与凯撒</h3><p>克利奥帕特拉七世是托勒密王朝中第一个学会埃及语并接受埃及信仰和埃及神明的人，这是其他王室成员所拒绝的事（想想罗塞塔石碑还需要古希腊文书写）。她早年在就政治上活跃，应该算是被迫和托勒密十三世（同父异母弟弟）结婚以一同统治埃及。但之后两人发生冲突，艳后被迫流亡叙利亚，招兵买马打算反攻托勒密十三世。</p><p>此时罗马内部也正在争斗，凯撒打败了庞培，后者被迫跑到埃及。而托勒密十三世可能希望寻求凯撒支持而擅自将凯撒老对手庞培暗杀了，在凯撒追到埃及时献上庞培的头颅。这可能令凯撒十分不满，因为庞培是他的劲敌、女婿，也是罗马执政官，不应该被异国人杀死。</p><p>克利奥帕特拉七世可能看准了这个机会潜回埃及，并将自己献给凯撒，做他的情人，取得凯撒的支持。之后凯撒对埃及统治者的仲裁，是克利奥帕特拉七世上位。</p><blockquote class="blockquote-center"><p>传说当时克利奥帕特拉把自己伸直，用毯子卷起来包覆其中，命人抬着进入王宫，这时克利奥帕特拉年仅21岁，凯撒52岁。<br><em>维基百科</em></p></blockquote><p>托勒密十三世当然十分不满，率军围攻亚历山大城内罗马军。凯撒等到增援到来，脱围之后在尼罗河战役打败托勒密十三世，随后另立了托勒密十四世（仍旧是艳后的弟弟）和艳后结婚统治埃及。艳后虽然名义上嫁给托勒密十四世，但是实际上却和凯撒相好，还生了一个孩子托勒密·凯撒。</p><p>BC46，艳后来到罗马，遭到罗马人民的厌恶，因为凯撒已婚，而她和凯撒关系暧昧。但凯撒不愧为独裁者，完全罔顾旁人，甚至为艳后制作黄金雕像，和罗马人先祖维纳斯神像一起摆放。在凯撒被刺后，艳后还留在罗马，可能是希望自己儿子继承凯撒。但是凯撒大概没有承认这个儿子，而是在遗嘱另立他的养子屋大维作为继承人。于是她回到埃及，毒死了托勒密十四世，与其儿子共同统治埃及。</p><h3 id="艳后与安东尼"><a href="#艳后与安东尼" class="headerlink" title="艳后与安东尼"></a>艳后与安东尼</h3><p>安东尼是凯撒生前最重要的军队指挥官。凯撒被刺后，他和屋大维解决了反凯撒势力。之后在埃及传唤艳后的时候也应该是被迷住了，和她在 BC41 到 BC40 年度过了一段时光。接着安东尼离开了埃及，艳后不久后生下一男一女双胞胎，相信就是安东尼的儿女。</p><p>安东尼和屋大维从 BC41 年开始就不和，因为安东尼妻子发起了和屋大维对抗的战争。虽然后来妻子突然身亡，安东尼也娶了屋大维的姐姐小屋大薇以维持稳定，但是两人仍然是竞争关系。安东尼把大量土地给予了艳后，屋大维利用这一点宣称其为外国女王而牺牲共和国权利。两人关系持续恶化，安东尼也冷落小屋大薇。之后对安息帝国的战争失利，安东尼回到埃及。BC36 年，艳后又为安东尼生下第二个儿子。</p><p>BC34 年赢得对亚美尼亚的战争后，安东尼和艳后在大胜后的举动被屋大维大肆利用，煽动罗马对安东尼的不满，包括艳后以神的名义宣称自己和凯撒的儿子是万王之王，自己则是万王之女王，和安东尼的儿女则分别册封国王等。安东尼更公然向罗马宣称将包括打下亚美尼亚等一部分罗马行省赠予克利奥帕特拉七世。最冒犯屋大维的，是安东尼宣称艳后和凯撒的儿子托勒密·凯撒才应该是凯撒的继承人。</p><p>屋大维借机行事向埃及女王宣战，在亚克兴角海战中打败安东尼。安东尼输掉海战的原因可能是因为海军在战事胶着时出现叛逃，安东尼和艳后逃回了埃及，陆军见势也投降屋大维了。</p><p>屋大维乘胜追击到埃及，退无可退的安东尼误认为艳后已自杀，用剑刺自己，可能是被带到艳后藏身的坟墓才真正死去。艳后随后也被捕了。</p><p>关于克利奥帕特拉七世的死法，无人知道。流传最广的版本是她让毒蛇咬自己而毒发身亡，也有观点认为他是被屋大维下令处死。</p><p>她和凯撒的儿子托勒密·凯撒被屋大维处死，从此埃及成为了罗马帝国的行省，托勒密王朝终结，埃及的法老时代也终结了。</p><p><img alt="丹达拉的哈索尔神庙 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3c/Dendera_7_977.PNG/621px-Dendera_7_977.PNG" data-original="https://upload.wikimedia.org/wikipedia/commons/3/3c/Dendera_7_977.PNG"></p><p><img alt="哈索尔神庙墙上的克利奥帕特拉七世和她的儿子托勒密·凯撒 via 维基百科" src="https://upload.wikimedia.org/wikipedia/commons/4/49/Denderah3_Cleopatra_Cesarion.jpg" data-original="https://upload.wikimedia.org/wikipedia/commons/4/49/Denderah3_Cleopatra_Cesarion.jpg"></p><h2 id="罗马统治时期-gt-阿拉伯人入侵"><a href="#罗马统治时期-gt-阿拉伯人入侵" class="headerlink" title="罗马统治时期 -&gt; 阿拉伯人入侵"></a>罗马统治时期 -&gt; 阿拉伯人入侵</h2><p>作为罗马帝国行省的埃及，发生的事情属于罗马的历史了，这里不详述。只是 CE264 年的时候，反抗罗马的帕尔米拉女王季诺碧亚征服了埃及使其脱离罗马，并自称埃及女王，说她的家族可追溯到克利奥帕特拉七世。后来罗马也没有战胜她，只能是围城断粮逼其投降。</p><p>埃及有一段时间曾被萨珊王朝所占领（CE621 - CE629），拜占庭（东罗马帝国）虽然重新夺回，但十年后阿拉伯帝国入侵的时候，已经无力抵抗，自此埃及伊斯兰化，埃及文明也不复存在。</p><h2 id="古埃及神明"><a href="#古埃及神明" class="headerlink" title="古埃及神明"></a>古埃及神明</h2><p>古埃及是一个宗教特色很浓的国家，了解其神明系统有助于深入理解古埃及，不过没有兴趣也可不看。</p><p>见 <a href="/learn-ancient-egyptian-gods-in-5-minutes">古埃及神明</a> 一文。</p><h2 id="一些小知识"><a href="#一些小知识" class="headerlink" title="一些小知识"></a>一些小知识</h2><p>法老的头冠分两部分，代表上埃及的白色王冠，代表下埃及的红色王冠，一般法老会戴着两个，诏示其为整个埃及的统治者。</p><p>古埃及神话中的神明都是兄妹 / 姐弟结合，这可能造成了古埃及王室基本都是近亲结合。如果侧室的儿子登基法老，一般也要娶正室的女儿。统治者可能借此保持所谓的血统纯正。</p><p>建造金字塔和神庙的大石头、花岗岩等，很多是从阿斯旺开凿的。</p><h2 id="部分参考资料"><a href="#部分参考资料" class="headerlink" title="部分参考资料"></a>部分参考资料</h2><p><a href="https://www.bilibili.com/medialist/play/ml454556918" target="_blank" rel="noopener">开放世界埃及篇</a><br><a href="https://zh.wikipedia.org/wiki/古埃及" target="_blank" rel="noopener">古埃及 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/古埃及历史" target="_blank" rel="noopener">古埃及历史 - 维基百科，自由的百科全书</a><br><a href="https://auntology.fandom.com/wiki/阿姨学、古埃及" target="_blank" rel="noopener">阿姨学、古埃及 | 阿姨学词典 Wikia | FANDOM powered by Wikia</a><br><a href="https://en.wikipedia.org/wiki/History_of_ancient_Egypt" target="_blank" rel="noopener">History of ancient Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Prehistoric_Egypt" target="_blank" rel="noopener">Prehistoric Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Early_Dynastic_Period_%28Egypt%29" target="_blank" rel="noopener">Early Dynastic Period (Egypt) - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Old_Kingdom_of_Egypt" target="_blank" rel="noopener">Old Kingdom of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/First_Intermediate_Period_of_Egypt" target="_blank" rel="noopener">First Intermediate Period of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Middle_Kingdom_of_Egypt" target="_blank" rel="noopener">Middle Kingdom of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Second_Intermediate_Period_of_Egypt" target="_blank" rel="noopener">Second Intermediate Period of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/New_Kingdom_of_Egypt" target="_blank" rel="noopener">New Kingdom of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Third_Intermediate_Period_of_Egypt" target="_blank" rel="noopener">Third Intermediate Period of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Late_Period_of_ancient_Egypt" target="_blank" rel="noopener">Late Period of ancient Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Ptolemaic_Kingdom" target="_blank" rel="noopener">Ptolemaic Kingdom - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Sasanian_Egypt" target="_blank" rel="noopener">Sasanian Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/First_Dynasty_of_Egypt" target="_blank" rel="noopener">First Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Second_Dynasty_of_Egypt" target="_blank" rel="noopener">Second Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Third_Dynasty_of_Egypt" target="_blank" rel="noopener">Third Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Fourth_Dynasty_of_Egypt" target="_blank" rel="noopener">Fourth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Fifth_Dynasty_of_Egypt" target="_blank" rel="noopener">Fifth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Sixth_Dynasty_of_Egypt" target="_blank" rel="noopener">Sixth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Seventh_Dynasty_of_Egypt" target="_blank" rel="noopener">Seventh Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Eighth_Dynasty_of_Egypt" target="_blank" rel="noopener">Eighth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Ninth_Dynasty_of_Egypt" target="_blank" rel="noopener">Ninth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Tenth_Dynasty_of_Egypt" target="_blank" rel="noopener">Tenth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Eleventh_Dynasty_of_Egypt" target="_blank" rel="noopener">Eleventh Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Eleventh_Dynasty_of_Egypt" target="_blank" rel="noopener">Eleventh Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Twelfth_Dynasty_of_Egypt" target="_blank" rel="noopener">Twelfth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Thirteenth_Dynasty_of_Egypt" target="_blank" rel="noopener">Thirteenth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Fourteenth_Dynasty_of_Egypt" target="_blank" rel="noopener">Fourteenth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Fifteenth_Dynasty_of_Egypt" target="_blank" rel="noopener">Fifteenth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Sixteenth_Dynasty_of_Egypt" target="_blank" rel="noopener">Sixteenth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Abydos_Dynasty" target="_blank" rel="noopener">Abydos Dynasty - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Seventeenth_Dynasty_of_Egypt" target="_blank" rel="noopener">Seventeenth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Eighteenth_Dynasty_of_Egypt" target="_blank" rel="noopener">Eighteenth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Nineteenth_Dynasty_of_Egypt" target="_blank" rel="noopener">Nineteenth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Twentieth_Dynasty_of_Egypt" target="_blank" rel="noopener">Twentieth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Twenty-first_Dynasty_of_Egypt" target="_blank" rel="noopener">Twenty-first Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Twenty-second_Dynasty_of_Egypt" target="_blank" rel="noopener">Twenty-second Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Twenty-third_Dynasty_of_Egypt" target="_blank" rel="noopener">Twenty-third Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Twenty-fourth_Dynasty_of_Egypt" target="_blank" rel="noopener">Twenty-fourth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Twenty-fifth_Dynasty_of_Egypt" target="_blank" rel="noopener">Twenty-fifth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Twenty-sixth_Dynasty_of_Egypt" target="_blank" rel="noopener">Twenty-sixth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Twenty-eighth_Dynasty_of_Egypt" target="_blank" rel="noopener">Twenty-eighth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Twenty-ninth_Dynasty_of_Egypt" target="_blank" rel="noopener">Twenty-ninth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Thirtieth_Dynasty_of_Egypt" target="_blank" rel="noopener">Thirtieth Dynasty of Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Argead_dynasty" target="_blank" rel="noopener">Argead dynasty - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Ptolemaic_Kingdom" target="_blank" rel="noopener">Ptolemaic Kingdom - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Valley_of_the_Kings" target="_blank" rel="noopener">Valley of the Kings - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Giza_pyramid_complex" target="_blank" rel="noopener">Giza pyramid complex - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Histories_%28Herodotus%29" target="_blank" rel="noopener">Histories (Herodotus) - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Assyria" target="_blank" rel="noopener">Assyria - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Kingdom_of_Kush" target="_blank" rel="noopener">Kingdom of Kush - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Hyksos" target="_blank" rel="noopener">Hyksos - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Ramesseum" target="_blank" rel="noopener">Ramesseum - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Ancient_Near_East" target="_blank" rel="noopener">Ancient Near East - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Abu_Simbel_temples" target="_blank" rel="noopener">Abu Simbel temples - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Egyptian%E2%80%93Hittite_peace_treaty" target="_blank" rel="noopener">Egyptian–Hittite peace treaty - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Battle_of_Kadesh" target="_blank" rel="noopener">Battle of Kadesh - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Abydos_King_List" target="_blank" rel="noopener">Abydos King List - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Abydos,_Egypt" target="_blank" rel="noopener">Abydos, Egypt - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Canaan" target="_blank" rel="noopener">Canaan - Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Karnak" target="_blank" rel="noopener">Karnak - Wikipedia</a><br><a href="https://zh.wikipedia.org/wiki/早王朝时期" target="_blank" rel="noopener">早王朝时期 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/古王国时期" target="_blank" rel="noopener">古王国时期 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/第一中间时期" target="_blank" rel="noopener">第一中间时期 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/中王国时期" target="_blank" rel="noopener">中王国时期 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/第二中间时期" target="_blank" rel="noopener">第二中间时期 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/新王国时期" target="_blank" rel="noopener">新王国时期 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/第三中间时期" target="_blank" rel="noopener">第三中间时期 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/古埃及晚期" target="_blank" rel="noopener">古埃及晚期 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/阿契美尼德王朝" target="_blank" rel="noopener">阿契美尼德王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/托勒密时王朝" target="_blank" rel="noopener">托勒密时期 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及_%28羅馬帝國行省%29" target="_blank" rel="noopener">罗马及拜占庭时期 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/萨珊王朝" target="_blank" rel="noopener">萨珊时期 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第一王朝" target="_blank" rel="noopener">埃及第一王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第二王朝" target="_blank" rel="noopener">埃及第二王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第三王朝" target="_blank" rel="noopener">埃及第三王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第四王朝" target="_blank" rel="noopener">埃及第四王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第五王朝" target="_blank" rel="noopener">埃及第五王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第六王朝" target="_blank" rel="noopener">埃及第六王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第七王朝" target="_blank" rel="noopener">埃及第七王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第十一王朝" target="_blank" rel="noopener">埃及第十一王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第十二王朝" target="_blank" rel="noopener">埃及第十二王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第十三王朝" target="_blank" rel="noopener">埃及第十三王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第十四王朝" target="_blank" rel="noopener">埃及第十四王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第十五王朝" target="_blank" rel="noopener">埃及第十五王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第十六王朝" target="_blank" rel="noopener">埃及第十六王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第十七王朝" target="_blank" rel="noopener">埃及第十七王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第十八王朝" target="_blank" rel="noopener">埃及第十八王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第十九王朝" target="_blank" rel="noopener">埃及第十九王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第二十王朝" target="_blank" rel="noopener">埃及第二十王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第二十一王朝" target="_blank" rel="noopener">埃及第二十一王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第二十二王朝" target="_blank" rel="noopener">埃及第二十二王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第二十三王朝" target="_blank" rel="noopener">埃及第二十三王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第二十四王朝" target="_blank" rel="noopener">埃及第二十四王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第二十五王朝" target="_blank" rel="noopener">埃及第二十五王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第二十六王朝" target="_blank" rel="noopener">埃及第二十六王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第二十七王朝" target="_blank" rel="noopener">埃及第二十七王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第二十八王朝" target="_blank" rel="noopener">埃及第二十八王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第二十九王朝" target="_blank" rel="noopener">埃及第二十九王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第三十王朝" target="_blank" rel="noopener">埃及第三十王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及第三十一王朝" target="_blank" rel="noopener">埃及第三十一王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/古希腊" target="_blank" rel="noopener">古希腊 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/馬其頓王國" target="_blank" rel="noopener">馬其頓王國 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/托勒密王朝" target="_blank" rel="noopener">托勒密王朝 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/波斯" target="_blank" rel="noopener">波斯 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/帝王谷" target="_blank" rel="noopener">帝王谷 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/吉萨金字塔群" target="_blank" rel="noopener">吉萨金字塔群 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/吉萨金字塔群/历史_%28希罗多德%29" target="_blank" rel="noopener">历史 (希罗多德) - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/亚述" target="_blank" rel="noopener">亚述 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/库施" target="_blank" rel="noopener">库施 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/喜克索斯人" target="_blank" rel="noopener">喜克索斯人 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/拉美西姆" target="_blank" rel="noopener">拉美西姆 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/古代近东" target="_blank" rel="noopener">古代近东 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/阿布辛贝勒神庙" target="_blank" rel="noopener">阿布辛贝勒神庙 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/埃及赫梯和约" target="_blank" rel="noopener">埃及赫梯和约 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/卡迭石战役" target="_blank" rel="noopener">卡迭石战役 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/阿拜多斯王表" target="_blank" rel="noopener">阿拜多斯王表 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/阿拜多斯" target="_blank" rel="noopener">阿拜多斯 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/迦南" target="_blank" rel="noopener">迦南 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/卡纳克神庙" target="_blank" rel="noopener">卡纳克神庙 - 维基百科，自由的百科全书</a></p><h2 id="PDF-版"><a href="#PDF-版" class="headerlink" title="PDF 版"></a>PDF 版</h2><p><a href="/files/learn-ancient-egyptian-history-in-30-minutes.pdf">下载地址</a></p><h2 id="修订记录"><a href="#修订记录" class="headerlink" title="修订记录"></a>修订记录</h2><h3 id="2019-05-15"><a href="#2019-05-15" class="headerlink" title="2019.05.15"></a>2019.05.15</h3><ul><li>搜集材料</li><li>完成文章结构</li></ul><h3 id="2019-05-20"><a href="#2019-05-20" class="headerlink" title="2019.05.20"></a>2019.05.20</h3><ul><li>完成初稿</li></ul><h3 id="2019-05-21"><a href="#2019-05-21" class="headerlink" title="2019.05.21"></a>2019.05.21</h3><ul><li>新增缩略图</li><li>整体润色</li></ul><h3 id="2019-05-22"><a href="#2019-05-22" class="headerlink" title="2019.05.22"></a>2019.05.22</h3><ul><li>整理参考资料</li><li>增补早期王朝的内容</li></ul><h3 id="2019-05-23"><a href="#2019-05-23" class="headerlink" title="2019.05.23"></a>2019.05.23</h3><ul><li>新增「古埃及神明」一节</li></ul><h3 id="2019-06-01"><a href="#2019-06-01" class="headerlink" title="2019.06.01"></a>2019.06.01</h3><ul><li>添加 PDF 版</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几天在 bilibili 上看了一个 up 主的埃及旅游系列 &lt;a href=&quot;https://www.bilibili.com/medialist/play/ml454556918&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vlog&lt;/a&gt;，了解了
      
    
    </summary>
    
      <category term="知识" scheme="https://blog.e10t.net/categories/%E7%9F%A5%E8%AF%86/"/>
    
      <category term="古埃及" scheme="https://blog.e10t.net/categories/%E7%9F%A5%E8%AF%86/%E5%8F%A4%E5%9F%83%E5%8F%8A/"/>
    
    
      <category term="ancient-egypt" scheme="https://blog.e10t.net/tags/ancient-egypt/"/>
    
      <category term="history" scheme="https://blog.e10t.net/tags/history/"/>
    
  </entry>
  
  <entry>
    <title>不要再只会用 for 了</title>
    <link href="https://blog.e10t.net/dont-only-use-for-any-more/"/>
    <id>https://blog.e10t.net/dont-only-use-for-any-more/</id>
    <published>2017-10-23T15:54:14.000Z</published>
    <updated>2019-05-22T09:09:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>No Silver Bullet</p></blockquote><h2 id="老黄牛的-for"><a href="#老黄牛的-for" class="headerlink" title="老黄牛的 for"></a>老黄牛的 for</h2><p><img src="https://i.imgflip.com/1y3pxa.jpg" alt="for-for-everywhere"></p><p>几乎每一个编程语言都有 <code>for</code>，JavaScript 也不例外。</p><p>在 JavsScript 中，<code>for</code> 广泛用于遍历数组中，也能用于遍历对象的属性。</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ([initialization]; [condition]; [final-expression])</span><br><span class="line">   statement</span><br></pre></td></tr></table></figure><p><code>initialization</code> 是初始化语句，通常用于初始化计数变量（比如，你们最爱的 <code>i</code>）；<code>condition</code> 是判断本次是否执行 <code>statement</code>；<code>final-expression</code> 在 <code>statement</code> 执行完后执行，通常用于对计数变量进行变换。</p><p>例如，要遍历一个数组 <code>arr</code>，那么可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">  ;<span class="comment">// 做你爱做的事</span></span><br><span class="line">  <span class="comment">// arr[i] 就能在每一次运行过程中取到在 arr 中的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者经常见到所谓的性能优化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=arr.length; i&lt;len; i++) &#123;</span><br><span class="line">  ;<span class="comment">// 做你爱做的事</span></span><br><span class="line">  <span class="comment">// arr[i] 就能在每一次运行过程中取到在 arr 中的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>强烈建议使用 <code>const</code> 或 <code>let</code> 声明变量而不是使用 <code>var</code>，因为 <code>var</code> 会在 <code>for</code> 语句外声明变量，结果就是变量可能会在意外的地方被读取到。如果你不能使用 ES2015 或更新的版本，下文同样有解决方法（同样是本文的主要内容）。</p></blockquote><p>如果你写过 C 系列，那么你有可能忍不住自己的麒麟臂，写出「炫技」的代码来。比如 MDN 上的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for" target="_blank" rel="noopener">这个例子</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showOffsetPos</span>(<span class="params">sId</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> nLeft = <span class="number">0</span>, nTop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> oItNode = <span class="built_in">document</span>.getElementById(sId); <span class="comment">/* initialization */</span></span><br><span class="line"></span><br><span class="line">      oItNode; <span class="comment">/* condition */</span></span><br><span class="line"></span><br><span class="line">    nLeft += oItNode.offsetLeft, nTop += oItNode.offsetTop, oItNode = oItNode.offsetParent <span class="comment">/* final-expression */</span></span><br><span class="line"></span><br><span class="line">  ); <span class="comment">/* semicolon */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Offset position of \''</span> + sId + <span class="string">'\' element:\n left: '</span> + nLeft + <span class="string">'px;\n top: '</span> + nTop + <span class="string">'px;'</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Example call: */</span></span><br><span class="line"></span><br><span class="line">showOffsetPos(<span class="string">'content'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// "Offset position of "content" element:</span></span><br><span class="line"><span class="comment">// left: 0px;</span></span><br><span class="line"><span class="comment">// top: 153px;"</span></span><br></pre></td></tr></table></figure><p>这么写看着很酷，但是实际上不要这样写，尤其是在团队合作中。这样的代码一是混杂难懂，二是难以维护。代码首先是写给人看的，接着才是给机器运行的。</p><p>或许你已经非常习惯写 <code>for</code> 了，习惯到了看见一个数组就自然而然打出 <code>for (...)</code> 来。但是你有没有想过，很多时候，遍历数组其实跟索引并没有什么关系，代码只是要将数组里面的元素按顺序处理完。然而，<strong>数组天然就应该是顺序的</strong>，根本无需要一个额外的 <code>i</code> 来保证。换句话说，数组应该利用自身属性，提供无需索引的顺序读取方法，而索引只是在顺序读取的过程中的一个记录变量。</p><p>那这样有什么优势呢？</p><p>从处理流程上说，举个例子：假设你是一个接待员，工作是处理一列队伍的咨询。使用 <code>for</code> 的处理方法是：先计算整个队伍的长度，然后喊第一个人开始处理；每处理完一个人，就将序号加一再喊；直到序号等于队伍长度。而使用直接顺序读取的处理方法是：从队伍最前开始处理，每处理完一个，直接转到下一个重新开始处理，直到队伍没有下一个需要处理。这样以来就能省去了对队伍长度和索引的处理。</p><p>从代码逻辑上说，在数组上提供顺序读取方法，是将全局的语法转化为了相当于成员函数的执行，解除了和全局的耦合的同时，结合链式调用和灵活的回调函数能解放出极大的数组处理潜力。你能轻松在一行代码内基于数组进行非常多而灵活的处理，并且将「肮脏」的处理过程隐藏起来，直接得到一个处理得「连你阿妈都唔识」的结果，干净利落。</p><p>下面来认识一下这些顺序读取方法吧。</p><h2 id="优雅的-forEach-map-filter-reduce"><a href="#优雅的-forEach-map-filter-reduce" class="headerlink" title="优雅的 forEach, map, filter, reduce"></a>优雅的 forEach, map, filter, reduce</h2><p><img src="https://i.imgflip.com/1y3h2m.jpg" alt="forEach,map,filter,reduce"></p><p>在 ES5（ES5.1） 中，JavaScript 新增了多个数组方法，包括：forEach, map, filter, reduce。</p><p>每个方法都接受一个回调函数作为参数传入，每个方法都会在取得一个元素的时候调用此回调函数，不同在于不同方法对待回调函数的结果上。</p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>forEach 返回值为 undefined，适合通过数组来操作其他对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//your iterator</span></span><br><span class="line">&#125;[, thisArg]);</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 返回值为回调函数返回值组成的数组，适合处理数组变换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> new_array = arr.map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Return element for new_array</span></span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter 返回值为回调函数返回真所对应的元素组成的数组，适合处理数组筛选。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> new_array = arr.filter(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Return true or false</span></span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>reduce 返回值为初始值经过和每个元素作用后得到的最终值，适合遍历数组后得到一个值或者一个对象的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> new_array = arr.reduce(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">accumulator, currentValue, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Return accumulator</span></span><br><span class="line">&#125;[, initialValue])</span><br></pre></td></tr></table></figure><blockquote><p>别忘了在回调函数中返回结果！</p></blockquote><h2 id="新方法新思路"><a href="#新方法新思路" class="headerlink" title="新方法新思路"></a>新方法新思路</h2><p>配合几个编写代码时的常见场景，看看不使用 <code>for</code> 的解决方法。</p><h3 id="循环多次执行某些动作"><a href="#循环多次执行某些动作" class="headerlink" title="循环多次执行某些动作"></a>循环多次执行某些动作</h3><p>给定一个数组，打印其元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>for</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])  <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>炫技</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (</span><br><span class="line">  <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">  i&lt;arr.length;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i++])</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>改写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="params">el</span> =&gt;</span> <span class="built_in">console</span>.log(el))  <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><h3 id="对数组的每一个元素进行变换"><a href="#对数组的每一个元素进行变换" class="headerlink" title="对数组的每一个元素进行变换"></a>对数组的每一个元素进行变换</h3><p>给定一个数组，将其元素都加一。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>for</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">  arr[i] = arr[i] + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>炫技</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (</span><br><span class="line">  <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">  i&lt;arr.length;</span><br><span class="line">  arr[i] = arr[i++] + <span class="number">1</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>改写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function">(<span class="params">el, i, ar</span>) =&gt;</span> ar[i] = ar[i] + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>更好</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArr = arr.map(<span class="function"><span class="params">el</span> =&gt;</span> el + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>在允许的情况下尽量不要去修改原数据，而是返回一个新的数组。</p></blockquote><h3 id="提取数组中符合某个标准的元素"><a href="#提取数组中符合某个标准的元素" class="headerlink" title="提取数组中符合某个标准的元素"></a>提取数组中符合某个标准的元素</h3><p>给定一个数组，筛选出大于 2 的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>for</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr[i] &gt; <span class="number">2</span>) &#123;  <span class="comment">// e.g. should be larger than 2</span></span><br><span class="line">    newArr.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArr = arr.filter(<span class="function"><span class="params">el</span> =&gt;</span> el &gt; <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="使用数组生成新数组"><a href="#使用数组生成新数组" class="headerlink" title="使用数组生成新数组"></a>使用数组生成新数组</h3><p>给定一个数组，要求使用其元素内容作为键，元素下表作为值，生成一个新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><p>for</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">  obj[arr[i]] = i</span><br><span class="line">  newArr.push(obj)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// can access 'i' and 'obj' here</span></span><br></pre></td></tr></table></figure><p>改写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">el, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">  obj[el] = i</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// cannot access 'obj' here, hell yeah!</span></span><br></pre></td></tr></table></figure><p>ES2015</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArr = arr.map(<span class="function">(<span class="params">el, i</span>) =&gt;</span> &#123; <span class="keyword">return</span> &#123; [el]: i &#125; &#125;)</span><br><span class="line"><span class="comment">// less code in one line! fuck yeah!</span></span><br></pre></td></tr></table></figure><h3 id="遍历数组，得到一个最终值"><a href="#遍历数组，得到一个最终值" class="headerlink" title="遍历数组，得到一个最终值"></a>遍历数组，得到一个最终值</h3><p>给定一个数字数组，将其包含的数字累加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>for</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">  result += arr[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = arr.reduce(<span class="function">(<span class="params">ret, el</span>) =&gt;</span> ret + el, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>给定一个键值数组，将其转换为一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="string">'a'</span>, <span class="attr">value</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="string">'b'</span>, <span class="attr">value</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="string">'c'</span>, <span class="attr">value</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="string">'d'</span>, <span class="attr">value</span>: <span class="number">4</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>for</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">  result[arr[i].key] = arr[i].value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = arr.reduce(<span class="function">(<span class="params">obj, &#123; key, value &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  obj[key] = value</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure><p>从以上例子中可以看到，ES2015 的代码更加清晰可读，而且代码打起来流畅省时（你自己试试！）。如果你还没使用上 ES6，那么应该赶紧去学！或许<a href="https://www.wintellect.com/why-you-should-be-writing-ecma-script-6-now/" target="_blank" rel="noopener">这篇文章</a>和<a href="https://thenextweb.com/dd/2016/03/09/6-reasons-need-learn-javascript-es6-now-not-later/" target="_blank" rel="noopener">这篇文章</a>能说服你。</p><p>也可以看看本人写的 <a href="https://raw.githubusercontent.com/exoticknight/blog-post/master/%E3%80%8AUnderstanding%20ECMAScript%206%E3%80%8B%E7%AC%94%E8%AE%B0.md" target="_blank" rel="noopener">《Understanding ECMAScript 6》笔记</a>。</p><h2 id="不灭的-for"><a href="#不灭的-for" class="headerlink" title="不灭的 for"></a>不灭的 for</h2><p>尽管数组新增的方法十分强大，但是 <code>for</code> 除了会在遍历数组中使用，还会在处理对象的时候使用，比如使用 <code>for...in</code> 遍历对象的属性（及其原型上的属性）。在这些场合上，就需要具体情况具体分析了。</p><h3 id="遍历对象问题"><a href="#遍历对象问题" class="headerlink" title="遍历对象问题"></a>遍历对象问题</h3><p>给出 app 的版本以及版本的使用量，统计最新两个大版本的使用量。版本命名符合 semver 标准，形如 ‘x.x.x’。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> apps = &#123;</span><br><span class="line">  <span class="string">'6.6.0'</span>: <span class="number">53695</span>,</span><br><span class="line">  <span class="string">'6.10.0'</span>: <span class="number">47319</span>,</span><br><span class="line">  <span class="string">'5.4.0'</span>: <span class="number">42601</span>,</span><br><span class="line">  <span class="string">'5.8.5'</span>: <span class="number">41320</span>,</span><br><span class="line">  <span class="string">'5.5.5'</span>: <span class="number">40322</span>,</span><br><span class="line">  <span class="string">'5.8.1'</span>: <span class="number">38509</span>,</span><br><span class="line">  <span class="string">'5.1.5'</span>: <span class="number">26473</span>,</span><br><span class="line">  <span class="string">'5.2.1'</span>: <span class="number">24267</span>,</span><br><span class="line">  <span class="string">'6.10.1'</span>: <span class="number">17042</span>,</span><br><span class="line">  <span class="string">'5.8.0'</span>: <span class="number">13878</span>,</span><br><span class="line">  <span class="string">'5.5.1'</span>: <span class="number">12887</span>,</span><br><span class="line">  <span class="string">'5.1.0'</span>: <span class="number">9836</span>,</span><br><span class="line">  <span class="string">'6.5.0'</span>: <span class="number">8909</span>,</span><br><span class="line">  <span class="string">'5.0.0'</span>: <span class="number">6704</span>,</span><br><span class="line">  <span class="string">'4.7.0'</span>: <span class="number">5915</span>,</span><br><span class="line">  <span class="string">'4.5.0'</span>: <span class="number">5300</span>,</span><br><span class="line">  <span class="string">'4.3.0'</span>: <span class="number">4213</span>,</span><br><span class="line">  <span class="string">'5.7.0'</span>: <span class="number">4000</span>,</span><br><span class="line">  <span class="string">'4.6.1'</span>: <span class="number">3647</span>,</span><br><span class="line">  <span class="string">'4.4.0'</span>: <span class="number">1921</span>,</span><br><span class="line">  <span class="string">'4.6.0'</span>: <span class="number">1802</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> largest = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> versions = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> apps) &#123;</span><br><span class="line">  <span class="keyword">const</span> major = <span class="built_in">parseInt</span>(key.split(<span class="string">'.'</span>)[<span class="number">0</span>], <span class="number">10</span>)</span><br><span class="line">  <span class="keyword">if</span> (!versions[major]) &#123;</span><br><span class="line">    versions[major] = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  versions[major][key] = apps[key]</span><br><span class="line"></span><br><span class="line">  largest = largest &lt; major ? major : largest</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newApps = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.assign(newApps, versions[largest-i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES2015</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> largest = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> versions = <span class="built_in">Object</span>.keys(apps).reduce(<span class="function">(<span class="params">obj, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> major = <span class="built_in">parseInt</span>(key.split(<span class="string">'.'</span>)[<span class="number">0</span>], <span class="number">10</span>)</span><br><span class="line">  <span class="keyword">if</span> (!obj[major]) &#123;</span><br><span class="line">    obj[major] = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj[major][key] = apps[key]</span><br><span class="line"></span><br><span class="line">  largest = largest &lt; major ? major : largest</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line"><span class="keyword">const</span> newApps = [...Array(<span class="number">2</span>).keys()].map(<span class="function"><span class="params">x</span> =&gt;</span> largest - x).reduce(<span class="function">(<span class="params">obj, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(obj, versions[key])</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure><p>使用 <code>for</code> 和不使用 <code>for</code>相比，相差不大，甚至代码看起来更清晰，而且有 ES2015 的加成，消除了变量泄露的影响。所以如果是遍历对象，就没必要去用数组的方法了。</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>截止目前位置（2017-10-17），从 <a href="https://jsperf.com/for-vs-foreach-vs-for-of" target="_blank" rel="noopener">benchmark</a> 来看，在性能上，<code>for</code> &gt; <code>forEach</code> &gt; <code>for...of</code>。</p><p>因此在一些对性能要求比较高的代码中，使用 <code>forEach</code> 和 <code>for...of</code> 需要谨慎，这有可能会成为性能瓶颈。另外 <code>for...of</code> 在浏览器上的支持度不高，所以还是可以暂时不使用，除非你清楚自己在干什么。</p><p>不过，仍然是那句话，代码首先是写给人看的，性能优化应该在功能实现之后再考虑。</p><h3 id="循环中断问题"><a href="#循环中断问题" class="headerlink" title="循环中断问题"></a>循环中断问题</h3><p>一般来说，使用 <code>for</code> 和使用数组方法在功能实现上是一样的，但是由于 <code>for</code> 是编程语言层面的实现，可以使用 <code>break</code> 和 <code>return</code> 手段进行中断；上文中的数组方法由于是遍历调用函数，并不存在什么停止的条件，因此肯定是会将所有元素都过一遍。在这种情况下，就乖乖使用 <code>for</code> 吧。</p><blockquote><p>当然也可以使用 <code>Array.some</code> 等方法模拟中断效果，但要是那样做还不如直接 <code>for</code> 呢。</p></blockquote><h3 id="Promise-的问题"><a href="#Promise-的问题" class="headerlink" title="Promise 的问题"></a>Promise 的问题</h3><p>使用数组方法时，最容易出错的地方是和 Promise 一起使用的时候。</p><p>比如需要从不同的 URL 请求数据，极其容易写成以下<strong>错误的</strong>代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> URLs = [</span><br><span class="line">  <span class="string">'http://www.a.com'</span>,</span><br><span class="line">  <span class="string">'http://www.b.com'</span>,</span><br><span class="line">  <span class="string">'http://www.c.com'</span>,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> results = URLs.map(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> $.ajax(url)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你会发现 <code>results</code> 的内容只是 Promise 实例，根本不是期望的值。代码的问题在于几乎所有的网络请求 API，返回的都是一个 Promise 实例。</p><p>正确的做法是使用 <code>Promise.all</code> 将多个 Promise 实例包装成一个 Promise 实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> URLs = [</span><br><span class="line">  <span class="string">'http://www.a.com'</span>,</span><br><span class="line">  <span class="string">'http://www.b.com'</span>,</span><br><span class="line">  <span class="string">'http://www.c.com'</span>,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> result</span><br><span class="line"><span class="built_in">Promise</span>.all(URLs.map(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> $.ajax(url)</span><br><span class="line">&#125;)).then(<span class="function"><span class="params">res</span> =&gt;</span> result = res)</span><br></pre></td></tr></table></figure><p>如果你使用 async／await，<strong>千万不要这样写</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> URLs = [</span><br><span class="line">  <span class="string">'http://www.a.com'</span>,</span><br><span class="line">  <span class="string">'http://www.b.com'</span>,</span><br><span class="line">  <span class="string">'http://www.c.com'</span>,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> results = URLs.map(<span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> $.ajax(url)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>同样这种写法只能得到一个 Promise 实例数组。应该这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> URLs = [</span><br><span class="line">  <span class="string">'http://www.a.com'</span>,</span><br><span class="line">  <span class="string">'http://www.b.com'</span>,</span><br><span class="line">  <span class="string">'http://www.c.com'</span>,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(URLs.map(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> $.ajax(url)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 注意你不能在没有 <code>async</code> 标识的函数中使用 <code>await</code>，因此在各种全局状态下是无法使用 <code>await</code> 的。幸好 async／await 处理的就是 Promise，你只需要改用 <code>.then</code> 就好了。</p></blockquote><p>举一个更极端的例子，URL 请求需要按顺序发送，上一次的结果需要作为下一次请求的参数。怎么写呢？</p><p>Promise 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> URLs = [</span><br><span class="line">  <span class="string">'http://www.a.com'</span>,</span><br><span class="line">  <span class="string">'http://www.b.com'</span>,</span><br><span class="line">  <span class="string">'http://www.c.com'</span>,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> result</span><br><span class="line">URLs</span><br><span class="line">.map(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> $.ajax(url + params)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> prev.then(next)</span><br><span class="line">&#125;, <span class="built_in">Promise</span>.resolve(<span class="string">''</span>))</span><br><span class="line">.then(<span class="function"><span class="params">ret</span> =&gt;</span> result = ret)</span><br></pre></td></tr></table></figure><p>async／await 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> URLs = [</span><br><span class="line">  <span class="string">'http://www.a.com'</span>,</span><br><span class="line">  <span class="string">'http://www.b.com'</span>,</span><br><span class="line">  <span class="string">'http://www.c.com'</span>,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> URLs.map(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> $.ajax(url + params)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> prev.then(next)</span><br><span class="line">&#125;, <span class="built_in">Promise</span>.resolve(<span class="string">''</span>))</span><br></pre></td></tr></table></figure><p>但是看看用 <code>for</code> 会如何？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> URLs = [</span><br><span class="line">  <span class="string">'http://www.a.com'</span>,</span><br><span class="line">  <span class="string">'http://www.b.com'</span>,</span><br><span class="line">  <span class="string">'http://www.c.com'</span>,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> result</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> url <span class="keyword">of</span> URLs) &#123;</span><br><span class="line">  result = <span class="keyword">await</span> $.ajax(url + result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意外的简洁。这归功于数组的有序性，以及 <code>for</code> 在语言层面上的可被打断性。</p><p>可见在处理顺序的异步请求上，<code>for</code> 有着很大的优势，但在并发请求上，还是乖乖用 <code>.map</code> 吧（比 <code>for</code> + <code>.push</code> 要好）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;No Silver Bullet&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;老黄牛的-for&quot;&gt;&lt;a href=&quot;#老黄牛的-for&quot; class=&quot;headerlink&quot; title=&quot;老黄牛的 for&quot;&gt;&lt;/a&gt;老黄牛的 for&lt;/h
      
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="技术" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="前端" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/"/>
    
    
      <category term="javascript" scheme="https://blog.e10t.net/tags/javascript/"/>
    
      <category term="bytalk" scheme="https://blog.e10t.net/tags/bytalk/"/>
    
  </entry>
  
  <entry>
    <title>Mocha + Chai + istanbul in ES2015</title>
    <link href="https://blog.e10t.net/mocha-chai-istanbul-in-es2015/"/>
    <id>https://blog.e10t.net/mocha-chai-istanbul-in-es2015/</id>
    <published>2017-08-06T07:20:41.000Z</published>
    <updated>2017-08-06T07:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 JavaScript 写代码的时候，无论是使用 TDD 方法还是为了保证代码的质量和可维护性，都应该考虑加上单元测试。在博文 <a href="https://blog.e10t.net/mocha-chai-travis-ci-codecov-workflow/">mocha + chai + Travis CI + Codecov 使用流程</a> 中有简单地介绍了如何使用流行的 JavsScript 库来对代码进行自动测试，检查代码覆盖率。</p><p>在那篇文章中，使用的是 Mocha／Chai／istanbul 和在线的 Codecov，以及和 Github 关系密切的 Travis CI，而且测试的 JavaScript 代码是 es5。现在 es2015 已经标准化了，那么教程也需要更新一下了。另外如果项目是私有项目，那么还是使用完备的离线测试环境比较好。接下来就是一个快速可行的教程。</p><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>测试框架无需变更，还是 Mocha + Chai 的组合，但是 istanbul 需要稍微变动一下。</p><blockquote><p>如果你不需要 istanbul 做覆盖率测试，那么需要使用 <code>npm install --save-dev babel-register</code> 和 <code>mocha --require babel-register</code> 使 mocha 能识别 es2015 的代码</p></blockquote><p>使用新套件，直接安装 <code>npm i -S mocha chai cross-env nyc babel-plugin-istanbul babel-register babel-preset-env</code>。</p><p>mocha 和 chai 不用解释了，<code>nyc</code> 可以理解是 istanbul 的命令行工具；<code>babel-plugin-istanbul</code> 是在 babel 中插入 istanbul，<code>babel-register</code> 是 istanbul 使用的 babel 接口，这样两个库就打通了；最后 <code>babel-preset-env</code> 是 babel 的运行配置。</p><p>先来配置 <code>babel-plugin-istanbul</code>，新建 <code>.babelrc</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    <span class="string">"env"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"env"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: &#123;</span><br><span class="line">      <span class="string">"plugins"</span>: [ <span class="string">"istanbul"</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>presets</code> 配置告诉 babel 使用 <code>babel-preset-env</code>。当然也可以用 ‘es2015’ + ‘stage-0’ 的组合，具体可以自行斟酌。</p><p><code>env.test.plugins</code> 告诉 babel 在 <code>NODE_ENV=test</code> 的情况下使用插件 <code>babel-plugin-istanbul</code>。</p><p>接下来配置 <code>babel-register</code>，新建 <code>.nycrc</code>：</p><blockquote><p><code>.nycrc</code> 是 nyc 的配置文件，和 <code>.babelrc</code> 类似，当然配置也是可以直接写进 <code>package.json</code> 的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"require"</span>: [</span><br><span class="line">    <span class="string">"babel-register"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"reporter"</span>: [</span><br><span class="line">    <span class="string">"lcov"</span>,</span><br><span class="line">    <span class="string">"text-summary"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"sourceMap"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"instrument"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的配置直接用了官方的配置。<code>require</code> 字段告诉 nyc 使用 <code>babel-register</code>，<code>reporter</code> 字段的 ‘lcov’ 会让 nyc 生成 <code>lcov.info</code> 文件和对应的 HTML 报告，如果使用 <code>lcovonly</code> 则只生成 ‘lcov.info’。’text-summary’ 则是会在控制台输出覆盖率等信息。</p><blockquote><p>文件会默认生成在 <code>/coverage</code> 下，可以使用 <code>report-dir</code> 字段指定。</p></blockquote><p>最后，在 <code>package.json</code> 中加入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"test"</span>: <span class="string">"cross-env NODE_ENV=test nyc mocha test/**/*.spec.js"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="测试编写事例"><a href="#测试编写事例" class="headerlink" title="测试编写事例"></a>测试编写事例</h2><p>比如有 <code>index.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="string">'a'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么可以写 <code>test/index.spec.js</code>，可以直接上 ES2015 的语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; expect &#125; <span class="keyword">from</span> <span class="string">'chai'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Test &#125; <span class="keyword">from</span> <span class="string">'../index'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'index test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'should be a string'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> test = <span class="keyword">new</span> Test</span><br><span class="line">    expect(test.data).to.be.a(<span class="string">'string'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用 <code>npm test</code> 运行测试，得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; cross-env NODE_ENV=test nyc mocha test/**/*.spec.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  index test</span><br><span class="line">    ✓ should be a string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  1 passing (8ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=============================== Coverage summary ===============================</span><br><span class="line">Statements   : 100% ( 1/1 )</span><br><span class="line">Branches     : 100% ( 0/0 )</span><br><span class="line">Functions    : 100% ( 1/1 )</span><br><span class="line">Lines        : 100% ( 1/1 )</span><br><span class="line">================================================================================</span><br></pre></td></tr></table></figure><h2 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h2><p>在测试中经常需要测试 promise 等异步操作，虽然 Mocha 库是可以使用回调来完成测试的，但是我们当然要用 async／await 啦。</p><p>比如，需要测试 <code>index.js</code> 中的 <code>requestAsync</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="string">'a'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  requestAsync () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">      res(<span class="keyword">this</span>.data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么需要先 <code>npm i -S babel-polyfill babel-plugin-transform-async-to-generator</code>。</p><p>然后配置 <code>.nycrc</code>，加上 ‘babel-polyfill’ 支持 generator 运行时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"require"</span>: [</span><br><span class="line">    <span class="string">"babel-polyfill"</span>,</span><br><span class="line">    <span class="string">"babel-register"</span></span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 <code>.babelrc</code>，加上 ‘transform-async-to-generator’，将 async 模式转换为 generator 模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"env"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: &#123;</span><br><span class="line">      <span class="string">"plugins"</span>: [ <span class="string">"istanbul"</span>, <span class="string">"transform-async-to-generator"</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着这样测试异步：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; expect &#125; <span class="keyword">from</span> <span class="string">'chai'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Test &#125; <span class="keyword">from</span> <span class="string">'../index'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test#requestAsync'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'should get a string'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> test = <span class="keyword">new</span> Test</span><br><span class="line">    <span class="keyword">const</span> ret = <span class="keyword">await</span> test.requestAsync()</span><br><span class="line">    expect(ret).to.be.a(<span class="string">'string'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在测试项 <code>it</code> 的第二个函数前加 ‘async’ 标志异步，然后在返回 promise 的调用前加上 ‘await’，OK。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; cross-env NODE_ENV=test nyc mocha test/**/*.spec.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  test#requestAsync</span><br><span class="line">    ✓ should get a string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  1 passing (14ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=============================== Coverage summary ===============================</span><br><span class="line">Statements   : 100% ( 3/3 )</span><br><span class="line">Branches     : 100% ( 0/0 )</span><br><span class="line">Functions    : 100% ( 3/3 )</span><br><span class="line">Lines        : 100% ( 3/3 )</span><br><span class="line">================================================================================</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 JavaScript 写代码的时候，无论是使用 TDD 方法还是为了保证代码的质量和可维护性，都应该考虑加上单元测试。在博文 &lt;a href=&quot;https://blog.e10t.net/mocha-chai-travis-ci-codecov-workflow/&quot;&gt;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="技术" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="前端" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/"/>
    
    
      <category term="javascript" scheme="https://blog.e10t.net/tags/javascript/"/>
    
      <category term="mocha" scheme="https://blog.e10t.net/tags/mocha/"/>
    
      <category term="chai" scheme="https://blog.e10t.net/tags/chai/"/>
    
      <category term="istanbul" scheme="https://blog.e10t.net/tags/istanbul/"/>
    
      <category term="测试" scheme="https://blog.e10t.net/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>说说牛客上的一道 JavaScript 题目</title>
    <link href="https://blog.e10t.net/talk-about-a-question-in-nowcoder/"/>
    <id>https://blog.e10t.net/talk-about-a-question-in-nowcoder/</id>
    <published>2016-12-13T12:48:11.000Z</published>
    <updated>2016-12-13T12:48:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>牛客上有这么一道 JavaScript 的 <a href="https://www.nowcoder.com/questionTerminal/9c76e58c2ce94eb9b8168b43adef4f50" target="_blank" rel="noopener">题目</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填写内容让下面代码支持 a.name = “name1”; b.name = “name2”;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    【<span class="number">1</span>】</span><br><span class="line">&#125;</span><br><span class="line">obj.【<span class="number">2</span>】 = <span class="string">"name2"</span>;</span><br><span class="line"><span class="keyword">var</span> a = obj(<span class="string">"name1"</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> obj;</span><br></pre></td></tr></table></figure><p>【1】和【2】是填写的内容，【2】的答案是 <code>prototype.name</code>，没争议。</p><p>问题是【1】，参考答案居然是 <code>if(name){ this.name = name;}return this;</code>，这么随便地玩弄 <code>this</code> 不就是明摆着污染全局变量吗？暴力赋值不可取。</p><p>下面的一些高票讨论还说了一大堆解释的废话，连他自己都说自己好罗嗦。对，你不但罗嗦，而且还没有改错。注释里都说了给 window 的属性赋值，还不自知出问题，真是误人子弟。</p><p>先来分析一下题目，a 和 b 都从 obj 来，为什么同名的属性值不一样？可以看出，是对 obj 这个函数的调用方式不一样，a 是 obj 函数的调用结果，而 b 则是 obj 作为 <em> 构造函数 </em> 调用的结果。所以这题的重点应该是如何区分<em>函数调用</em>和<em>构造函数调用</em>。</p><p>一个关键字 <code>new</code> 决定了不同。<code>new</code> 的作用是什么呢？<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">MDN</a> 上说了，面试也会考你的，简单来说是三步，<code>new foo</code>：</p><ol><li>生成一个继承于 foo.prototype 的对象</li><li>foo 会被调用，其中的 <code>this</code> 值会被绑定为 1 中的对象</li><li>如果 foo 没有返回一个对象（注意是对象！），则返回 1 的对象</li></ol><p>从 2 就可以看出 <code>this</code> 值会被 <code>new</code> 绑定为一个确定的对象，而不是像普通函数调用中那样自己不可预料，要看上下文的进程。</p><p>于是就可以在这里做文章。先来判断 <code>this</code> 的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> obj) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>instanceof</code> 会检查 <code>this</code> 的原型链上是否存在 <code>foo.prototype</code>。也就是说能判断是否满足第 1 条，确保了对象能从 <code>prototype</code> 中读取到 <code>name</code> 属性。（毕竟代码中并没有给 b 的赋值中传入）</p><blockquote><p><code>instanceof</code> 并不是完美的判断方法，但是在这里足够了，后面会谈到这个问题。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> obj) &#123;</span><br><span class="line">    <span class="comment">// new 调用</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非 new 调用</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非 new 调用的情况下，直接返回一个新对象就 OK 了。</p><p>而在 new 调用的情况下，可以看到 <code>function obj(name)</code> 定义的时候是有参数的，调用的时候却没参数，这就要小心了，为了安全起见，还是判断一下为妙。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> obj) &#123;</span><br><span class="line">    <span class="comment">// new 调用</span></span><br><span class="line">    <span class="keyword">if</span> (name !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非 new 调用</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，判断会写成 <code>if (name)</code>，但是碰到 <code>null</code>、<code>0</code>、<code>false</code> 就 GG 了，所以还是谨慎点吧。</p><p>问题到这里就可以比较完美地解答了。</p><h2 id="bonus-instanceof-的问题"><a href="#bonus-instanceof-的问题" class="headerlink" title="bonus: instanceof 的问题"></a>bonus: instanceof 的问题</h2><p>『<code>instanceof</code> 会检查 <code>this</code> 的原型链上是否存在 <code>foo.prototype</code>』，为什么说得这么拗口，是因为需要表达出 <code>instanceof</code> 本来就不是真的用来检测是否调用 <code>new</code> 的方法。</p><p>在题目里面，要求的是 a 需要从原型链上读取到特定的属性值，所以 <code>instanceof</code> 的作用刚好在这里能符合要求而已。</p><p>函数调用除了题目中的方法还有第三种方法，那就是 <code>foo.call</code>、<code>foo.apply</code>，而且也能为函数指定 <code>this</code> 的值（所以还有 <code>bind</code>）。因此是存在方法调戏 <code>instanceof</code> 的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo.prototype.name = <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">var</span> midman = <span class="keyword">new</span> foo(<span class="string">'fake foo'</span>)</span><br><span class="line"><span class="keyword">var</span> a = foo.call(midman)</span><br><span class="line"><span class="keyword">var</span> b = foo.call(midman, <span class="string">'b'</span>)</span><br><span class="line">a  <span class="comment">// undefined, WTF?!</span></span><br><span class="line">b  <span class="comment">// undefined, WTF?!</span></span><br></pre></td></tr></table></figure><p>这里的 <code>foo</code> 调用的方式是作为函数来调用，但是为 <code>this</code> 绑定的值是从 <code>foo</code> 上 <code>new</code> 出来的，换句话说，其原型链上存在 <code>foo.prototype</code>，于是就骗过了 <code>instanceof</code>。</p><p>于是 ES2015 来搭救你了，新增了一个 <code>new.target</code>。于是修改成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>.target !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// new 调用</span></span><br><span class="line">    <span class="keyword">if</span> (name !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非 new 调用</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;牛客上有这么一道 JavaScript 的 &lt;a href=&quot;https://www.nowcoder.com/questionTerminal/9c76e58c2ce94eb9b8168b43adef4f50&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="技术" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="黑客" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/%E9%BB%91%E5%AE%A2/"/>
    
      <category term="javascript" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/"/>
    
    
      <category term="javascript" scheme="https://blog.e10t.net/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>FictionInjection-始动：Angular 依赖注入分析和源码抽取改造（上）</title>
    <link href="https://blog.e10t.net/fictioninjection-series-analyze-angular-dependence-injection-and-extract-it-part-1/"/>
    <id>https://blog.e10t.net/fictioninjection-series-analyze-angular-dependence-injection-and-extract-it-part-1/</id>
    <published>2016-05-12T05:56:53.000Z</published>
    <updated>2016-11-08T07:58:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>几年前有一个项目构思，由于技术水平低，当时并没有思考得很清楚，所以一直没怎么着手开始。近来前端很多优秀的库出现了，也让我对那个项目有了新的想法。在写了几个 JavaScript 的项目后我觉得可以尝试开始了。尝试并成功写出一些代码之后，就开（挖）始（坑）了这个系列的博文。</p><p>项目是写一个 JavaScript 框架，干什么的在此并不是重点，但是首先需要一个可扩展的模块系统。最简单就是直接用 jQuery 扩展的写法，直接将函数等的挂载在一个对象下，不过如此一来模块之间依赖非常多的话，管理起来会十分困难。也可以使用 AMD / CMD 的模块化的方法，不过考虑到 ES2015 已经加入了 import / export 的语法，最好就直接使用。然而使用了 ES2015 的语法之后，仍然使用 AMD 等的语法就显得很别扭，但是又想要依赖注入功能怎么办？</p><p>解决方法是模（fu）仿（zhi）著名的 AngularJS 中关于依赖注入的源代码。</p><p>Angular 有两个版本，1.x 和 2.x，但是 2.x 中，淡化了模块的概念，直接采用 component 和 ES2015 的 import / export 的机制，所以依赖注入已经不太算是亮点了。而且 Angular2 采用 TypeScript 编写，从语法编写上也不适合作为参考。最后选定 1.4.5 版本。</p><blockquote><p>Angular 项目下还有一个不怎么有人知道的 <code>di.js</code> 项目，是从 Angular 中独立出来的依赖注入库，但是从文档来看，也是需要 TypeScript 来使用。</p></blockquote><p>文章较长，给个目录</p><p><a name="catalogue"></a></p><ul><li><a href="#di">实现依赖注入</a></li><li><a href="#api">从 API 入手</a></li><li><a href="#analyze">开始分析</a></li><li><a href="#wrapup">统一包装</a></li><li><a href="#brief">小结</a></li><li><a href="#injector">注入器的奥秘</a></li><li><a href="#unexpected">读源码的意外发现</a></li></ul><p><a name="di"></a></p><h2 id="实现依赖注入↑"><a href="#实现依赖注入↑" class="headerlink" title="实现依赖注入↑"></a>实现依赖注入<a href="#catalogue">↑</a></h2><p>JavaScript 如何实现依赖注入呢？AngularJS 给出了三个解决方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接在参数里面声明</span></span><br><span class="line"><span class="built_in">module</span>.service( <span class="function"><span class="keyword">function</span> (<span class="params"> $http </span>) </span>&#123;&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用显示注释</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">a.$inject = [<span class="string">'$http'</span>]</span><br><span class="line"><span class="built_in">module</span>.service( a )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组内联</span></span><br><span class="line"><span class="built_in">module</span>.service( [<span class="string">'$http'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"> http </span>) </span>&#123;&#125;] )</span><br></pre></td></tr></table></figure><p>实际上三个方式都是一样的，只是使用方式不一样，最后都是使用了 JavaScript 的闭包来实现依赖的注入，原理如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span> (<span class="params"> $http </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"> args </span>) </span>&#123;</span><br><span class="line">        <span class="comment">// $http.get( args )</span></span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将依赖作为参数传入 <code>menthod</code> 得到的返回值就是是一个可以调用 <code>$http</code> 服务的函数了。</p><p>像这样 <code>[&#39;$http&#39;, function ( http ) {}]</code> 最后一个元素是函数的结构可以称为一个<strong>‘可注入结构’</strong>。</p><p><a name="api"></a></p><h2 id="从-API-入手↑"><a href="#从-API-入手↑" class="headerlink" title="从 API 入手↑"></a>从 API 入手<a href="#catalogue">↑</a></h2><p>Angular 库的源代码文件非常大，一般基本不会从头开始看。而 API 作为库对外的窗口，从 API 的使用顺藤摸瓜地查找代码是比较好的做法。Angular 模块的使用一般如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare module</span></span><br><span class="line"><span class="keyword">const</span> a = angular.module( <span class="string">'a'</span>, [] );</span><br><span class="line"><span class="keyword">const</span> b = angular.module( <span class="string">'b'</span>, [] );</span><br><span class="line"><span class="keyword">const</span> c = angular.module( <span class="string">'c'</span>, [<span class="string">'a'</span>] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// use the module</span></span><br><span class="line">a</span><br><span class="line">.value( <span class="string">'a'</span>, <span class="number">123</span> )</span><br><span class="line">.factory( <span class="string">'a'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">123</span>; &#125; )</span><br><span class="line">.service( <span class="string">'serviceName'</span>, ... )</span><br><span class="line">.directive( <span class="string">'directiveName'</span>, ... )</span><br><span class="line">.filter( <span class="string">'filterName'</span>, ... );</span><br></pre></td></tr></table></figure><p>先创建一个模块，用数组说明它的依赖模块，然后模块就可以调用 <code>value</code>、<code>service</code>、<code>directive</code> 等 API，API 的第一个参数是名字，第二个参数则是值或者函数或者数组，了解 AngularJS 的读者应该知道其实是值或者返回值的构造函数或者包含依赖和构造函数的数组。</p><p>打开 Angular.js ，查找出 <code>module(name, requires, configFn)</code> 函数的定义，位于一个更大的函数 <code>setupModuleLoader</code> 内。<code>setupModuleLoader</code> 为 <code>module</code> 函数编写了一些检测函数和变量。最重要的是 <code>modules</code> 变量，用来保存所有的模块信息。</p><p>下面来分析 <code>module</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (requires &amp;&amp; modules.hasOwnProperty(name)) &#123;</span><br><span class="line">  modules[name] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出如果模块重复创建是会覆盖之前的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;angular.Module&#125;</span> </span>*/</span></span><br><span class="line"><span class="keyword">var</span> moduleInstance = &#123;</span><br></pre></td></tr></table></figure><p><code>moduleInstance</code> 就是将会返回出去的模块对象，可以看到里面有 <code>name</code> 和 <code>requires</code> 等属性和 <code>provider</code> 和 <code>factory</code> 等函数。</p><p>里面所有的方法，都是通过调用 <code>invokeLater</code> 和 <code>invokeLaterAndSetModuleName</code> 生成的新函数。新函数的上下文中带有 <code>provider</code> 和 <code>method</code> 信息。比如 <code>service</code> 函数：provider=’$provide’，method=’service’，暂时还看不出来信息有什么用，可以先跳过。新函数在调用的时候会将信息连同调用的参数一起 push 进模块的 <code>_invokeQueue</code> 属性中。</p><p>绕了一大圈，就是知道了：在调用 <code>value</code>、<code>service</code>、<code>provider</code> 这些基本的模块功能函数的时候，其实只是将构造函数和相关信息先保存了下来，根本就没有做初始化模块等工作。</p><p>但是作为一个库必定需要跟 <code>window</code> 或者 <code>document</code> 产生点关系不然无法操作 DOM，根据编写过不少库的经验来看，通常将这样的代码放在最后。于是拉到最后一看，gotcha。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jqLite(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  angularInit(<span class="built_in">document</span>, bootstrap);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>明显意思就是在文档准备完毕的时候调用 <code>angularInit</code>，转到 <code>angularInit</code> 的定义发现调用了 <code>bootstrap(appElement, module ? [module] : [], config);</code>，再转到 <code>bootstrap</code> 的定义，在函数内部又会调用 <code>doBootstrap</code> 函数，一系列的检查之后，调用了 <code>createInjector</code> 函数就结束了，转到 <code>createInjector</code> 的定义一看，有 <code>$provide</code> <code>factory</code> 等字样，说明找对地方了。</p><p><a name="analyze"></a></p><h2 id="开始分析↑"><a href="#开始分析↑" class="headerlink" title="开始分析↑"></a>开始分析<a href="#catalogue">↑</a></h2><p>重点来分析 <code>createInjector</code> 函数。</p><p>函数体大概可以分成四段。</p><p>第一段是定义了 <code>providerCache</code>、<code>instanceCache</code>、<code>providerInjector</code> 和 <code>instanceInjector</code>。最后返回 <code>instanceInjector</code> 对象。<code>providerInjector</code> 和 <code>instanceInjector</code> 各为将 <code>providerCache</code> 和 <code>instanceCache</code> 传入 <code>createInternalInjector</code> 函数的返回值。</p><p>第二段是 provider 函数的定义，用以供初始化时候的调用。</p><p>第三段是 <code>loadModules</code> 函数的定义，作用是，显然，初始化模块。</p><p>第四段是 <code>createInternalInjector</code> 函数的定义，函数返回的是真正的注入器。</p><p>从第一段的代码来看，真正的工作是在 <code>loadModules</code> 函数中，因为 <code>createInternalInjector</code> 函数只返回一个对象，没有 ‘side effect’ 的代码。</p><p><code>loadModules</code> 函数上来就是一个对模块数组的遍历，然后在遍历内取模块的属性 <code>_invokeQueue</code> 来调用 <code>runInvokeQueue</code> 函数对已经缓存下来的对象或方法的构造函数进行处理。</p><p>值得注意的是在做调用 <code>runInvokeQueue</code> 前，有一个递归的调用 <code>loadModules(moduleFn.requires)</code>，表明了在初始化本模块之前，会先初始化依赖的模块。</p><p>到目前为止，可以判明模块初始化的分两个阶段，第一个是：声明模块及其依赖模块 -&gt; 缓存模块变量的构造函数；第二个是：选取一个根模块（对应 AngularJS 中的 ‘app’ 模块） -&gt; 找出其依赖的模块，对于每一个依赖，递归地先初始化其依赖的模块，再初始化自身 -&gt; 处理模块中缓存的变量的构造函数。</p><p>如此采取先缓存所有模块再通过依赖树来初始化的做法虽然看起来繁琐，但是得到一个重要的特性就是声明模块的时候不用关注依赖的顺序，只需要表明依赖就可以了。如果声明的时候就立刻初始化，则必须小心检查所依赖的模块初始化是否已经完成了，然而如此一来就退化成了普通的模块化方法了。<strong>延迟初始化是实现依赖注入的重要过程</strong>。</p><p>模块依赖已经明了，现在来看看作为处理函数的 <code>runInvokeQueue</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runInvokeQueue</span>(<span class="params">queue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i, ii;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, ii = queue.length; i &lt; ii; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> invokeArgs = queue[i],</span><br><span class="line">        provider = providerInjector.get(invokeArgs[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    provider[invokeArgs[<span class="number">1</span>]].apply(provider, invokeArgs[<span class="number">2</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的代码只有两行，<code>provider = providerInjector.get(invokeArgs[0]);</code> 和 <code>provider[invokeArgs[1]].apply(provider, invokeArgs[2]);</code>。</p><p>往上看一下，调用 <code>providerInjector.get</code> 相当于是调用 <code>getService</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getService</span>(<span class="params">serviceName, caller</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache.hasOwnProperty(serviceName)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[serviceName] === INSTANTIATING) &#123;</span><br><span class="line">      <span class="keyword">throw</span> $injectorMinErr(<span class="string">'cdep'</span>, <span class="string">'Circular dependency found: &#123;0&#125;'</span>,</span><br><span class="line">                serviceName + <span class="string">' &lt;- '</span> + path.join(<span class="string">' &lt;- '</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[serviceName];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      path.unshift(serviceName);</span><br><span class="line">      cache[serviceName] = INSTANTIATING;</span><br><span class="line">      <span class="keyword">return</span> cache[serviceName] = factory(serviceName, caller);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cache[serviceName] === INSTANTIATING) &#123;</span><br><span class="line">        <span class="keyword">delete</span> cache[serviceName];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      path.shift();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码虽多，但基本就是干一件事，返回 <code>cache</code> 中的对象，如果没有，就用 <code>factory</code> 创建一个再返回。而调用的对象 <code>providerInjector</code> 的定义来看，<code>cache</code> 就等于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">providerCache = &#123;</span><br><span class="line">  $provide: &#123;</span><br><span class="line">      provider: supportObject(provider),</span><br><span class="line">      factory: supportObject(factory),</span><br><span class="line">      service: supportObject(service),</span><br><span class="line">      value: supportObject(value),</span><br><span class="line">      constant: supportObject(constant),</span><br><span class="line">      decorator: decorator</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>OK，现在可以知道了那些被延迟初始化的模块元素会在这里被处理了。</p><p>从上文可以知道，<code>invokeArgs[0]</code> 的值为 <code>$provider</code>，<code>invokeArgs[1]</code> 的值为 service / factory 等，<code>invokeArgs[2]</code> 则为参数数组。</p><p>看看以下的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如此使用</span></span><br><span class="line">m.service( <span class="string">'b'</span>, [<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"> a </span>) </span>&#123; <span class="keyword">this</span>.a = a &#125;] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化的时候实际上调用</span></span><br><span class="line">$provider.service( <span class="string">'b'</span>, [<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"> a </span>) </span>&#123; <span class="keyword">this</span>.a = a &#125;] );</span><br></pre></td></tr></table></figure><p><a name="wrapup"></a></p><h2 id="统一包装↑"><a href="#统一包装↑" class="headerlink" title="统一包装↑"></a>统一包装<a href="#catalogue">↑</a></h2><p>接下来就是分析模块元素（对外表现为 API）的代码了。</p><p>函数有点多，但是还是能看得出来。<code>supportObject</code> 不用管，只是负责转换一下参数，基本的函数是 <code>provider</code>，<code>factory</code> 会调用它，然后 <code>value</code> 和 <code>service</code> 会调用 <code>factory</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">provider</span>(<span class="params">name, provider_</span>) </span>&#123;</span><br><span class="line">  assertNotHasOwnProperty(name, <span class="string">'service'</span>);</span><br><span class="line">  <span class="keyword">if</span> (isFunction(provider_) || isArray(provider_)) &#123;</span><br><span class="line">    provider_ = providerInjector.instantiate(provider_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!provider_.$<span class="keyword">get</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> $injectorMinErr(<span class="string">'pget'</span>, <span class="string">"Provider '&#123;0&#125;' must define $get factory method."</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> providerCache[name + providerSuffix] = provider_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个判断和第二个判断在 <code>factory</code> 调用的时候是无效的，因为 <code>factory</code> 调用 <code>provider</code> 的时候第二个参数是 Object，而且带有 <code>$get</code> 属性。实际上在本阶段做的是，就是将调用 API 传入的第二个参数（第一个参数是名字）再包装一层对象，再<strong>存储在 <code>providerCache</code> 中</strong>，对象统一拥有 <code>$get</code> 属性，或者说，接口。</p><p>其中，<code>$get</code> 属性是一个可供调用的函数，功能是即使模块元素混杂存储，也能被统一的接口成功调用。</p><p>对于 <code>value</code>，调用 API 的时候传入的是值，因此需要包装成返回这个值的函数才赋值给 <code>$get</code>。</p><p>对于 <code>constant</code>，值是不变的，所以可以看到就直接存储了。</p><p>对于 <code>decorator</code>，同样会定义 <code>$get</code> 属性。</p><p>对于 <code>service</code>，设计上应该生成一个单例并存储下来。不过在这里，仍然是继续包装起来。</p><p>源代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enforceReturnValue</span>(<span class="params">name, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">enforcedReturnValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = instanceInjector.invoke(factory, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (isUndefined(result)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> $injectorMinErr(<span class="string">'undef'</span>, <span class="string">"Provider '&#123;0&#125;' must return a value from $get factory method."</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factory</span>(<span class="params">name, factoryFn, enforce</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> provider(name, &#123;</span><br><span class="line">    $<span class="keyword">get</span>: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function service(name, <span class="keyword">constructor</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> factory(name, [<span class="string">'$injector'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$injector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $injector.instantiate(<span class="keyword">constructor</span>);</span><br><span class="line">  &#125;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际干了如下的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> provider(name, &#123;  <span class="comment">// 跟其他 API 一样调用 provider 函数</span></span><br><span class="line">    $<span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> instanceInjector.invoke(</span><br><span class="line">          [<span class="string">'$injector'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$injector</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> $injector.instantiate(<span class="keyword">constructor</span>);  // 注意 <span class="keyword">constructor</span> 是用户自定义的‘可注入结构’</span><br><span class="line">          &#125;]  // 这又是一个‘可注入结构’，注入的是 '$injector'，实际上就等于 instanceInjector</span><br><span class="line">          , this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)( 'serviceName' )</span><br></pre></td></tr></table></figure><p>最后依然将包装好的函数存入 <code>$provider</code>。</p><p>只是为什么还是存储在 <code>$provider</code>，而不是直接调用函数进行初始化？比如 <code>service</code>，为什么还要再包装上一层‘可注入结构’？</p><p><a name="brief"></a></p><h2 id="小结↑"><a href="#小结↑" class="headerlink" title="小结↑"></a>小结<a href="#catalogue">↑</a></h2><p>前文提到，使用延迟初始化实现了模块的依赖注入，使依赖的模块不需要提前定义。</p><p>实际上模块内的元素（factory / service 等）也是可以使用依赖注入的。使用过 AngularJS 的肯定知道定义某一个 controller 的时候可以注入某个 service，然而 controller 和 service 的定义顺序应该不能对代码运行造成影响。</p><p>因此，在此时，模块元素的“构造函数”（注意是用户自定义的那个函数而并非供<br> new 调用的那个函数）还并不具备运行的条件，因为还是需要等依赖的元素初始化。</p><p>于是某种意义上，模块元素就需要<strong>第二重注入</strong>。把‘可注入结构’缓存在 <code>$provider</code> 中实际上就是对应了前文叙述的‘把模块先全部缓存’，包装上一个函数再统一放在 <code>$get</code> 属性下明显是方便供下一阶段的调用。</p><p>万事俱备，只欠注入了。</p><blockquote><p>分析到现阶段，大家应该对平常使用频繁的 <code>service</code>、<code>factory</code> 等函数有了更深的认识了。</p></blockquote><p><a name="injector"></a></p><h2 id="注入器的奥秘↑"><a href="#注入器的奥秘↑" class="headerlink" title="注入器的奥秘↑"></a>注入器的奥秘<a href="#catalogue">↑</a></h2><p>现在把精力放在 <code>createInternalInjector</code> 函数。</p><p>此函数在<a href="#analyze">开始分析</a>一节中已经提到了，作用只是返回一个对象。这个对象就是真正的注入器。</p><p>此函数被调用了两次，分别是得到 <code>providerInjector</code> 和 <code>instanceInjector</code>。</p><p>注入器中重要的函数有三个，分别是 <code>getService</code>、<code>invoke</code> 和 <code>instantiate</code>。</p><p>在<a href="#analyze">开始分析</a>中已经大致介绍了，<code>getService</code> 函数干一件事，返回 <code>cache</code> 中的对象，如果没有，就用 <code>factory</code> 创建一个再返回。</p><p>对于 <code>providerInjector</code>，<code>factory</code> 函数是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">serviceName, caller</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (angular.isString(caller)) &#123;</span><br><span class="line">    path.push(caller);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> $injectorMinErr(<span class="string">'unpr'</span>, <span class="string">"Unknown provider: &#123;0&#125;"</span>, path.join(<span class="string">' &lt;- '</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难理解，因为在调用 provider 的时候，<code>providerCache</code> 中的函数应该已经在上一个初始化模块阶段中被定义好，如果没找到，那么肯定是调用了未定义的 provider。</p><p>对于 <code>instanceInjector</code>，<code>factory</code> 函数是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">serviceName, caller</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> provider = providerInjector.get(serviceName + providerSuffix, caller);</span><br><span class="line">  <span class="keyword">return</span> instanceInjector.invoke(provider.$<span class="keyword">get</span>, provider, undefined, serviceName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>instanceCache</code> 本身就是空的，因此在找不到的时候，就去 <code>providerInjector</code> 里找 provider，然后得到其调用的结果，就是真正需要的实例（instance）了。<code>$get</code> 在这里就凸显出统一调用的用处了。</p><p><code>invoke</code> 函数则是处理<strong>‘可注入结构’</strong>和调用函数。从源码中也可以看到组装参数和调用函数，其中也会调用 <code>getService</code> 去得到实参的值来实现注入。从这里的 <code>getService</code> 出发，又有可能调用 <code>factory</code> 继而继续调用 <code>invoke</code> 来得到所依赖的实例，直到没有任何依赖需要实例化，从而完美的实现了自洽。</p><p><code>instantiate</code> 函数是用来处理 ‘service’ 的，是用来模拟 <code>new</code> 的，从代码来看也是如此：复制一个函数的 prototype，绑定为函数的 <code>this</code>，然后调用函数。因此调用 <code>service</code> API 的时候，可以完全使用构造函数的写法，同时也能得到注入特性。</p><p><a name="unexpected"></a></p><h2 id="读源码的意外发现↑"><a href="#读源码的意外发现↑" class="headerlink" title="读源码的意外发现↑"></a>读源码的意外发现<a href="#catalogue">↑</a></h2><p>读源码一般都会有一定的收获，或是技巧上的，或是思想上的。</p><p>当读完了 Angular 的依赖注入的代码后，才发现 Angular 虽然表明支持模块化，但是实际上所谓的模块化只是徒有其名，模块的定义只是方便框架自己做延迟初始化的工作，没有模块之实。模块只是依赖树上的节点，最终生成出来的命名空间跟模块没有一丁点的关系，所有模块里的东西，不论是 ‘value’、’service’ 和 ‘provider’ 等，都是平铺在 <code>instanceCache</code> 里面的。这样的做法明显的一个结果就是命名冲突，两个不同模块里面的同名对象，后实例化的会覆盖掉先实例化的。这一点非常的不好，因为完全不符合模块化的预期结果。</p><p>在下一篇编（fu）写（zhi）注入功能的时候，我会修改这部分使其能满足模块化的实际预期。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;几年前有一个项目构思，由于技术水平低，当时并没有思考得很清楚，所以一直没怎么着手开始。近来前端很多优秀的库出现了，也让我对那个项目有了新的想法。在写了几个 JavaScript 的项目后我觉得可以尝试开始了。尝试并成功写出一些代码之后，就开（挖）始（坑）了这个系列的博文。&lt;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="技术" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="前端" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/"/>
    
    
      <category term="javascript" scheme="https://blog.e10t.net/tags/javascript/"/>
    
      <category term="FictionInjection" scheme="https://blog.e10t.net/tags/FictionInjection/"/>
    
  </entry>
  
  <entry>
    <title>看《Sherlock: The Abominable Bride》</title>
    <link href="https://blog.e10t.net/watch-sherlock-the-abominable-bride/"/>
    <id>https://blog.e10t.net/watch-sherlock-the-abominable-bride/</id>
    <published>2016-01-05T11:48:23.000Z</published>
    <updated>2016-01-05T11:49:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>看完新出的夏洛克，想必大家都会很茫然。刚好今晚也看了，就说说我看了电影和影评后的总结吧。</p><p>PS: 有剧透才能更好地看电影。</p><p>PS: 如果你是想看好莱坞大片，还像和我同一片场的人那样带着爆米花和泡椒凤爪来看的，可以退票了。</p><p>简单来说，整部电影的剧情几乎都是在嗑了药的夏洛克进入多层梦境中发生的。他要解决上一季结尾中莫里亚蒂的 “回归” 的问题，于是在脑内——或者说是思维迷宫内——解决一百年前的另外一个 “死而复活的新娘” 的问题。而解决这个问题的方法，就是将自己带入到那个维多利亚时代中，思考自己会如何行动，剧情如何发展。这也就是为什么差不多通篇都是维多利亚时代风格的由来。案情重组，简而言之。不过，有一个问题，就是实际上根据设定，电影中福尔摩斯并不是十九世纪的人物，如此一来就对原来的案情进行了干涉，出现矛盾，这个后面再谈。</p><p>令来看福华 CP 的，卖腐的，相爱相杀的女性，啊不，观众大失所望，恐怕是悬疑色彩的浓重，剧情的多段跳跃和突然切换，以及似乎毫无卖腐的情节。然而我等从第一季就只对其具备推理性质和现代化改编产生强烈爱好的人却是大欢喜：这才是正剧的风格，第三季给某些群体派太多显而易见的糖了。</p><p>然而电影中的推理很好吗？电影没有派糖吗？非也。</p><p>先说推理。电影中的诡计归结成一句话就是：死了的新娘为何能复活并杀死其丈夫？答案是一开始就没死，是在姐妹们的帮助下演戏，之后再当街杀丈夫并给大众一种复活的假象再高明地自杀，不留下破绽，并且还继续利用这种牺牲换来了死而复生继而复活的恐怖现象来帮助姐妹完成对姐妹的丈夫的复仇。卧槽竟然吞枪自杀只是演戏？乍一看似乎有点敷衍，但是和朋友讨论后认为，如果考虑到十九世纪科技水平的低下和侦查手段的匮乏，加上法医的暗中帮助，实际上完全是可能发生的。所以说推理虽然并不出彩或者惊世骇俗，然而还是有意思的。只是编剧没有给解答过程一个酷炫的表现，所以观众就有不爽、硬了不射的憋屈。那为什么不表现得很光很亮很油还很 duang 呢？同样后面再谈。</p><p>再说派糖，电影中最明显的就是瀑布旁莫里亚蒂说的 “你们不如私奔吧” 的吧？原著可是福尔摩斯和教授一起掉下瀑布失踪的，电影里面华生来救福尔摩斯了啊。麦考夫在飞机里面对夏洛克嗑药的担心和毫不掩饰的 be there for you 你们无视了吗？午夜夏洛克和华生的深入交谈你们没触动吗？只能说糖派得有点晦涩了，伪粉抖一抖就掉了，真粉还是会粘着。</p><p>另外纵观整个案件，诡计的实施涉及到已经患绝症的新娘，女仆，为了证明自己和男性一样能胜任工作而不得不女扮男装的女法医（电影此处对 man 的翻译应该有问题）以及一众的女性秘密组织，换句话说，这其实标志着女性的反抗。电影中已有多处暗示：玛丽说她希望跟华生一样能做事，并且参加女性选举权的争取；麦考夫说有一个眼皮底下的 enemy，undetected, and unstoppable，还说 we will lose，because they are right we are wrong；玛丽从十九世纪的被晾在一边到二十世纪终于能和丈夫一起参与事情；华生家庭的情况；通通都是编剧支持女性争取权利的暗示。这也是跟随了近年电影频繁地使用女性作为主角，将女性塑造出不同形象的大流（我是从冰雪奇缘开始察觉近来电影有这样的趋势的）。这才是给女性派的最好的糖不是吗？</p><p>最后来说说电影对夏洛克这个人物的思考，顺便也把前面两个 “后面再谈” 解决了。原著中福尔摩斯基本上被塑造成理性思考和推理的机器，然而比较 tricky 的一点是根据设定，小说是道尔笔下的华生写的，小说中福尔摩斯的形象是道尔笔下的华生给大众塑造的，真实 (?) 的夏洛克到底是怎样的人无从得知。电影中也有反复地强调华生将夏洛克的案件写成文章发表。在午夜华生反复质问夏洛克关于感情和过去的问题，夏洛克没有说出来。这是编剧对夏洛克这个人物感情的探讨，没什么清晰的结论。之后没能保护受害人，夏洛克把自己关在房间里又磕药。然后莫里亚蒂就出现了在房间又吞枪了一次，没死，夏洛克觉得想不通怎么死不了的时候飞机着陆了把他震醒了。醒过来的二十一世纪是现实。一番交流后他又睡了，在梦里十九世纪醒来，开始了找玛丽和到在教堂里面解谜。最后指认凶手的时候他突然想到，凶手为什么要找他来破案呢？因为历史上新娘案就没被侦破，他作为侦探加入进案件了就产生了干涉，造成了奇怪的悖论。接着莫里亚蒂又出来了，场景就又切换到二十一世纪了，但是是更深一层梦里的二十一世纪，因为最后死尸活过来了，在现实里是不可能的。紧接着场景转到了著名的瀑布，这个估计就是夏洛克心里近乎最深层的地方了。可以看到，每当梦里有不寻常的事情发生，莫里亚蒂就会出来，试图让夏洛克偏离方向，只是第一次被飞机降落打断了。于是也就解释了为何解谜过程不酷炫，第一解谜发生在夏洛克脑内，显然不需要 “炫” 给自己看；第二，解谜会引出悖论从而引出教授，太酷炫会让观众大脑当机无法思考莫里亚蒂出现的原因。看到这你是不是忘记了这一段说的是夏洛克人物的探讨了？前面说了一大段剧情其实就是论证了在这个系列中，编剧认为莫里亚蒂就是夏洛克的心结和过去，或者说他脑中的魔鬼，会让夏洛克的思考出现问题。这是编剧对夏洛克过去的探讨。在原著中两人双双跌下瀑布，电影中是华生出来救场，并且表现得完全不像非梦境的华生。这 “夏洛克被心魔莫里亚蒂殴打，华生赶来将教授一脚踹下” 的场景表明夏洛克不再纠结莫里亚蒂 “复活” 了，而明白是他 “回来” 了。</p><p>于是正如新娘最终还是死了，莫里亚蒂大约的确已经死了。正如复仇是秘密组织干的，无责任猜测一下下一季的剧情大概就是教授的同伙来复仇了。</p><p>最后来看看编剧在电影里融合了什么呢？电视剧中的人物的重新运用，合格的推理，女性主义，对夏洛克的人物心理探讨，还有两季之间的承前启后。或许把这么多的东西融于一炉是有点用力过猛了，我刚看完的时候也是有点懵了，但是走回家的路上却越想越有意思。</p><p>我给这电影三个评价：</p><ul><li>女性主义的胜利</li><li>原著党的胜利</li><li>伪粉的处刑</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看完新出的夏洛克，想必大家都会很茫然。刚好今晚也看了，就说说我看了电影和影评后的总结吧。&lt;/p&gt;
&lt;p&gt;PS: 有剧透才能更好地看电影。&lt;/p&gt;
&lt;p&gt;PS: 如果你是想看好莱坞大片，还像和我同一片场的人那样带着爆米花和泡椒凤爪来看的，可以退票了。&lt;/p&gt;
&lt;p&gt;简单来说，
      
    
    </summary>
    
      <category term="生活" scheme="https://blog.e10t.net/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="电影" scheme="https://blog.e10t.net/categories/%E7%94%9F%E6%B4%BB/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="bytalk" scheme="https://blog.e10t.net/tags/bytalk/"/>
    
      <category term="movie" scheme="https://blog.e10t.net/tags/movie/"/>
    
  </entry>
  
  <entry>
    <title>クリスマス？なにそれ？美味しいの？</title>
    <link href="https://blog.e10t.net/single-bell-2015/"/>
    <id>https://blog.e10t.net/single-bell-2015/</id>
    <published>2015-12-25T09:02:32.000Z</published>
    <updated>2015-12-25T09:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个妹子给我推荐了这个刷算法题换装的游戏。</p><p>然而随着一道又一道的题目的通过，悲伤感越来越重却是怎么回事。</p><p>在平安夜和圣诞节一个人对着电脑敲代码来给虚拟妹子解锁装扮也是够自虐的。<br><img src="https://ooo.0o0.ooo/2015/12/25/567d017589cbe.png" alt="tu"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个妹子给我推荐了这个刷算法题换装的游戏。&lt;/p&gt;
&lt;p&gt;然而随着一道又一道的题目的通过，悲伤感越来越重却是怎么回事。&lt;/p&gt;
&lt;p&gt;在平安夜和圣诞节一个人对着电脑敲代码来给虚拟妹子解锁装扮也是够自虐的。&lt;br&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="算法" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 ES6 编写一个生命游戏</title>
    <link href="https://blog.e10t.net/write-a-game-of-life-using-es6/"/>
    <id>https://blog.e10t.net/write-a-game-of-life-using-es6/</id>
    <published>2015-11-26T16:38:57.000Z</published>
    <updated>2015-11-27T04:31:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/exoticknight/gol.js" target="_blank" rel="noopener">GitHub 地址</a></p></blockquote><p><img src="https://i.imgur.com/fLKUaVL.gif" alt="gif"></p><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>前段时间看了《Understanding ECMAScript 6》，因为有 JavaScript 的基础，很快就上手了，还写了 <a href="http://blog.e10t.net/understanding-ecmascript6-note/">笔记</a>。然而编程只看书是不够的，还需要让身体熟悉起来。刚好最近在看「全部成为 F」这部新番，看到 ED 采用了「生命游戏」的表现形式，于是便有了用 ES6 来写一个的主意。</p><h2 id="「生命游戏」"><a href="#「生命游戏」" class="headerlink" title="「生命游戏」"></a>「生命游戏」</h2><p>「生命游戏」的英文原文是「Game of Life」，是细胞自动机的一种形式，每个细胞的未来状态只取决于以其为中心周围八格细胞的当前状态。更详细的信息请看 <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank" rel="noopener">wiki 条目</a>，给出一个有意思的动画图。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif" alt="gif 动画图"></p><p>而状态判断只有四条：</p><ol><li>当前细胞为存活状态时，当周围低于 2 个（不包含 2 个）存活细胞时， 该细胞变成死亡状态。（模拟生命数量稀少）</li><li>当前细胞为存活状态时，当周围有 2 个或 3 个存活细胞时， 该细胞保持原样。</li><li>当前细胞为存活状态时，当周围有 3 个以上的存活细胞时，该细胞变成死亡状态。（模拟生命数量过多）</li><li>当前细胞为死亡状态时，当周围有 3 个存活细胞时，该细胞变成存活状态。 （模拟繁殖）</li></ol><h3 id="算法思考"><a href="#算法思考" class="headerlink" title="算法思考"></a>算法思考</h3><p>假设有一个棋盘，每一个格子代表一个细胞。在每一次生成下一代细胞，先遍历每一个细胞，查询它周围八格细胞的状态，设置本细胞下一代的状态。</p><p>显然这样的算法基本毫无意义，因为显然棋盘是不定大小的，细胞也不是每一代都一定会变化的，遍历整个棋盘也是浪费时间的。</p><p>实际上，发生变化或者有可能发生变化的细胞，基本是聚集在活细胞周围的。如果一个死细胞附近没有活细胞，那么这个细胞就不会发生变化。所以，可以换个思路，每一个曾经活过或者在活细胞周围的细胞都维持一个它的邻居细胞的数目记录。每当一个细胞活过来了，就通知周围八格的细胞，让它们的活邻居细胞的数目记录增加 1；相反每当一个细胞死了，就通知周围八格的细胞，让它们的活邻居细胞的数目记录减少 1。显然在更新完之后，周围八格的细胞不论生死都清楚自己周围的活细胞数，也就是能够得到自己的未来状态了。同时，在通知周围八个邻居的时候，也可以统计出对于本细胞来说的活邻居数，于是本细胞的未来状态也能够得到了。</p><p>于是算法能描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1) 在某一次生成本次状态中，有将改变状态的细胞集合 S</span><br><span class="line">2) 遍历集合 S，对于细胞 i：</span><br><span class="line">    改变细胞 i 的状态</span><br><span class="line">    细胞 i 的活邻居数置零</span><br><span class="line">    遍历 8 个邻居细胞，对于邻居细胞 j：</span><br><span class="line">        如果细胞 i 改变后的状态 == 存活，细胞 j 的活邻居数增加 1</span><br><span class="line">        如果细胞 i 改变后的状态 == 死亡，细胞 j 的活邻居数减少 1</span><br><span class="line">        计算细胞 j 的未来状态并记录在将改变状态的细胞集合 S&apos; 中</span><br><span class="line">        如果细胞 j 是活细胞：</span><br><span class="line">            细胞 i 的活邻居数增加 1</span><br><span class="line">    计算细胞 i 的未来状态并记录在将改变状态的细胞集合 S&apos; 中</span><br><span class="line">3)S = S&apos;，重复 1)、2)</span><br></pre></td></tr></table></figure><h2 id="ES6-写起来"><a href="#ES6-写起来" class="headerlink" title="ES6 写起来"></a>ES6 写起来</h2><p>ES6 中有 class 的概念，虽然实现方式其实就是 function 和原型，但是在写的时候就不用像以前用「模拟」的手段来编写啦。</p><h3 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h3><p>基本来说，分三个主要对象：提供算法的 class Life，提供单元格绘制的 class Grid，提供 DOM 动画控制的 class Game。Game 从算法中得到需要重绘的单元格，通过 Grid 来绘制单元格。</p><h3 id="class-Life"><a href="#class-Life" class="headerlink" title="class Life"></a>class Life</h3><p>已经有算法描述了，写起来并不复杂。新建一个 <code>life.js</code> 文件，导出 <code>Life</code> 类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Life</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> ( row, col ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.row = row;</span><br><span class="line">    <span class="keyword">this</span>.column = col;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.generation = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * this.world = &#123;</span></span><br><span class="line"><span class="comment">     *   '0,0':  // 'x,y'</span></span><br><span class="line"><span class="comment">     *   [</span></span><br><span class="line"><span class="comment">     *     1,  // alive 1, dead 0</span></span><br><span class="line"><span class="comment">     *     0,  // count of neighbour</span></span><br><span class="line"><span class="comment">     *   ]</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">this</span>.world = &#123;&#125;;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * '0,0':  // 'x,y'</span></span><br><span class="line"><span class="comment">     * 1  // to be alive 1, to be dead -1, 0 not change</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">this</span>.changedState = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数只需要得到世界（棋盘）的长宽就行了，<code>this.world</code> 记录世界中受关注细胞的状态，<code>this.changedState</code> 记录将要改变状态的细胞。</p><p>算法本体代码，相当于描述 2) 中循环中的操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">_processLife ( x, y, state ) &#123;</span><br><span class="line">  <span class="keyword">let</span> currentCellHash = x + <span class="string">','</span> + y;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">this</span>.world[currentCellHash] ) &#123;</span><br><span class="line">    <span class="comment">// 根据 state 改变状态</span></span><br><span class="line">    <span class="keyword">this</span>.world[currentCellHash][<span class="number">0</span>] = state ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果世界中不存在记录，则肯定是新的活细胞</span></span><br><span class="line">    <span class="keyword">this</span>.world[currentCellHash] = [<span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新邻居细胞并统计活邻居数</span></span><br><span class="line">  <span class="keyword">let</span> aliveNeighBours = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> neighbours = [</span><br><span class="line">    <span class="comment">// 左边的邻居</span></span><br><span class="line">    [x - <span class="number">1</span>, y - <span class="number">1</span>],</span><br><span class="line">    [x - <span class="number">1</span>, y],</span><br><span class="line">    [x - <span class="number">1</span>, y + <span class="number">1</span>],</span><br><span class="line">    <span class="comment">// 上下邻居</span></span><br><span class="line">    [x, y - <span class="number">1</span>],</span><br><span class="line">    [x, y + <span class="number">1</span>],</span><br><span class="line">    <span class="comment">// 右边的邻居</span></span><br><span class="line">    [x + <span class="number">1</span>, y - <span class="number">1</span>],</span><br><span class="line">    [x + <span class="number">1</span>, y],</span><br><span class="line">    [x + <span class="number">1</span>, y + <span class="number">1</span>],</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">let</span> counter = state ? +<span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环 8 个邻居</span></span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ ) &#123;</span><br><span class="line">    <span class="keyword">let</span> [nx, ny] = neighbours[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些世界中的约束</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; <span class="keyword">this</span>.column &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny &lt; <span class="keyword">this</span>.row ) &#123;</span><br><span class="line">      <span class="keyword">let</span> hash = nx + <span class="string">','</span> + ny;</span><br><span class="line">      <span class="keyword">let</span> oldState = <span class="keyword">this</span>.world[hash];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// oldState[0] alive or dead, oldState[1] count of neighbour</span></span><br><span class="line">      <span class="keyword">if</span> ( oldState ) &#123;  <span class="comment">// 邻居已经存在于世界中了</span></span><br><span class="line">        oldState[<span class="number">1</span>] += counter;  <span class="comment">// 更新邻居的邻居数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顺便统计活邻居数</span></span><br><span class="line">        <span class="keyword">if</span> ( oldState[<span class="number">0</span>] ) &#123;</span><br><span class="line">          aliveNeighBours++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 边缘开拓新的细胞，肯定是死细胞</span></span><br><span class="line">        oldState = <span class="keyword">this</span>.world[hash] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 计算邻居细胞的未来状态</span></span><br><span class="line">      <span class="keyword">switch</span> ( oldState[<span class="number">1</span>] ) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          <span class="keyword">this</span>.changedState[hash] = <span class="number">-1</span>;  <span class="comment">// if alive, then to be dead</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">          <span class="keyword">this</span>.changedState[hash] = <span class="number">1</span>;  <span class="comment">// if dead, then to be alive</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">          <span class="keyword">this</span>.changedState[hash] = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算当前细胞的未来状态</span></span><br><span class="line">  <span class="keyword">this</span>.world[currentCellHash][<span class="number">1</span>] = aliveNeighBours;</span><br><span class="line">  <span class="keyword">switch</span> ( aliveNeighBours ) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">this</span>.changedState[currentCellHash] = <span class="number">-1</span>;  <span class="comment">// if alive, then to be dead</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">this</span>.changedState[currentCellHash] = <span class="number">1</span>;  <span class="comment">// if dead, then to be alive</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">this</span>.changedState[currentCellHash] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 的循环其实就是得到下一代的状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nextGeneration () &#123;</span><br><span class="line">  <span class="keyword">let</span> state = <span class="built_in">Object</span>.assign( &#123;&#125;, <span class="keyword">this</span>.changedState );  <span class="comment">// 复制将要改变的状态集以便清空</span></span><br><span class="line">  <span class="keyword">let</span> changedCells = &#123; <span class="number">0</span>: [], <span class="number">1</span>:[] &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reset next state</span></span><br><span class="line">  <span class="keyword">this</span>.changedState = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2) 的循环</span></span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">let</span> key <span class="keyword">in</span> state ) &#123;</span><br><span class="line">    <span class="keyword">let</span> [x, y] = key.split( <span class="string">','</span> ).map( <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">parseInt</span>( x ) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( state[key] === <span class="number">1</span> &amp;&amp; ( !<span class="keyword">this</span>.world[key] || <span class="keyword">this</span>.world[key][<span class="number">0</span>] === <span class="number">0</span> ) ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.aliveAt( x, y );  <span class="comment">// 会调用 _processLife( x, y, true )</span></span><br><span class="line">      changedCells[<span class="number">1</span>].push( [x, y] );  <span class="comment">// 记录重绘的细胞</span></span><br><span class="line">    &#125; <span class="keyword">if</span> ( state[key] === <span class="number">-1</span> &amp;&amp; <span class="keyword">this</span>.world[key][<span class="number">0</span>] === <span class="number">1</span> ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.killAt( x, y );  <span class="comment">// 会调用 _processLife( x, y, false )</span></span><br><span class="line">      changedCells[<span class="number">0</span>].push( [x, y] );  <span class="comment">// 记录重绘的细胞</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> changedCells;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他函数可以在 GiiHub 查看。</p><h3 id="class-Grid"><a href="#class-Grid" class="headerlink" title="class Grid"></a>class Grid</h3><p>确定使用 <code>HTML5</code> 中的 <code>Canvas</code> 元素来绘制整个世界（棋盘），<code>Canvas</code> 元素的操作使用另一个类 <code>C</code>，后面再写。</p><p>新建 <code>grid.js</code> 文件，导出 <code>Grid</code> 类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Grid</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> ( canvas, row, col, displayScheme, colorScheme ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.view = canvas;</span><br><span class="line">    <span class="keyword">this</span>.canvas = <span class="keyword">new</span> C( canvas );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.displayScheme = displayScheme;</span><br><span class="line">    <span class="keyword">this</span>.colorScheme = colorScheme;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数要传入 canvas DOM 元素，棋盘的长宽，显示的选项和颜色选项。</p><p>绘制单元格的主要函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">drawCells( redrawCells ) &#123;</span><br><span class="line">  <span class="comment">// draw alive cells</span></span><br><span class="line">  <span class="keyword">this</span>.canvas.setPenColor( <span class="keyword">this</span>.colorScheme.aliveColor );</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">let</span> x, y, i = <span class="number">0</span>, len = redrawCells[<span class="number">1</span>].length; i &lt; len; i++ ) &#123;</span><br><span class="line">    [x, y] = redrawCells[<span class="number">1</span>][i];</span><br><span class="line">    <span class="keyword">this</span>.drawCellAt( x, y );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// draw dead cells</span></span><br><span class="line">  <span class="keyword">this</span>.canvas.setPenColor( <span class="keyword">this</span>.colorScheme.deadColor );</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">let</span> x, y, i = <span class="number">0</span>, len = redrawCells[<span class="number">0</span>].length; i &lt; len; i++ ) &#123;</span><br><span class="line">    [x, y] = redrawCells[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">this</span>.drawCellAt( x, y );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drawCellAt ( x, y ) &#123;</span><br><span class="line">  <span class="keyword">this</span>.canvas.drawRect(</span><br><span class="line">    x * ( <span class="keyword">this</span>.displayScheme.borderWidth + <span class="keyword">this</span>.displayScheme.cellWidth ),</span><br><span class="line">    y * ( <span class="keyword">this</span>.displayScheme.borderWidth + <span class="keyword">this</span>.displayScheme.cellWidth ),</span><br><span class="line">    <span class="keyword">this</span>.displayScheme.cellWidth,</span><br><span class="line">    <span class="keyword">this</span>.displayScheme.cellWidth );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>drawCells</code> 函数是用来批量画细胞的函数，同样颜色的细胞放在一起画，就不需要频繁改变画笔的颜色。</p><p><code>drawCellAt</code> 函数就是找到单元格的左上角距离 <code>Canvas</code> 元素左上角的距离，距离左边是第 x 个细胞宽度加细胞边框宽度，距离上边也是同样道理。</p><p>其中调用的 <code>setPenColor</code> 和 <code>drawRect</code> 还没有，于是就新增一个 <code>c.js</code> 文件，导出 <code>C</code> 类。其实就是 <code>Canvas</code> 元素的操作的封装而已。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> ( ele ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cxt = ele.getContext( <span class="string">'2d'</span> );</span><br><span class="line">    <span class="keyword">this</span>.fillStyle = <span class="string">'#000000'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setPenColor ( hex ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cxt.fillStyle = <span class="keyword">this</span>.fillStyle = <span class="string">'#'</span> + hex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  drawRect ( ox, oy, width, height ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cxt.fillRect( ox, oy, width, height );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear () &#123;</span><br><span class="line">    <span class="keyword">this</span>.cxt.clearRect( <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.cxt.canvas.width, <span class="keyword">this</span>.cxt.canvas.height );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class-Game"><a href="#class-Game" class="headerlink" title="class Game"></a>class Game</h3><p>不复杂，直接看代码吧。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Life <span class="keyword">from</span> <span class="string">'./life.js'</span>;</span><br><span class="line"><span class="keyword">import</span> Grid <span class="keyword">from</span> <span class="string">'./grid.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> ( canvas, row, col, displayScheme, colorScheme, gps ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.grid = <span class="keyword">new</span> Grid( canvas, row, col, displayScheme, colorScheme );</span><br><span class="line">    <span class="keyword">this</span>.life = <span class="keyword">new</span> Life( row, col );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.speed = <span class="number">1000</span> / gps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.enable = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.running = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init ( x ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stop();</span><br><span class="line">    <span class="keyword">this</span>.life.init( x );</span><br><span class="line">    <span class="keyword">this</span>.grid.init();</span><br><span class="line">    <span class="keyword">this</span>.enable = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop () &#123;</span><br><span class="line">    <span class="keyword">this</span>.running = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.enable = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.life.reset();</span><br><span class="line">    <span class="keyword">this</span>.grid.claer();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pause () &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">this</span>.enable ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.running = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resume () &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">this</span>.enable ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  step () &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">this</span>.enable ) &#123;</span><br><span class="line">      <span class="comment">// run algorithm</span></span><br><span class="line">      <span class="keyword">let</span> redrawCells = <span class="keyword">this</span>.life.nextGeneration();</span><br><span class="line">      <span class="comment">// redraw cells</span></span><br><span class="line">      <span class="keyword">this</span>.grid.drawCells( redrawCells );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">this</span>.enable &amp;&amp; !<span class="keyword">this</span>.running ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.running = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> _run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">this</span>.running ) &#123;</span><br><span class="line">          <span class="keyword">this</span>.step();</span><br><span class="line">          setTimeout( _run, <span class="keyword">this</span>.speed );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      setTimeout( _run, <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一些简单的动画控制方法，跟普通 JavaScript 写起来没什么不同。需要注意的是 <code>enable</code> 状态和 <code>running</code> 状态是不一样的，前者是指整个游戏的响应，后者是指动画的响应。</p><p><code>step</code> 方法是迭代一步，<code>run</code> 方法就是用 <code>setTimeout</code> 来循环调用 <code>step</code> 了。在 <code>run</code> 方法中使用了箭头函数来隐含设定了 <code>this</code> 的值，ES6 的优势就体现出来了。</p><h3 id="gol-js"><a href="#gol-js" class="headerlink" title="gol.js"></a>gol.js</h3><p>整个程序的主体是 Game 的实例，然而还是需要有人去创造一个实例出来，也就是说需要一个工厂函数。于是，新建 <code>gol.js</code> 文件，导出 <code>GOL</code> 类。里面写一个静态方法，用作创建 Game 实例的工厂方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Game <span class="keyword">from</span> <span class="string">'./game.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">GOL</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> createGame ( canvas, row, col, options ) &#123;</span><br><span class="line">    <span class="keyword">let</span> param = <span class="built_in">Object</span>.assign( &#123;</span><br><span class="line">      displayScheme: &#123;</span><br><span class="line">        borderWidth: <span class="number">1</span>,</span><br><span class="line">        cellWidth: <span class="number">10</span></span><br><span class="line">      &#125;,</span><br><span class="line">      colorScheme: &#123;</span><br><span class="line">        aliveColor: <span class="string">'000000'</span>,</span><br><span class="line">        deadColor: <span class="string">'FFFFFF'</span>,</span><br><span class="line">        worldColor: <span class="string">'FFFFFF'</span>,</span><br><span class="line">        borderColor: <span class="string">'FFFFFF'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      gps: <span class="number">15</span></span><br><span class="line">    &#125;, options );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Game( canvas, row, col, param.displayScheme, param.colorScheme, param.gps );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过在 <code>createGame</code> 方法上就不要用 ES6 的语法了，因为方法是要在页面上调用的，目前还没有哪个浏览器完全支持 ES6。但是在方法里面用是没问题的，因为编译器会帮我们转换好。于是可以看到方法里面直接用 <code>Object.assign( des, src )</code> 的函数来合并参数，类似 jQuery 的 <code>extends</code> 函数。</p><h3 id="boot-js"><a href="#boot-js" class="headerlink" title="boot.js"></a>boot.js</h3><p>到此还没完，回忆一下在写普通 JavaScript 库的时候，我们通常会直接包裹上一层适应各种环境的模块注册代码，本人最喜欢就是直接使用 <a href="https://github.com/umdjs/umd" target="_blank" rel="noopener">UMD</a> 了。</p><p>新建 <code>boot.js</code> 文件，执行非 ES6 形式的导出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GOL <span class="keyword">from</span> <span class="string">'./gol.js'</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"> root, name, definition </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd ) &#123;</span><br><span class="line">    define( [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ( root[name] = definition( root ) );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span> &amp;&amp; <span class="built_in">module</span>.exports ) &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = definition( root );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root[name] = definition( root );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)( <span class="built_in">window</span>, <span class="string">'GOL'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"> root </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> GOL;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="代码打包"><a href="#代码打包" class="headerlink" title="代码打包"></a>代码打包</h2><p>OK，到此代码基本写好了，然而到在浏览器上执行还是有一段距离，主要是基本没有浏览器默认支持 ES6，我们还是需要将 ES6 的代码编译一下以便能放到浏览器上运行。比较有名的编译器就是 <a href="https://github.com/babel/babel" target="_blank" rel="noopener">Babel</a> 和 Google 的 <a href="https://github.com/google/traceur-compiler" target="_blank" rel="noopener">Traceur</a> 了。在编译的同时，还需要将所有文件打包成 bundle。</p><p>在进行了各种尝试之后（包括主流的 npm / browserify / jspm 等），最后发现使用 <code>webpack</code> 和 <code>Babel</code> 的结合是比较理想的。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>先来把需要的东西都装上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev webpack babel babel-core babel-loader babel-preset-es2015</span><br></pre></td></tr></table></figure><blockquote><p>个人其实非常讨厌安装到本地，明明都是可以全局安装的插件和工具。<br>而且每次开一个新的项目就要安装几十 MB 的重复东西实在无聊，npm 本身的树状依赖也是容易造成目录过深的情况。（据说新版 npm 有改善，但是不稳定）<br>个人的解决方法是固定一个开发目录，代码随便迁移。</p></blockquote><h3 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h3><p><code>webpack</code> 我就不详细解释了。直接上 <code>webpack.config.js</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/boot.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname,</span><br><span class="line">        filename: <span class="string">'./dist/bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                loader: <span class="string">'babel'</span>,</span><br><span class="line">                query: &#123;</span><br><span class="line">                    cacheDirectory: <span class="literal">true</span>,</span><br><span class="line">                    presets: [<span class="string">'es2015'</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>目前来说，这样写就能让 <code>Babel</code> 编译 ES6 的代码的同时，也运用 <code>webpack</code> 自己的打包功能 <strong> 根据 ES6 的模块语法 </strong> 将文件都打包成一个 bundle。</p><p>打包出来的代码有点大，压缩一下，再写一个 <code>webpack.config.min.js</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.min.js</span></span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = exports = <span class="built_in">Object</span>.create(<span class="built_in">require</span>(<span class="string">"./webpack.config.js"</span>));</span><br><span class="line">exports.plugins = [<span class="keyword">new</span> webpack.optimize.UglifyJsPlugin()];</span><br><span class="line">exports.output = <span class="built_in">Object</span>.create(exports.output);</span><br><span class="line">exports.output.filename = exports.output.filename.replace(<span class="regexp">/\.js$/</span>, <span class="string">".min.js"</span>);</span><br></pre></td></tr></table></figure><p>就能用 <code>webpack</code> 自带的压缩插件压缩代码了。</p><h2 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h2><p>算法、绘图和动画控制都写好了，但是还不够，缺少了交互，还应该允许方便的自定义世界中的活细胞。比较好的交互方式就是允许通过在世界（棋盘）点击来放置活细胞或者死细胞。</p><p>于是考虑监听 <code>Canvas</code> 元素的 <code>mousedown</code>、<code>mousemove</code> 和 <code>mouseup</code> 事件，做出类似画图那样的效果（每个细胞可以看成是一个像素点）。</p><h3 id="grid-js"><a href="#grid-js" class="headerlink" title="grid.js"></a>grid.js</h3><p>先改造负责绘制的模块。</p><p>在 <code>Grid</code> 类中新增 <code>drawAliveCellAt</code>、<code>drawDeadCellAt</code> 函数，负责独立绘制细胞。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">drawAliveCellAt( x, y ) &#123;</span><br><span class="line">  <span class="keyword">this</span>.canvas.setPenColor( <span class="keyword">this</span>.colorScheme.aliveColor );</span><br><span class="line">  <span class="keyword">this</span>.drawCellAt( x, y );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drawDeadCellAt( x, y ) &#123;</span><br><span class="line">  <span class="keyword">this</span>.canvas.setPenColor( <span class="keyword">this</span>.colorScheme.deadColor );</span><br><span class="line">  <span class="keyword">this</span>.drawCellAt( x, y );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增 <code>on</code>、<code>off</code> 函数，负责绑定监听方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">on ( event, handler ) &#123;</span><br><span class="line">  <span class="keyword">this</span>.view.addEventListener( event, handler, <span class="literal">false</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">off ( event, handler ) &#123;</span><br><span class="line">  <span class="keyword">this</span>.view.removeEventListener( event, handler );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增 <code>getXFromPixel</code>、<code>getYFromPixel</code> 函数，负责将像素点转换为单元格位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">getXFromPixel ( pixel ) &#123;</span><br><span class="line">  <span class="keyword">let</span> d = <span class="keyword">this</span>.displayScheme.borderWidth + <span class="keyword">this</span>.displayScheme.cellWidth;</span><br><span class="line">  <span class="keyword">let</span> x = ~~( ( pixel - <span class="keyword">this</span>.canvas.left ) / d );</span><br><span class="line">  <span class="keyword">return</span> x % d &lt;= <span class="keyword">this</span>.displayScheme.cellWidth ? x : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getYFromPixel ( pixel ) &#123;</span><br><span class="line">  <span class="keyword">let</span> d = <span class="keyword">this</span>.displayScheme.borderWidth + <span class="keyword">this</span>.displayScheme.cellWidth;</span><br><span class="line">  <span class="keyword">let</span> y = ~~( ( pixel - <span class="keyword">this</span>.canvas.top ) / d );</span><br><span class="line">  <span class="keyword">return</span> y % d &lt;= <span class="keyword">this</span>.displayScheme.cellWidth ? y : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>~~</code> 是快速取整数。<code>this.canvas.left</code> 和 <code>this.canvas.top</code> 来自于类 <code>C</code> 的实例，因为鼠标点击事件取得的坐标点并非一定是相对于 <code>Canvas</code> 元素的左上角，还要减去 <code>Canvas</code> 元素的边框等。在 <code>c.js</code> 中将构造函数修改一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span> ( ele ) &#123;</span><br><span class="line">  <span class="keyword">this</span>.cxt = ele.getContext( <span class="string">'2d'</span> );</span><br><span class="line">  <span class="keyword">this</span>.fillStyle = <span class="string">'#000000'</span>;</span><br><span class="line">  <span class="keyword">this</span>.left = ele.getBoundingClientRect().left;</span><br><span class="line">  <span class="keyword">this</span>.top = ele.getBoundingClientRect().top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="game-js"><a href="#game-js" class="headerlink" title="game.js"></a>game.js</h3><p>类 <code>Game</code> 的修改有点复杂。先在类的构造函数中增加一个属性，负责记录鼠标状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._mouseState = &#123;</span><br><span class="line">  press: <span class="literal">false</span>,</span><br><span class="line">  lastX: <span class="number">-1</span>,</span><br><span class="line">  lastY: <span class="number">-1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再增加三个方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_onMouseDown ( e ) &#123;</span><br><span class="line">  <span class="keyword">this</span>._mouseState.press = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">this</span>._toggleCell( e.clientX, e.clientY );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_onMouseMove ( e ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">this</span>._mouseState.press ) &#123;</span><br><span class="line">    <span class="keyword">this</span>._toggleCell( e.clientX, e.clientY );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_onMouseUp ( e ) &#123;</span><br><span class="line">  <span class="keyword">this</span>._mouseState.press = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">this</span>._mouseState.lastX = <span class="keyword">this</span>._mouseState.lastY = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鼠标按下，就在鼠标按下的位置改变细胞的状态，并记录鼠标状态为按下。接着如果鼠标弹起，那么就重置鼠标状态；如果鼠标移动并且状态是按下，那么就一直改变路过的细胞的状态。</p><p><code>_toggleCell</code> 方法这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_toggleCell ( px, py ) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="keyword">this</span>.grid.getXFromPixel( px );</span><br><span class="line">  <span class="keyword">let</span> y = <span class="keyword">this</span>.grid.getYFromPixel( py );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( x !== <span class="number">-1</span> &amp;&amp; y !== <span class="number">-1</span>  &amp;&amp; ( <span class="keyword">this</span>._mouseState.lastX !== x || <span class="keyword">this</span>._mouseState.lastY !== y ) ) &#123;</span><br><span class="line">    <span class="keyword">this</span>._mouseState.lastX = x;</span><br><span class="line">    <span class="keyword">this</span>._mouseState.lastY = y;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">this</span>.life.isAlive( x, y ) ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.life.killAt( x, y );</span><br><span class="line">      <span class="keyword">this</span>.grid.drawDeadCellAt( x, y );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.life.aliveAt( x, y );</span><br><span class="line">      <span class="keyword">this</span>.grid.drawAliveCellAt( x, y );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概意思就是先将鼠标的位置转化为单元格位置，再反置此单元格细胞的状态。记录下 <code>lastX</code> 和 <code>lastY</code> 是为了不会循环反置，一定要有坐标变化才反置。</p><p>接下来就是将那三个函数绑定在事件上。新增 <code>_setupLinsteners</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_setupLinsteners () &#123;</span><br><span class="line">  <span class="keyword">this</span>.grid.on( <span class="string">'mousedown'</span>, e =&gt; <span class="keyword">this</span>._onMouseDown( e );</span><br><span class="line">  <span class="keyword">this</span>.grid.on( <span class="string">'mousemove'</span>, e =&gt; <span class="keyword">this</span>._onMouseMove( e );</span><br><span class="line">  <span class="keyword">this</span>.grid.on( <span class="string">'mouseup'</span>, e =&gt; <span class="keyword">this</span>._onMouseUp( e );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然使用了箭头函数优雅地绑定了 <code>this</code> 的值，但是这样写并不好，因为没办法解绑了，容易造成内存泄漏。改一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_setupLinsteners () &#123;</span><br><span class="line">  <span class="keyword">this</span>._boundMethod[<span class="string">'_onMouseDown'</span>] = <span class="function"><span class="params">e</span> =&gt;</span> <span class="keyword">this</span>._onMouseDown( e );</span><br><span class="line">  <span class="keyword">this</span>._boundMethod[<span class="string">'_onMouseMove'</span>] = <span class="function"><span class="params">e</span> =&gt;</span> <span class="keyword">this</span>._onMouseMove( e );</span><br><span class="line">  <span class="keyword">this</span>._boundMethod[<span class="string">'_onMouseUp'</span>] = <span class="function"><span class="params">e</span> =&gt;</span> <span class="keyword">this</span>._onMouseUp( e );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.grid.on( <span class="string">'mousedown'</span>, <span class="keyword">this</span>._boundMethod[<span class="string">'_onMouseDown'</span>] );</span><br><span class="line">  <span class="keyword">this</span>.grid.on( <span class="string">'mousemove'</span>, <span class="keyword">this</span>._boundMethod[<span class="string">'_onMouseMove'</span>] );</span><br><span class="line">  <span class="keyword">this</span>.grid.on( <span class="string">'mouseup'</span>, <span class="keyword">this</span>._boundMethod[<span class="string">'_onMouseUp'</span>] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_teardownLinsteners () &#123;</span><br><span class="line">  <span class="keyword">this</span>.grid.off( <span class="string">'mousedown'</span>, <span class="keyword">this</span>._boundMethod[<span class="string">'_onMouseDown'</span>] );</span><br><span class="line">  <span class="keyword">this</span>.grid.off( <span class="string">'mousemove'</span>, <span class="keyword">this</span>._boundMethod[<span class="string">'_onMouseMove'</span>] );</span><br><span class="line">  <span class="keyword">this</span>.grid.off( <span class="string">'mouseup'</span>, <span class="keyword">this</span>._boundMethod[<span class="string">'_onMouseUp'</span>] );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._boundMethod = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将匿名函数的引用保存起来就能解绑了。</p><p>最后给个 demo 吧。或者玩玩 <a href="https://exoticknight.github.io/gol.js/" target="_blank" rel="noopener">在线 demo</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Game of Life&lt;/title&gt;</span><br><span class="line">  &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;canvas id=&quot;grid&quot; width=&quot;1000&quot; height=&quot;500&quot; style=&quot;border:1px solid&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">  &lt;button onclick=&quot;test()&quot;&gt;init&lt;/button&gt;</span><br><span class="line">  &lt;button onclick=&quot;g.step()&quot;&gt;setp&lt;/button&gt;</span><br><span class="line">  &lt;button onclick=&quot;g.run()&quot;&gt;run&lt;/button&gt;</span><br><span class="line">  &lt;button onclick=&quot;g.stop()&quot;&gt;stop&lt;/button&gt;</span><br><span class="line">  &lt;button onclick=&quot;g.pause()&quot;&gt;pause&lt;/button&gt;</span><br><span class="line">  &lt;button onclick=&quot;g.resume()&quot;&gt;resume&lt;/button&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">var options = &#123;</span><br><span class="line">  displayScheme: &#123;</span><br><span class="line">    borderWidth: 1,</span><br><span class="line">    cellWidth: 4</span><br><span class="line">  &#125;,</span><br><span class="line">  colorScheme: &#123;</span><br><span class="line">    aliveColor: &apos;000000&apos;,</span><br><span class="line">    deadColor: &apos;efefef&apos;,</span><br><span class="line">    worldColor: &apos;ffffff&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var g=GOL.createGame(document.getElementById(&apos;grid&apos;), 100, 200, options);</span><br><span class="line">function test()&#123;</span><br><span class="line">  g.init([[10,10],[11,10],[10,11],[13,12],[12,13],[13,13]]);</span><br><span class="line">  g.step();</span><br><span class="line">&#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/exoticknight/gol.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=
      
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="技术" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="前端" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/"/>
    
    
      <category term="javascript" scheme="https://blog.e10t.net/tags/javascript/"/>
    
      <category term="ECMAScript6" scheme="https://blog.e10t.net/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>《Understanding ECMAScript 6》笔记</title>
    <link href="https://blog.e10t.net/understanding-ecmascript6-note/"/>
    <id>https://blog.e10t.net/understanding-ecmascript6-note/</id>
    <published>2015-10-21T14:17:05.000Z</published>
    <updated>2015-11-06T06:44:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在线免费阅读：<a href="https://leanpub.com/understandinges6/read/" target="_blank" rel="noopener">https://leanpub.com/understandinges6/read/</a></p><p>部分代码使用原书，代码版权归原书所有</p></blockquote><p><a name="catalogue"></a></p><ol><li><a href="#block-bindings">块级绑定（Block Bindings）</a></li><li><a href="#string">字符串</a></li><li><a href="#regex">正则</a></li><li><a href="#template-strings">字符串模板（template strings）</a></li><li><a href="#tagged-templates">标签模板（tagged templates）</a></li><li><a href="#function">函数</a></li><li><a href="#object">对象</a></li><li><a href="#destructuring">解构（Destructuring）</a></li><li><a href="#symbols">Symbols</a></li><li><a href="#generators">生成器（Generators）</a></li><li><a href="#iterators">迭代器（Iterators）</a></li><li><a href="#class">类</a></li><li><a href="#promises">Promises</a></li><li><a href="#modules">模块（Modules）</a></li><li><a href="#miscellaneous">杂七杂八</a></li></ol><p><a name="block-bindings"></a></p><h2 id="块级绑定（Block-Bindings）↑"><a href="#块级绑定（Block-Bindings）↑" class="headerlink" title="块级绑定（Block Bindings）↑"></a>块级绑定（Block Bindings）<a href="#catalogue">↑</a></h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>块级{}中有效</p><p>同块级不可重复声明</p><p>没有变量提升</p><blockquote><p>块级会形成暂时性死区（TDZ，Temporal Dead Zone）</p></blockquote><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>基本和 <code>let</code> 相同，值不可修改</p><blockquote><p><code>let</code> 和 <code>const</code> 最好不要在全局下使用</p></blockquote><p><a name="string"></a></p><h2 id="字符串↑"><a href="#字符串↑" class="headerlink" title="字符串↑"></a>字符串<a href="#catalogue">↑</a></h2><h3 id="unicode-支持更好"><a href="#unicode-支持更好" class="headerlink" title="unicode 支持更好"></a>unicode 支持更好</h3><h3 id="新增部分函数，支持双字节"><a href="#新增部分函数，支持双字节" class="headerlink" title="新增部分函数，支持双字节"></a>新增部分函数，支持双字节</h3><p><code>codePointAt</code>，双字节版的 <code>charCodeAt</code>，得到字符 unicode</p><p><code>fromCodePoint</code>，双字节版的 <code>fromCharCode</code>，从 unicode 得出字符</p><p><code>includes</code>，包含某字符串</p><p><code>startsWith</code>，以某字符串开始</p><p><code>endsWith</code>，以某字符串结束</p><p><code>repeat</code>，重复字符串</p><p><code>normalize</code>，unicode 正规化，举个例子：两个 unicode 字符合成一个</p><p><a name="regex"></a></p><h2 id="正则↑"><a href="#正则↑" class="headerlink" title="正则↑"></a>正则<a href="#catalogue">↑</a></h2><h3 id="新增标志-u"><a href="#新增标志-u" class="headerlink" title="新增标志 u"></a>新增标志 <code>u</code></h3><p>正则识别 unicode 字符</p><h3 id="新增标志-y"><a href="#新增标志-y" class="headerlink" title="新增标志 y"></a>新增标志 <code>y</code></h3><p>sticky，部分浏览器早就实现了</p><p><a name="template-strings"></a></p><h2 id="字符串模板（template-strings）↑"><a href="#字符串模板（template-strings）↑" class="headerlink" title="字符串模板（template strings）↑"></a>字符串模板（template strings）<a href="#catalogue">↑</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">`<span class="subst">$&#123;a&#125;</span> <span class="subst">$&#123;a + b&#125;</span>`</span>  <span class="comment">// '1 3'</span></span><br></pre></td></tr></table></figure><p><a name="tagged-templates"></a></p><h2 id="标签模板（tagged-templates）↑"><a href="#标签模板（tagged-templates）↑" class="headerlink" title="标签模板（tagged templates）↑"></a>标签模板（tagged templates）<a href="#catalogue">↑</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span> (<span class="params"> strings, ...values </span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( strings )</span><br><span class="line">  <span class="built_in">console</span>.log( values )</span><br><span class="line">  <span class="keyword">return</span> values[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = tag<span class="string">`a <span class="subst">$&#123;a&#125;</span>`</span>  <span class="comment">// 'a 1'</span></span><br><span class="line"><span class="comment">// ["a ", "", raw: Array[2]]</span></span><br><span class="line"><span class="comment">// [1]</span></span><br></pre></td></tr></table></figure><p><a name="function"></a></p><h2 id="函数↑"><a href="#函数↑" class="headerlink" title="函数↑"></a>函数<a href="#catalogue">↑</a></h2><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"> bar = <span class="number">1</span> </span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( bar )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"> bar, ...rest </span>) </span>&#123;  <span class="comment">// ✓</span></span><br><span class="line">  ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"> bar, ...rest, last </span>) </span>&#123;  <span class="comment">// ×</span></span><br><span class="line">  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数属性-name"><a href="#函数属性-name" class="headerlink" title="函数属性 name"></a>函数属性 name</h3><p>各种例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( doSomething.name );          <span class="comment">// "doSomething"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doAnotherThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log( doAnotherThing.name );       <span class="comment">// "doAnotherThing"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doSomethingAgain = <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log( doSomethingAgain.name );      <span class="comment">// "doSomethingElse"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="keyword">get</span> firstName () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Nicholas"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="keyword">this</span>.name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( person.sayName.name );   <span class="comment">// "sayName"</span></span><br><span class="line"><span class="built_in">console</span>.log( person.firstName.name ); <span class="comment">// "get firstName"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( doSomething.bind().name );   <span class="comment">// "bound doSomething"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( ( <span class="keyword">new</span> <span class="built_in">Function</span>() ).name );     <span class="comment">// "anonymous"</span></span><br></pre></td></tr></table></figure><h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>避免了很多使用 <code>new</code> 的坑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">"undefined"</span> ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'good'</span> );  <span class="comment">// using new</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">'You must use new with Person.'</span> )  <span class="comment">// not using new</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();  <span class="comment">// good</span></span><br><span class="line">foo = Foo.call( foo );  <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><h3 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h3><p>块级中可定义函数</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p><code>this</code>, <code>super</code>, <code>arguments</code> 和 <code>new.target</code> 的值都在定义函数时绑定而非运行时绑定</p><p>不可 <code>new</code></p><p>不可改变 <code>this</code> 的值</p><p>没有 <code>arguments</code></p><blockquote><p>跟普通函数一样拥有 name 属性</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">value</span> =&gt;</span> value;  <span class="comment">// input value, output value</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params"> x, y </span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">x</span>: <span class="string">'x'</span> &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this 的绑定</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener( <span class="string">'click'</span>, (<span class="function"><span class="keyword">function</span> (<span class="params"> e </span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( e.type );</span><br><span class="line">    &#125;).bind( <span class="keyword">this</span> ), <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener( <span class="string">'click'</span>, e =&gt; &#123;<span class="built_in">console</span>.log( e.type )&#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="立即调用函数表达式（Immediately-Invoked-Function-Expressions-IIFEs-）"><a href="#立即调用函数表达式（Immediately-Invoked-Function-Expressions-IIFEs-）" class="headerlink" title="立即调用函数表达式（Immediately-Invoked Function Expressions (IIFEs)）"></a>立即调用函数表达式（Immediately-Invoked Function Expressions (IIFEs)）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"> s </span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( s );</span><br><span class="line">&#125;( <span class="string">'text'</span> )  <span class="comment">// text</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = ( <span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log( s );</span><br><span class="line">&#125;)( <span class="string">'text'</span> )  <span class="comment">// text</span></span><br></pre></td></tr></table></figure><h3 id="新增尾递归优化"><a href="#新增尾递归优化" class="headerlink" title="新增尾递归优化"></a>新增尾递归优化</h3><p><a name="object"></a></p><h2 id="对象↑"><a href="#对象↑" class="headerlink" title="对象↑"></a>对象<a href="#catalogue">↑</a></h2><h3 id="对象字面属性值简写（Property-Initializer-Shorthand）"><a href="#对象字面属性值简写（Property-Initializer-Shorthand）" class="headerlink" title="对象字面属性值简写（Property Initializer Shorthand）"></a>对象字面属性值简写（Property Initializer Shorthand）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"> text </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name  <span class="comment">// name: name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象方法简写（Method-Initializer-Shorthand）"><a href="#对象方法简写（Method-Initializer-Shorthand）" class="headerlink" title="对象方法简写（Method Initializer Shorthand）"></a>对象方法简写（Method Initializer Shorthand）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  bar () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算属性名语法"><a href="#计算属性名语法" class="headerlink" title="计算属性名语法"></a>计算属性名语法</h3><p>对象的属性可以使用中括号 <code>[]</code> 表示需要「被计算」，结果转换为字符串作为属性名使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">  a: <span class="string">'text a'</span>,</span><br><span class="line">  [a]: <span class="string">'function a'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( foo[<span class="string">'a'</span>] )  <span class="comment">// text a</span></span><br><span class="line"><span class="built_in">console</span>.log( foo[a] )  <span class="comment">// function a</span></span><br></pre></td></tr></table></figure><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>和经典的 <code>===</code> 几乎一样，区别在于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( +<span class="number">0</span> === <span class="number">-0</span>);             <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.is( +<span class="number">0</span>, <span class="number">-0</span> ) );     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="literal">NaN</span> === <span class="literal">NaN</span> );           <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.is( <span class="literal">NaN</span>, <span class="literal">NaN</span> ) );   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign( target, ...source )</span><br></pre></td></tr></table></figure><p>读取源对象可列举的、自身的属性，将其赋值到目标对象上，覆盖旧属性，并非通常意义的复制。</p><h3 id="复制存取器属性"><a href="#复制存取器属性" class="headerlink" title="复制存取器属性"></a>复制存取器属性</h3><blockquote><p>此小节查询 MDN 后补充上</p></blockquote><p>使用 <code>Object.getOwnPropertyDescriptor(source, key)</code> 读取，使用 <code>Object.defineProperties</code> 定义。</p><h3 id="属性允许重复定义"><a href="#属性允许重复定义" class="headerlink" title="属性允许重复定义"></a>属性允许重复定义</h3><p>属性以最后一个定义的值为准</p><h3 id="修改原型"><a href="#修改原型" class="headerlink" title="修改原型"></a>修改原型</h3><p><code>Object.getPrototypeOf</code>，得到原型</p><p><code>Object.setPrototypeOf</code>，设置原型</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>用以访问对象的 prototype</p><p><a name="destructuring"></a></p><h2 id="解构（Destructuring）↑"><a href="#解构（Destructuring）↑" class="headerlink" title="解构（Destructuring）↑"></a>解构（Destructuring）<a href="#catalogue">↑</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;a, <span class="attr">b</span>: &#123; c, d &#125;&#125; = c</span><br><span class="line">( &#123;a, <span class="attr">b</span>: &#123; c, d &#125;&#125; = c )</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [a, [b, c]] = d</span><br><span class="line"><span class="keyword">var</span> [a, , [b, c]] = d  <span class="comment">// 跳过一个</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"> &#123; bar1, bar2 &#125; = &#123;&#125; </span>) </span>&#123;</span><br><span class="line">  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解构可以有默认值，但只会在需要的时候求值。</p><p><a href="http://www.2ality.com/2015/01/es6-destructuring.html" target="_blank" rel="noopener">2ality</a> 有更详细清晰的解释：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">prop</span>: y=someFunc()&#125; = someValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x, y;</span><br><span class="line">[x=<span class="number">3</span>, y=x] = [];     <span class="comment">// x=3; y=3</span></span><br><span class="line">[x=<span class="number">3</span>, y=x] = [<span class="number">7</span>];    <span class="comment">// x=7; y=7</span></span><br><span class="line">[x=<span class="number">3</span>, y=x] = [<span class="number">7</span>, <span class="number">2</span>]; <span class="comment">// x=7; y=2</span></span><br></pre></td></tr></table></figure><p><a name="symbols"></a></p><h2 id="Symbols（不知道如何翻译，是第七种原始类型）↑"><a href="#Symbols（不知道如何翻译，是第七种原始类型）↑" class="headerlink" title="Symbols（不知道如何翻译，是第七种原始类型）↑"></a>Symbols（不知道如何翻译，是第七种原始类型）<a href="#catalogue">↑</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">Symbol</span>( <span class="string">'bar'</span> )</span><br></pre></td></tr></table></figure><p><code>Symbol( &#39;description&#39; )</code> 生成局部 Symbol，即使 <code>description</code> 相同生成的 Symbol 也不一样</p><p><code>Symbol.for( &#39;description&#39; )</code> 生成全局 Symbol，<code>description</code> 相同则 Symbol 相同</p><h3 id="获取对象的-Symbol-数组"><a href="#获取对象的-Symbol-数组" class="headerlink" title="获取对象的 Symbol 数组"></a>获取对象的 Symbol 数组</h3><p><code>Object.getOwnPropertySymbols( object )</code></p><h3 id="强制转换-Symbol-为-String"><a href="#强制转换-Symbol-为-String" class="headerlink" title="强制转换 Symbol 为 String"></a>强制转换 Symbol 为 String</h3><blockquote><p>原书本节未完成</p></blockquote><h3 id="有名的预定义-Symbol"><a href="#有名的预定义-Symbol" class="headerlink" title="有名的预定义 Symbol"></a>有名的预定义 Symbol</h3><blockquote><p>原书本节大部分未完成</p></blockquote><p><a name="generators"></a></p><h2 id="生成器（Generators）↑"><a href="#生成器（Generators）↑" class="headerlink" title="生成器（Generators）↑"></a>生成器（Generators）<a href="#catalogue">↑</a></h2><p>生成迭代器的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  *createIterator ( items ) &#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">let</span> i=<span class="number">0</span>; i &lt; items.length; i++ ) &#123;</span><br><span class="line">      <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = o.createIterator( [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] );</span><br></pre></td></tr></table></figure><p><a name="iterators"></a></p><h2 id="迭代器（Iterators）↑"><a href="#迭代器（Iterators）↑" class="headerlink" title="迭代器（Iterators）↑"></a>迭代器（Iterators）<a href="#catalogue">↑</a></h2><h3 id="for-of-语法"><a href="#for-of-语法" class="headerlink" title="for-of 语法"></a>for-of 语法</h3><p>数组、字符串、映射（Map）、集合（Set）和元素数组（NodeList）都可迭代（iterable），可使用 for-of 语法</p><h3 id="得到内置迭代器"><a href="#得到内置迭代器" class="headerlink" title="得到内置迭代器"></a>得到内置迭代器</h3><p>Symbol.iterator 指向得到迭代器的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> iterator = values[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">iterator.next();  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = &#123;</span><br><span class="line">  items: [],</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> *<span class="keyword">this</span>.items.values();  <span class="comment">// `yield *` 语法，委托了数组 `items` 的内置迭代器</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="对象、数组、映射、集合都具有的默认迭代器"><a href="#对象、数组、映射、集合都具有的默认迭代器" class="headerlink" title="对象、数组、映射、集合都具有的默认迭代器"></a>对象、数组、映射、集合都具有的默认迭代器</h3><p><code>ertries()</code>，返回键值对迭代器</p><p><code>keys()</code>，返回键迭代器</p><p><code>values()</code>，返回值迭代器</p><h3 id="字符串迭代器"><a href="#字符串迭代器" class="headerlink" title="字符串迭代器"></a>字符串迭代器</h3><p>通过 <code>[]</code> 的访问是 code unit 方式</p><p>通过迭代器则是字符方式（几乎是，某些 unicode 支持不足）</p><h3 id="元素数组（NodeList）迭代器"><a href="#元素数组（NodeList）迭代器" class="headerlink" title="元素数组（NodeList）迭代器"></a>元素数组（NodeList）迭代器</h3><p>返回的是数组中的单个元素</p><h3 id="向迭代器传参数"><a href="#向迭代器传参数" class="headerlink" title="向迭代器传参数"></a>向迭代器传参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = foo()</span><br><span class="line"><span class="built_in">console</span>.log( it.next() )  <span class="comment">// Object &#123;value: 1, done: false&#125;，执行语句 `yield 1` 然后暂停</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next( <span class="number">2</span> ) )  <span class="comment">// Object &#123;value: undefined, done: true&#125;，将 2 作为 `yield 1` 的返回值，</span></span><br><span class="line">                             <span class="comment">// 迭代器内部继续执行语句 `let bar = 2`，</span></span><br><span class="line">                             <span class="comment">// 之后执行完毕，无返回值，`value` 为 `undefined`，`done` 为 `true`</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next() )  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h3 id="生成器使用-return-提前返回"><a href="#生成器使用-return-提前返回" class="headerlink" title="生成器使用 return 提前返回"></a>生成器使用 return 提前返回</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 42, done: true &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure><h3 id="委托生成器"><a href="#委托生成器" class="headerlink" title="委托生成器"></a>委托生成器</h3><p>使用 <code>yield *</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createRepeatingIterator</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"repeat"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> *createNumberIterator();</span><br><span class="line">  <span class="keyword">yield</span> *createRepeatingIterator(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = createCombinedIterator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure><p>可以 <code>yield *&quot;string&quot;</code>，会调用字符串的默认迭代器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> * <span class="string">"hello"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = foo()</span><br><span class="line"><span class="built_in">console</span>.log( it.next() )  <span class="comment">// Object &#123;value: "h", done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next() )  <span class="comment">// Object &#123;value: "e", done: false&#125;</span></span><br></pre></td></tr></table></figure><h3 id="异步任务调度"><a href="#异步任务调度" class="headerlink" title="异步任务调度"></a>异步任务调度</h3><p>以下是书中的例子，写得并不好，变量 <code>task</code> 的管理容易出问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> task;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readConfigFile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">"config.json"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            task.throw(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            task.next(contents);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> contents = <span class="keyword">yield</span> readConfigFile();</span><br><span class="line">    doSomethingWith(contents);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Done"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task = init();</span><br><span class="line">task.next();</span><br></pre></td></tr></table></figure><p><a name="class"></a></p><h2 id="类↑"><a href="#类↑" class="headerlink" title="类↑"></a>类<a href="#catalogue">↑</a></h2><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 相当于构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span> ( name ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 相当于 foo.prototype.bar</span></span><br><span class="line">  bar () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.name );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的属性最好都在构造函数里面创建。</p><p>类声明本质上就是以前的函数声明，除了以下有所不同：</p><ol><li>类声明不会像函数声明那样被提升</li><li>类内部的代码全部以 <code>strict mode</code> 运行</li><li>所有方法都是不可列举的，相当于使用了 <code>Object.defineProperty()</code></li><li>不使用 <code>new</code> 会抛异常</li><li>以类名命名方法来覆盖类名会抛异常（类名对于类内部来说是以 <code>const</code> 定义的，对于外部则不是）</li></ol><h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="class"><span class="keyword">class</span> <span class="title">foo2</span> </span>&#123;&#125;  <span class="comment">// foo === foo2</span></span><br></pre></td></tr></table></figure><p>匿名类作为参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFoo</span> (<span class="params"> c </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> c()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createFoo( <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>立即调用类表达式（有点像立即调用函数表达式）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> ( name ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;( <span class="string">'foo'</span> )</span><br></pre></td></tr></table></figure><h3 id="存取器属性"><a href="#存取器属性" class="headerlink" title="存取器属性"></a>存取器属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> ( name ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> className () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'class '</span> + <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> className ( value ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'class'</span> + value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> ( name ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 相当于 foo.prototype.bar</span></span><br><span class="line">  bar () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.name )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 相当于 foo.staticBar</span></span><br><span class="line">  <span class="keyword">static</span> staticBar () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.name )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get / set 也可以用</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> barName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'bar'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>静态成员同样不可列举</p></blockquote><h3 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h3><p>比起 ECMAScript5，ECMAScript6 的派生方便了很多</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> ( length, width ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getArea () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> ( length ) &#123;</span><br><span class="line">    <span class="keyword">super</span>( length, length );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在派生类的构造函数中，调用 <code>super</code> 是必须的。如果连构造函数都没有，则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 无构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> ( ...args ) &#123;</span><br><span class="line">    <span class="keyword">super</span>( ...args )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>只能在派生类中用 <code>super()</code></li><li>使用 <code>this</code> 前必先调用 <code>super()</code> 来<strong>初始化</strong> <code>this</code></li><li>只有在构造函数返回一个对象的时候才可以不用 <code>super()</code></li></ol></blockquote><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>覆盖、隐藏父类方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> ( length ) &#123;</span><br><span class="line">    <span class="keyword">super</span>( length, length );</span><br><span class="line">  &#125;</span><br><span class="line">  getArea () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仍然可以使用 <code>super</code> 调用父类方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> ( length ) &#123;</span><br><span class="line">        <span class="keyword">super</span>( length, length );</span><br><span class="line">    &#125;</span><br><span class="line">    getArea () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getArea();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类方法没有 <code>[[Construct]]</code> 这个内部方法，所以不能被 <code>new</code>。（<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-13.2.2" target="_blank" rel="noopener">什么是<code>[[Construct]]</code></a>）</p><h3 id="静态成员-1"><a href="#静态成员-1" class="headerlink" title="静态成员"></a>静态成员</h3><p>相当于 ES5 中定义在构造函数上的方法（注意不是定义在构造函数的原型上），派生类显然也能调用</p><h3 id="extends-关键字后面可以使用表达式"><a href="#extends-关键字后面可以使用表达式" class="headerlink" title="extends 关键字后面可以使用表达式"></a>extends 关键字后面可以使用表达式</h3><p>除了 <code>null</code> 和生成器函数外</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span> <span class="keyword">extends</span> <span class="title">base</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用表达式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBase</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span> <span class="keyword">extends</span> <span class="title">getBase</span>() </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 混合模式（多继承？!）</span></span><br><span class="line"><span class="keyword">let</span> AMinin = &#123;</span><br><span class="line">  aF = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> BMinin = &#123;</span><br><span class="line">  bF = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span> (<span class="params"> ...mixins </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> base = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="built_in">Object</span>.assign( base.prototype, ...mixins )</span><br><span class="line">  <span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span> <span class="keyword">extends</span> <span class="title">mixin</span>( <span class="title">AMinin</span>, <span class="title">BMinin</span> ) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span> <span class="keyword">extends</span> <span class="title">String</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="new-target-1"><a href="#new-target-1" class="headerlink" title="new.target"></a>new.target</h3><p>能够得知类的调用状态，应用例如：阻止抽象类被实例化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This class cannot be instantiated directly."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="promises"></a></p><h2 id="Promises↑"><a href="#Promises↑" class="headerlink" title="Promises↑"></a>Promises<a href="#catalogue">↑</a></h2><p>Promise 是老朋友了，所以没有什么好记录的，就记一下语法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span> (<span class="params"> resolve, reject </span>) </span>&#123;</span><br><span class="line">    resolve( <span class="number">42</span> );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.reject( <span class="number">43</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all( [p1, p2, p3] );  <span class="comment">// 等待所有 Promise 返回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p5 = <span class="built_in">Promise</span>.race( [p1, p2, p3] );  <span class="comment">// 最快的一个 Promise 返回就返回</span></span><br><span class="line"></span><br><span class="line">p4.then( <span class="function"><span class="keyword">function</span> (<span class="params"> value </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( value );</span><br><span class="line">&#125;).catch( <span class="function"><span class="keyword">function</span> (<span class="params"> value </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( value );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a name="modules"></a></p><h2 id="模块（Modules）↑"><a href="#模块（Modules）↑" class="headerlink" title="模块（Modules）↑"></a>模块（Modules）<a href="#catalogue">↑</a></h2><blockquote><p>注：本章的代码似乎有一些问题，基本参考 MDN 为准</p></blockquote><ol><li>模块中的代码自动以严格模式运行</li><li>模块中的顶层变量只是模块中顶层，并非全局顶层</li><li>顶层中的 <code>this</code> 的值为 <code>undefined</code></li><li>代码中不允许 HTML 风格的注释</li><li>模块必须有导出的东西</li></ol><h3 id="基本导入导出"><a href="#基本导入导出" class="headerlink" title="基本导入导出"></a>基本导入导出</h3><p>直接使用原书代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> magicNumber = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> multiply;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export as</span></span><br><span class="line"><span class="keyword">export</span> &#123; multiply <span class="keyword">as</span> foo &#125;</span><br></pre></td></tr></table></figure><ol><li>除非使用 <code>default</code> 语法，否则函数和类都不能使用匿名</li><li><code>export</code> 只能用在顶层中</li></ol><p><code>as</code> 和 <code>default</code> 语法的情况，给出一个来自 <a href="http://www.2ality.com/2015/07/es6-module-exports.html" target="_blank" rel="noopener">2ality</a> 的表格</p><div class="table-container"><table><thead><tr><th>Statement</th><th>Local name</th><th>Export name</th></tr></thead><tbody><tr><td>export {v as x};</td><td>‘v’</td><td>‘x’</td></tr><tr><td>export default function f() {}</td><td>‘f’</td><td>‘default’</td></tr><tr><td>export default function () {}</td><td>‘<em>default</em>‘</td><td>‘default’</td></tr><tr><td>export default 123;</td><td>‘<em>default</em>‘</td><td>‘default’</td></tr></tbody></table></div><p>可以看出，所谓的默认导出其实就是用了 <code>default</code> 作为名字罢了。</p><p>还能够将其他模块重新导出</p><div class="table-container"><table><thead><tr><th>Statement</th><th>Module</th><th>Import name</th><th>Export name</th></tr></thead><tbody><tr><td>export {v} from ‘mod’;</td><td>‘mod’</td><td>‘v’</td><td>‘v’</td></tr><tr><td>export {v as x} from ‘mod’;</td><td>‘mod’</td><td>‘v’</td><td>‘x’</td></tr><tr><td>export * from ‘mod’;</td><td>‘mod’</td><td>‘*’</td><td>null</td></tr></tbody></table></div><p>导入有很多方法，基本使用到的其实只有几种，以下来自 MDN：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> name <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; member &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; member <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; member1 , member2 &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; member1 , member2 <span class="keyword">as</span> alias2 , [...] &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> defaultMember, &#123; member [ , [...] ] &#125; <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> defaultMember, * <span class="keyword">as</span> alias <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> defaultMember <span class="keyword">from</span> <span class="string">"module-name"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"module-name"</span>;</span><br></pre></td></tr></table></figure><p>最后那种导入是相当于将代码执行了一次。通常可以用来做 <code>polyfills</code> 和 <code>shims</code>。</p><p><a name="miscellaneous"></a></p><h2 id="杂七杂八↑"><a href="#杂七杂八↑" class="headerlink" title="杂七杂八↑"></a>杂七杂八<a href="#catalogue">↑</a></h2><p><code>Number.isInteger</code>，判断整数</p><p><code>Number.isSafeInteger</code>，判断是否是有效整数</p><p>Math 中加入很多函数，例如双曲正弦、双曲余弦之类的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在线免费阅读：&lt;a href=&quot;https://leanpub.com/understandinges6/read/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leanpub.com/understanding
      
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="技术" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="前端" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/"/>
    
    
      <category term="javascript" scheme="https://blog.e10t.net/tags/javascript/"/>
    
      <category term="ECMAScript6" scheme="https://blog.e10t.net/tags/ECMAScript6/"/>
    
      <category term="note" scheme="https://blog.e10t.net/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>mocha + chai + Travis CI + Codecov 使用流程</title>
    <link href="https://blog.e10t.net/mocha-chai-travis-ci-codecov-workflow/"/>
    <id>https://blog.e10t.net/mocha-chai-travis-ci-codecov-workflow/</id>
    <published>2015-09-24T15:29:00.000Z</published>
    <updated>2015-09-24T15:31:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mocha"><a href="#mocha" class="headerlink" title="mocha"></a><a href="https://mochajs.org/" target="_blank" rel="noopener">mocha</a></h3><p>a feature-rich JavaScript test framework running on Node.js and the browser</p><h3 id="chai"><a href="#chai" class="headerlink" title="chai"></a><a href="http://chaijs.com/" target="_blank" rel="noopener">chai</a></h3><p>a BDD / TDD assertion library for node and the browser that can be delightfully paired with any javascript testing framework</p><h3 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a><a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a></h3><p>Free continuous integration platform for GitHub projects</p><h3 id="Codecov"><a href="#Codecov" class="headerlink" title="Codecov"></a><a href="https://codecov.io/" target="_blank" rel="noopener">Codecov</a></h3><p>Continuous Code Coverage</p><h2 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h2><p>简单来说，就是使用 mocha 作为测试框架，chai 作为断言库，将项目交给 Travis CI 做自动测试，交给 Codecov 做覆盖率测试。</p><p>以我自己的项目 <a href="https://github.com/exoticknight/simpleTemplate.js" target="_blank" rel="noopener">simpleTemplate.js</a> 为例。</p><p>先给项目装上 mocha 和 chai。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mocha chai --save-dev</span><br></pre></td></tr></table></figure><p>在 <code>package.json</code> 文件中添加测试脚本命令行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"mocha"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目根目录新建文件 <code>test.js</code>。</p><p>引入 chai 以及三个要测试的库。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expect = <span class="built_in">require</span>( <span class="string">'chai'</span> ).expect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bare = <span class="built_in">require</span>( <span class="string">'./simpleTemplate.bare.js'</span> ),</span><br><span class="line">    normal = <span class="built_in">require</span>( <span class="string">'./simpleTemplate.normal.js'</span> ),</span><br><span class="line">    advanced = <span class="built_in">require</span>( <span class="string">'./simpleTemplate.advanced.js'</span> );</span><br></pre></td></tr></table></figure><p>定义必需的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testData = &#123;</span><br><span class="line">    <span class="string">'text1'</span>: <span class="string">'mocha tastes good, chai tastes good too.'</span>,</span><br><span class="line">    <span class="string">'html'</span>: <span class="string">'&lt;hr&gt;'</span>,</span><br><span class="line">    <span class="string">'list'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="string">'objectList'</span>: [</span><br><span class="line">        &#123; <span class="string">'name'</span>: <span class="string">'a'</span> &#125;,</span><br><span class="line">        &#123; <span class="string">'name'</span>: <span class="string">'b'</span> &#125;,</span><br><span class="line">        &#123; <span class="string">'name'</span>: <span class="string">'c'</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'obj'</span>: &#123; <span class="string">'name'</span>: <span class="string">'obj'</span> &#125;,</span><br><span class="line">    <span class="string">'boolFalse'</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">'boolTrue'</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mocha 用起来其实也不复杂，常用的就是使用 <code>describe</code> 定义一个项目，使用 <code>it</code> 来执行一项测试。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe( <span class="string">'bare'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    describe( <span class="string">'string template'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        it( <span class="string">'should output correct string'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> template = bare( <span class="string">'&lt;p&gt;&#123;=text1&#125;&lt;/p&gt;'</span> );</span><br><span class="line"></span><br><span class="line">            expect( template.fill( testData ).render() ).to.equal( <span class="string">'&lt;p&gt;mocha tastes good, chai tastes good too.&lt;/p&gt;'</span> );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里就是定义了一个 <code>bare</code> 项，里面再定义一个 <code>string template</code> 项，然后在 <code>it</code> 的回调函数中写断言，第一个参数可以写上断言描述。如果断言失败，测试就会失败。</p><p>OK，执行 <code>npm test</code>，可以看到结果输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bare</span><br><span class="line">  string template</span><br><span class="line">    √ should output correct string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 passing (9ms)</span><br></pre></td></tr></table></figure><p><code>expect(...).to.equal(...)</code> 就是用到了 chai 了。</p><p>剩下的测试编写就不再详述了，基本都一样。</p><h2 id="自动测试"><a href="#自动测试" class="headerlink" title="自动测试"></a>自动测试</h2><p>去 Travis-CI 官网使用 github 帐号登录，开启对应项目的访问权限。</p><p>然后在 <code>package.json</code> 同目录（根目录）下，新建文件 <code>.travis.yml</code>，写入如下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - &quot;0.12&quot;</span><br></pre></td></tr></table></figure><p><code>git push</code> 一次，再访问 Travis-CI，会发现已经给你显示出测试结果了。</p><p>那么好了，测试通过，何不贴个奖章 show off 一下呢？</p><p>在项目旁边有一个黑色加绿色的按钮，点一下，弹框中选择 markdown 格式，将代码贴进 <code>readme</code>，再 <code>git push</code>，去 github 的项目页一看，是不是高大上起来了呢？</p><h2 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h2><p>代码覆盖率其实也没必要到 100%，只要不是太低的值就可以了。</p><p>去 Codecov 官网使用 github 帐号登录，开启对应项目的访问权限。</p><p>然后在 <code>package.json</code> 同目录（根目录）下的 <code>.travis.yml</code> 加入如下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env:</span><br><span class="line">  global:</span><br><span class="line">    - CODECOV_TOKEN: your-uuid</span><br><span class="line">script:</span><br><span class="line">  - istanbul cover node_modules/mocha/bin/_mocha</span><br><span class="line">  - cat ./coverage/coverage.json | node_modules/codecov.io/bin/codecov.io.js</span><br></pre></td></tr></table></figure><p>your-uuid 替换成开启项目时生成的 <code>Repository Upload Token</code>。</p><p>继续 <code>git push</code> 一次，再访问 Codecov 就可以看到项目的代码覆盖率了。</p><p>照样里添加上 badge，点击右边齿轮的 <code>badge</code>，就可以得到 markdown 代码了。</p><h2 id="打完收工"><a href="#打完收工" class="headerlink" title="打完收工"></a>打完收工</h2><p>以后每次 <code>push</code>，都会自动运行测试和代码率覆盖统计，去查看一下就知道代码有没有错误或者改进了。</p><p>参考文章：</p><p><a href="http://callmenick.com/post/basic-front-end-testing-with-mocha-chai" target="_blank" rel="noopener">Basic Front End Testing With Mocha &amp; Chai</a></p><p><a href="https://cnodejs.org/topic/5443b8342be2db9d42e8f685" target="_blank" rel="noopener">折腾 Coffee + mocha + Travis-CI 单元测试与覆盖率报告</a></p><p><a href="https://github.com/codecov/example-node" target="_blank" rel="noopener">Example Node with Codecov</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mocha&quot;&gt;&lt;a href=&quot;#mocha&quot; class=&quot;headerlink&quot; title=&quot;mocha&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://mochajs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mocha&lt;/a&gt;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="技术" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="前端" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/"/>
    
    
      <category term="javascript" scheme="https://blog.e10t.net/tags/javascript/"/>
    
      <category term="mocha" scheme="https://blog.e10t.net/tags/mocha/"/>
    
      <category term="chai" scheme="https://blog.e10t.net/tags/chai/"/>
    
      <category term="测试" scheme="https://blog.e10t.net/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="travisci" scheme="https://blog.e10t.net/tags/travisci/"/>
    
      <category term="codecov" scheme="https://blog.e10t.net/tags/codecov/"/>
    
      <category term="持续交付" scheme="https://blog.e10t.net/tags/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>配合 angular 和 angular-material 来开发基于 electron 的应用 · 3-- 文件组织结构和开发流程</title>
    <link href="https://blog.e10t.net/build-application-with-angular-and-ng-material-based-on-electron-3-file-structure-and-workflow/"/>
    <id>https://blog.e10t.net/build-application-with-angular-and-ng-material-based-on-electron-3-file-structure-and-workflow/</id>
    <published>2015-09-05T09:09:13.000Z</published>
    <updated>2015-09-05T09:10:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件组织结构"><a href="#文件组织结构" class="headerlink" title="文件组织结构"></a>文件组织结构</h2><p>良好的文件组织结构不仅能帮助我们更快地定位文件，更能配合开发工具形成流畅的开发流程，从而提高编程效率。</p><p>以下的目录和文件都放在存放应用的根目录 <code>app</code> 下。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>Electron 应用的配置文件，经常做 node 开发的人应该很熟悉了。稍微说明一下一些字段：</p><p><code>name</code>: 应用的名字，本项目就是 radioit 了</p><p><code>description</code>: 应用的描述</p><p><code>version</code>: 应用的版本号</p><p><code>author</code>: 作者名字</p><p><code>email</code>: 作者的邮箱</p><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><p>Electron 应用的入口点，可以在 package.json 的 <code>main</code> 字段自定义</p><h3 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules/"></a>node_modules/</h3><p>node 库的目录，一般不用手动管理，而是使用 npm 来安装和卸载库。</p><h3 id="lib"><a href="#lib" class="headerlink" title="lib/"></a>lib/</h3><p>存放 node 模块的目录。</p><h3 id="src"><a href="#src" class="headerlink" title="src/"></a>src/</h3><p>存放源代码的目录。</p><h3 id="src-css"><a href="#src-css" class="headerlink" title="src/css/"></a>src/css/</h3><p>存放待编译的 css 代码，比如本项目用的 .styl 文件。</p><h3 id="src-modules"><a href="#src-modules" class="headerlink" title="src/modules/"></a>src/modules/</h3><p>存放浏览器端的 javascript 源代码。</p><p>因为使用 AngularJS，所以此目录的结构就照搬 AngularJS 项目的结构。</p><p>通常来说有两种：按 service / controller / directive 分目录存放，按功能模块存放。</p><p>本项目选择按功能模块存放。</p><h3 id="src-modules-entry-js"><a href="#src-modules-entry-js" class="headerlink" title="src/modules/entry.js"></a>src/modules/entry.js</h3><p>供 browserify 打包的入口点。最终浏览器端的 javascript 代码会打包成一个名为 <code>bundle.js</code> 的文件。</p><h3 id="static-css"><a href="#static-css" class="headerlink" title="static/css/"></a>static/css/</h3><p>存放编译好的 CSS 文件。</p><h3 id="static-font"><a href="#static-font" class="headerlink" title="static/font/"></a>static/font/</h3><p>存放字体文件。因为 Electron 可以访问本地文件，所以自定义字体也基本不需要考虑网络传输问题。</p><h3 id="static-image"><a href="#static-image" class="headerlink" title="static/image/"></a>static/image/</h3><p>存放图片文件。</p><h3 id="static-js"><a href="#static-js" class="headerlink" title="static/js/"></a>static/js/</h3><p>存放客户端的 javascript 库，比如 jQuery，underscore，AngularJS 等。</p><h3 id="static-js-bundle-js"><a href="#static-js-bundle-js" class="headerlink" title="static/js/bundle.js"></a>static/js/bundle.js</h3><p>browserify 编译 javascript 代码后输出的文件。</p><h3 id="static-view"><a href="#static-view" class="headerlink" title="static/view/"></a>static/view/</h3><p>存放 HTML 模板文件或者包含 HTML 代码的文件。</p><h2 id="开发流程-—-node-相关"><a href="#开发流程-—-node-相关" class="headerlink" title="开发流程 — node 相关"></a>开发流程 — node 相关</h2><p>有关 node 的开发，跟普通的项目并没有什么两样，需要什么库就直接使用 npm 安装，然后再代码中使用 <code>require</code> 就可以了。</p><p>然而虽然 Electron 为 webkit 内核提供了 <code>io.js</code> 的运行环境，但是最好还是避免在客户端（浏览器）的 javascript 代码内混杂需要 node 依赖的代码。换句话说，最好将需要 node 依赖的 javascript 代码和平常在网页中使用的 javascript 代码分开。这样做的好处是不会搞混相关的 API 和设计模式，毕竟 node 大部分时候都是用在服务端上的。</p><p>本项目将 node 相关的代码放在 <code>lib/</code> 目录下，负责应用的业务逻辑，其既有可能被主进程所用，也有可能被渲染进程所用。node 相关的代码不需要编译合并。编写时在目录下新建 <code>xxx.js</code> 文件，写好需要 exports 的内容，在其他文件中则使用 <code>require( &#39;./xxx.js&#39; )</code> 就可以了。</p><h2 id="开发流程-—-界面相关"><a href="#开发流程-—-界面相关" class="headerlink" title="开发流程 — 界面相关"></a>开发流程 — 界面相关</h2><p>因为界面的渲染采用 webkit 引擎，所以 javascript 的编写和网页开发没有分别。</p><p>在 <code>package.json</code> 的 <code>scripts</code> 字段中增加一条命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"build:js"</span>: <span class="string">"browserify src/modules/entry.js -o static/js/bundle.js"</span></span><br></pre></td></tr></table></figure><p>然后在编写好 javascript 代码的时候，执行 <code>npm run build:js</code> 进行编译。</p><p>CSS 的编译则是加入如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"build:css"</span>: <span class="string">"stylus -u nib src/css/app.styl -o static/css/app.css"</span></span><br></pre></td></tr></table></figure><p>最后需要运行应用来测试，增加命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"test"</span>: <span class="string">"electron main.js 2&gt;&amp;1 | silence-chromium"</span>,</span><br><span class="line"><span class="string">"start"</span>: <span class="string">"npm run build:js &amp;&amp; npm run build:css &amp;&amp; electron main.js 2&gt;&amp;1 | silence-chromium"</span></span><br></pre></td></tr></table></figure><p>需要测试的时候使用 <code>npm run test</code>，需要运行则使用 <code>npm run start</code> 进行重新编译和运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文件组织结构&quot;&gt;&lt;a href=&quot;#文件组织结构&quot; class=&quot;headerlink&quot; title=&quot;文件组织结构&quot;&gt;&lt;/a&gt;文件组织结构&lt;/h2&gt;&lt;p&gt;良好的文件组织结构不仅能帮助我们更快地定位文件，更能配合开发工具形成流畅的开发流程，从而提高编程效率。&lt;/p
      
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="技术" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="javascript" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/"/>
    
      <category term="electron" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/electron/"/>
    
    
      <category term="javascript" scheme="https://blog.e10t.net/tags/javascript/"/>
    
      <category term="angularjs" scheme="https://blog.e10t.net/tags/angularjs/"/>
    
      <category term="angular-material" scheme="https://blog.e10t.net/tags/angular-material/"/>
    
      <category term="electron" scheme="https://blog.e10t.net/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>记一次奇怪的爬虫经历</title>
    <link href="https://blog.e10t.net/a-weird-experience-while-using-pyspider/"/>
    <id>https://blog.e10t.net/a-weird-experience-while-using-pyspider/</id>
    <published>2015-07-01T15:16:30.000Z</published>
    <updated>2015-07-01T15:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于某些原因，我需要去<del>爬</del>获取一些国家旅游景点的信息。</p><p>找到国家旅游局的网站，然后找到一个 5A 风景区目录。</p><p>网址：<a href="http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=view&amp;resultType=5A" target="_blank" rel="noopener">http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=view&amp;resultType=5A</a></p><p>于是去 pyspider 的 <a href="http://demo.pyspider.org/" target="_blank" rel="noopener">demo</a> 页新建一个项目：<a href="http://demo.pyspider.org/debug/5stat" target="_blank" rel="noopener">5stat</a>，就去爬了。</p><h2 id="分析页面"><a href="#分析页面" class="headerlink" title="分析页面"></a>分析页面</h2><p>网页比较特殊，看起来是用 dotnet 写的，翻页是按钮调用 js 代码实现的。跳转后还是同一个网址。</p><p>这里就要用到 pyspider 支持的页面载入后运行 js 脚本的功能。</p><p>先分析翻页按钮干了什么。</p><p>如下图，调用一个名为 <code>__doPostBack</code> 的函数。</p><p><img src="https://i.imgur.com/dMRNDZz.png" alt="__doPostBack"></p><p>在页面上寻找这个函数，看到函数体如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theForm = <span class="built_in">document</span>.forms[<span class="string">'form1'</span>];</span><br><span class="line"><span class="keyword">if</span> (!theForm) &#123;</span><br><span class="line">    theForm = <span class="built_in">document</span>.form1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__doPostBack</span>(<span class="params">eventTarget, eventArgument</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!theForm.onsubmit || (theForm.onsubmit() != <span class="literal">false</span>)) &#123;</span><br><span class="line">        theForm.__EVENTTARGET.value = eventTarget;</span><br><span class="line">        theForm.__EVENTARGUMENT.value = eventArgument;</span><br><span class="line">        theForm.submit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数将 <code>theForm</code> 里面的 <code>__EVENTTARGET</code> 值设置为 <code>PageNavigator1$LnkBtnNext</code> 之后就提交了。</p><p>找到 <code>theForm</code> 对应的元素，看见有三个隐藏域， <code>__EVENTTARGET</code>、<code>__EVENTARGUMENT</code> 和 <code>__VIEWSTATE</code>。</p><p><img src="https://i.imgur.com/4Bl389k.png" alt="theForm"></p><p>附近还有一个隐藏域 <code>__EVENTVALIDATION</code>。看名字就觉得要提交。</p><p>于是试试只提交这三个值看看会不会报错。</p><p>在 chrome 上安装 postman 这个应用，打开。</p><p><img src="https://i.imgur.com/CwPvFET.png" alt="postman"></p><p>修改方式为 POST，填上地址和三个域的值，send。</p><p><img src="https://i.imgur.com/7G2dgUC.png" alt="postman result"></p><p>OK，返回了正确的页面，也就是可行了。</p><h2 id="爬虫脚本"><a href="#爬虫脚本" class="headerlink" title="爬虫脚本"></a>爬虫脚本</h2><p>嗯 pyspider 的爬虫脚本怎么写就不详述了，不会的看文档。</p><p>着重列出爬虫执行的 js 脚本的功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="string">'y'</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">document</span>.querySelector(<span class="string">'#PageNavigator1_LnkBtnNext'</span>).getAttribute(<span class="string">'disabled'</span>) ) &#123;</span><br><span class="line">        flag = <span class="string">'n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.form1.__VIEWSTATE.value + <span class="string">'~'</span> + <span class="built_in">document</span>.form1.__EVENTVALIDATION.value + <span class="string">'~'</span> + flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来在回到爬虫脚本中的时候就能得到下一页跳转的参数了。</p><h2 id="奇怪的地方来了"><a href="#奇怪的地方来了" class="headerlink" title="奇怪的地方来了"></a>奇怪的地方来了</h2><p>因为 pyspider 的文档说明对于每个项目内的相同网址会忽略，于是按照教学提示给网址加了个 <code>#</code>。很明显这样的网址不会改变请求的参数（使用一些其他技术的情况下除外）。</p><blockquote><p>之后不再使用这个方法，因为 pyspider 判断是否同网址实质上是简单地将网址 md5 一下生成任务 id，以此来判断是否同一个爬虫任务。后来用的方法是直接重写任务 id 的生成。</p></blockquote><p>然而在爬下来的数据中却发现有除了旅游地点外的酒店信息。</p><p>原来同一个页面也有五星级饭店的信息。如下图，注意最后有一个 <code>#</code>。</p><p><img src="https://i.imgur.com/I0saHSE.png" alt="五星级饭店链接"></p><p>点击后跳转到一个网址：<a href="http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=hotel&amp;resultType=%u4E94" target="_blank" rel="noopener">http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=hotel&amp;resultType=%u4E94</a> 的页面。</p><p><img src="https://i.imgur.com/RUe1IIX.png" alt="五星级饭店"></p><p>看起来跟旅游地点差不多，新建一个项目 <a href="http://demo.pyspider.org/debug/5hotel" target="_blank" rel="noopener">5hotel</a>，直接复制粘贴之前的代码，就是改了一下网址。</p><p>期间还将任务 id 的生成重写了一下，这样即使请求同一个网址也没问题了。</p><p>然而运行的结果却失败了。</p><p><img src="https://i.imgur.com/x8w8QsA.png" alt="failed"></p><p>在 content 中很明显看出页面获取不全，然而代码是直接复制的，页面也是相同结构的，为什么会出现这个问题呢？</p><p>然后我就被困扰了两天，接着就没在去管，盘算以后自己实现个爬虫再爬好了。</p><h2 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h2><p>今天我再上去看，爬 5A 风景区的项目一直稳定运行。</p><p>五星级饭店的却还是无法抓取全部页面。</p><p>然后我鬼使神差地给网址加了一个 <code>#</code>。网址从：</p><p>www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=hotel&amp;resultType=%u4E94</p><p>变成</p><p>www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx#?catalogType=hotel&amp;resultType=%u4E94</p><p>然后就能爬了！！！</p><p>shenmegui？？？！！！</p><p><img src="https://i.imgur.com/nRP3znG.png" alt="success"></p><p>我也搞不清楚究竟是 pyspider 的问题还是 phantomjs 的问题还是 dotnet 的问题了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于某些原因，我需要去&lt;del&gt;爬&lt;/del&gt;获取一些国家旅游景点的信息。&lt;/p&gt;
&lt;p&gt;找到国家旅游局的网站，然后找到一个 5A 风景区目
      
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="技术" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="杂谈" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/%E6%9D%82%E8%B0%88/"/>
    
      <category term="黑客" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/%E9%BB%91%E5%AE%A2/"/>
    
      <category term="python" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"/>
    
    
      <category term="python" scheme="https://blog.e10t.net/tags/python/"/>
    
      <category term="script" scheme="https://blog.e10t.net/tags/script/"/>
    
      <category term="spider" scheme="https://blog.e10t.net/tags/spider/"/>
    
      <category term="scraper" scheme="https://blog.e10t.net/tags/scraper/"/>
    
      <category term="pyspider" scheme="https://blog.e10t.net/tags/pyspider/"/>
    
  </entry>
  
  <entry>
    <title>配合 angular 和 angular-material 来开发基于 electron 的应用 · 2--node 库的使用和抓取代码的编写</title>
    <link href="https://blog.e10t.net/build-application-with-angular-and-ng-material-based-on-electron-2-use-node-lib-and-code/"/>
    <id>https://blog.e10t.net/build-application-with-angular-and-ng-material-based-on-electron-2-use-node-lib-and-code/</id>
    <published>2015-06-29T08:11:33.000Z</published>
    <updated>2015-09-05T09:10:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-nodejs-的库"><a href="#使用-nodejs-的库" class="headerlink" title="使用 nodejs 的库"></a>使用 nodejs 的库</h2><p>python 脚本的详细编写，请看之前的博文：<a href="http://blog.e10t.net/radioit-plan-animate-radio-script-radioitscript/">radioit 计划——动画广播辅助脚本 radioitScript</a>。</p><p>需要用 node 实现脚本中的某些逻辑是获取和提取广播的信息，整合成 JSON 格式的数据。</p><p>而用一些库就能轻松做到。</p><h3 id="superagent"><a href="#superagent" class="headerlink" title="superagent"></a>superagent</h3><p><a href="https://github.com/visionmedia/superagent" target="_blank" rel="noopener">superagent</a> 是一个极其简单的 AJAX 库。</p><p>使用方法简单得令人发指。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>( <span class="string">'superagent'</span> );</span><br><span class="line"></span><br><span class="line">request</span><br><span class="line">    .get( <span class="string">'http://xxx.com'</span> )</span><br><span class="line">    .end( <span class="function"><span class="keyword">function</span> (<span class="params"> err, res </span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还用介绍吗？不用了。</p><h3 id="bluebird"><a href="#bluebird" class="headerlink" title="bluebird"></a>bluebird</h3><p><a href="https://github.com/petkaantonov/bluebird/" target="_blank" rel="noopener">bluebird</a> 是一个 Promise 库。</p><p>凡是类似 IO 的操作，必定需要异步。经典的解决方法是回调，然而是时候用 Promise 了！</p><p>bluebird 声称拥有无与伦比的速度。其实更实用的功能是它支持能够将一些本身是不支持 Promise 的库转化为支持 Promise 的库。</p><p>然而，要配合之前的 superagent，则需要另外一个库 <a href="https://github.com/KyleAMathews/superagent-bluebird-promise" target="_blank" rel="noopener">superagent-bluebird-promise</a>。superagent 本身不支持 Promise，从上面的代码来看就是使用回调的方法，这个库就是将 superagent 和 bluebird 融合在一起的“融合卡”。</p><p>使用的时候只需要：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>( <span class="string">'bluebird'</span> );</span><br><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>( <span class="string">'superagent-bluebird-promise'</span> );</span><br><span class="line"></span><br><span class="line">request</span><br><span class="line">    .get( <span class="string">'http://xxxx.com'</span> )</span><br><span class="line">    .then( <span class="function"><span class="keyword">function</span> (<span class="params"> res </span>) </span>&#123;</span><br><span class="line">        <span class="comment">// do something when resolved</span></span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"> err </span>) </span>&#123;</span><br><span class="line">        <span class="comment">// do something when rejected</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>立刻就可以使用上 <code>then</code> 了，方便吧。</p><h3 id="cherrio"><a href="#cherrio" class="headerlink" title="cherrio"></a>cherrio</h3><p><a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="noopener">cheerio</a> 是一个语法类似 jQuery，为服务端提供 jQuery 核心功能的库。这里用到的是它的 CSS 选择器功能。</p><p>代码同样很简单，使用过 jQuery 的人会倍感亲切。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>( <span class="string">'cheerio'</span> ),</span><br><span class="line">    $ = cheerio.load( <span class="string">'&lt;h2 class="title"&gt;Hello world&lt;/h2&gt;'</span> );</span><br><span class="line"></span><br><span class="line">$( <span class="string">'.title'</span> ).text(); <span class="comment">// Hello world</span></span><br></pre></td></tr></table></figure><p>使用 cheerio 有比较推荐的做法就是添加上 <code>decodeEntities</code> 和 <code>lowerCaseAttributeNames</code> 这个两个 options 配置，能避免各种 HTML 文本的奇怪问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ = cheerio.load( HTMLtext, &#123;</span><br><span class="line">                    <span class="string">'decodeEntities'</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="string">'lowerCaseAttributeNames'</span>: <span class="literal">true</span></span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><p>综上，四个库的混合使用例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>( <span class="string">'bluebird'</span> );</span><br><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>( <span class="string">'superagent-bluebird-promise'</span> );</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>( <span class="string">'cheerio'</span> );</span><br><span class="line"></span><br><span class="line">request</span><br><span class="line">    .get( <span class="string">'http://xxxx.com'</span> )</span><br><span class="line">    .then( <span class="function"><span class="keyword">function</span> (<span class="params"> res </span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $, text;</span><br><span class="line">        $ = cheerio.load( res.text, &#123;</span><br><span class="line">                    <span class="string">'decodeEntities'</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="string">'lowerCaseAttributeNames'</span>: <span class="literal">true</span></span><br><span class="line">                &#125;);</span><br><span class="line">        text = $( <span class="string">'p'</span> ).text();</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"> err </span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( err );</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="编写逻辑"><a href="#编写逻辑" class="headerlink" title="编写逻辑"></a>编写逻辑</h2><blockquote><p>npm 安装库的过程略。</p></blockquote><p>因为是信息整合，那么必定需要有一个统一的数据格式。于是先来确定数据格式。</p><p>广播站中所有广播的信息整合数据格式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data will be formated as a json object in following structure:</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     'name': 'String, name of the channel',</span></span><br><span class="line"><span class="comment">//     'url': 'String, url of the channel',</span></span><br><span class="line"><span class="comment">//     'timestamp': 'Number, timestamp of this data',</span></span><br><span class="line"><span class="comment">//     'bangumi': &#123;</span></span><br><span class="line"><span class="comment">//         'mon': [</span></span><br><span class="line"><span class="comment">//             &#123;</span></span><br><span class="line"><span class="comment">//                 'id': 'String, id of the bangumi',</span></span><br><span class="line"><span class="comment">//                 'homepage': 'URL, homepage of the bangumi',</span></span><br><span class="line"><span class="comment">//                 'name': 'String, name of the bangumi',</span></span><br><span class="line"><span class="comment">//                 'image': 'String, image url  of the bangumi, optional',</span></span><br><span class="line"><span class="comment">//                 'status': 'String, new / normal',</span></span><br><span class="line"><span class="comment">//                 ...</span></span><br><span class="line"><span class="comment">//             &#125;,</span></span><br><span class="line"><span class="comment">//             &#123;...&#125;</span></span><br><span class="line"><span class="comment">//         ],</span></span><br><span class="line"><span class="comment">//         'tue': [&#123;...&#125;,&#123;...&#125;],</span></span><br><span class="line"><span class="comment">//         'wed': [&#123;...&#125;,&#123;...&#125;],</span></span><br><span class="line"><span class="comment">//         'thu': [&#123;...&#125;,&#123;...&#125;],</span></span><br><span class="line"><span class="comment">//         'fri': [&#123;...&#125;,&#123;...&#125;],</span></span><br><span class="line"><span class="comment">//         'sat': [&#123;...&#125;,&#123;...&#125;],</span></span><br><span class="line"><span class="comment">//         'sun': [&#123;...&#125;,&#123;...&#125;],</span></span><br><span class="line"><span class="comment">//         'irr': [&#123;...&#125;,&#123;...&#125;],</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>单个广播的信息整合数据格式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data will be formated as a json object in following structure:</span></span><br><span class="line"><span class="comment">// &#123;http://hibiki-radio.jp</span></span><br><span class="line"><span class="comment">//     'timestamp': 'Number',</span></span><br><span class="line"><span class="comment">//     'name': 'String, name of the bangumi',</span></span><br><span class="line"><span class="comment">//     'homepage': 'URL, homepage of the bangumi',</span></span><br><span class="line"><span class="comment">//     'description': 'String, description of the bangumi',</span></span><br><span class="line"><span class="comment">//     'title': 'String, title of the newest episode',</span></span><br><span class="line"><span class="comment">//     'comment': 'String, comment of the newest episode',</span></span><br><span class="line"><span class="comment">//     'schedule': 'String, schedule of the bangumi or the update date of the newest pisode',</span></span><br><span class="line"><span class="comment">//     'personality': 'String, personality of the bangumi',</span></span><br><span class="line"><span class="comment">//     'guest': 'String, guest of the newest episode',</span></span><br><span class="line"><span class="comment">//     'images': 'String Array, array of images' url',</span></span><br><span class="line"><span class="comment">//     'audio': 'String, url of audio'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>有了输出的数据格式，抓取信息的时候就能有的放失。</p><p>以 <a href="http://hibiki-radio.jp" target="_blank" rel="noopener">響 - HiBiKi Radio Station -</a> 为例。因为在之前编写脚本的时候已经得到了页面上信息的位置，所以可以直接应用在代码中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一些固定的信息和变量</span></span><br><span class="line"><span class="keyword">var</span> NAME = <span class="string">'響 - HiBiKi Radio Station -'</span>;</span><br><span class="line"><span class="keyword">var</span> HOST = <span class="string">'http://hibiki-radio.jp'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> URLs = &#123;</span><br><span class="line">    <span class="string">'catalogue'</span>: <span class="string">'http://hibiki-radio.jp/program'</span>,</span><br><span class="line">    <span class="string">'bangumi'</span>: <span class="string">'http://hibiki-radio.jp/description/'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下开始获取广播站的广播。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取信息的对象</span></span><br><span class="line"><span class="keyword">var</span> hibiki = &#123;</span><br><span class="line">    catalogueName: NAME,</span><br><span class="line">    host: HOST,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步取得所有广播的基本信息，返回一个 promise 对象</span></span><br><span class="line">    getCatalogueAsync: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request</span><br><span class="line">            .get( URLs.catalogue )</span><br><span class="line">            .then( <span class="function"><span class="keyword">function</span> (<span class="params"> res </span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> $,</span><br><span class="line">                    days,</span><br><span class="line">                    bangumi,</span><br><span class="line">                    data;</span><br><span class="line"></span><br><span class="line">                days = <span class="string">'mon tue wed thu fri sat sun irr'</span>.split( <span class="string">' '</span> );</span><br><span class="line"></span><br><span class="line">                $ = cheerio.load( res.text, &#123;</span><br><span class="line">                    <span class="string">'decodeEntities'</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="string">'lowerCaseAttributeNames'</span>: <span class="literal">true</span></span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Extract html and structure data</span></span><br><span class="line">                <span class="comment">// 准备数据结构</span></span><br><span class="line">                data = &#123;&#125;;</span><br><span class="line">                data.bangumi = &#123;&#125;;</span><br><span class="line">                days.forEach( <span class="function"><span class="keyword">function</span> (<span class="params"> el </span>) </span>&#123;</span><br><span class="line">                    data.bangumi[el] = [];</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Structure daily bangumis</span></span><br><span class="line">                <span class="comment">// 一个 .hbkProgramTable 包含一天的广播</span></span><br><span class="line">                $( <span class="string">'.hbkProgramTable'</span> ).each( <span class="function"><span class="keyword">function</span> (<span class="params"> i, el </span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> _;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 一个 .hbkProgramTitleNew 或 .hbkProgramTitle 为一个广播</span></span><br><span class="line">                    data.bangumi[days[i]] = $( <span class="keyword">this</span> ).find( <span class="string">'.hbkProgramTitleNew, .hbkProgramTitle'</span> ).map( <span class="function"><span class="keyword">function</span> (<span class="params"> _, el </span>) </span>&#123;</span><br><span class="line">                        _ = $( <span class="keyword">this</span> );</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 一个广播的基本信息</span></span><br><span class="line">                        <span class="keyword">return</span> &#123;</span><br><span class="line">                            <span class="string">'id'</span>: _.parent().attr( <span class="string">'href'</span> ).slice( <span class="number">35</span> ),</span><br><span class="line">                            <span class="string">'homepage'</span>: _.parent().attr( <span class="string">'href'</span> ),</span><br><span class="line">                            <span class="string">'name'</span>: _.text(),</span><br><span class="line">                            <span class="string">'image'</span>: _.prev().children().eq( <span class="number">0</span> ).attr( <span class="string">'src'</span> ),</span><br><span class="line">                            <span class="string">'status'</span>: _.attr( <span class="string">'class'</span> ) === <span class="string">'hbkProgramTitleNew'</span> ? <span class="string">'new'</span> : <span class="string">'normal'</span></span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;).get();</span><br><span class="line"></span><br><span class="line">                    _ = <span class="literal">null</span>;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// add extra data</span></span><br><span class="line">                data.name = NAME;</span><br><span class="line">                data.url = HOST;</span><br><span class="line">                data.timestamp = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">            &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"> err </span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log( <span class="string">'hibiki:get catalogue error:'</span> + err );</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( err );</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下开始获取某个广播的详细信息，函数定义在上面的对象中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">getBangumiAsync: <span class="function"><span class="keyword">function</span> (<span class="params"> id </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> request</span><br><span class="line">        .get( url.resolve( URLs.bangumi, id ) )</span><br><span class="line">        .then( <span class="function"><span class="keyword">function</span> (<span class="params"> res </span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> $,</span><br><span class="line">                data;</span><br><span class="line"></span><br><span class="line">            $ = cheerio.load( res.text, &#123;</span><br><span class="line">                <span class="string">'decodeEntities'</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">'lowerCaseAttributeNames'</span>: <span class="literal">true</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Extract html and structure data</span></span><br><span class="line">            <span class="comment">// 某个广播详细页的信息提取，信息的位置在 python 脚本中已经确定好了</span></span><br><span class="line">            data = &#123;</span><br><span class="line">                <span class="string">'timestamp'</span>: <span class="built_in">Date</span>.now(),</span><br><span class="line">                <span class="string">'name'</span>: $( <span class="string">'title'</span> ).text().slice( <span class="number">27</span>, <span class="number">-5</span> ),</span><br><span class="line">                <span class="string">'homepage'</span>: url.resolve( URLs.bangumi, id ),</span><br><span class="line">                <span class="string">'description'</span>: $( <span class="string">'table.hbkTextTable td:nth-of-type(1) div:nth-of-type(1)'</span> ).eq( <span class="number">0</span> ).text().trim(),</span><br><span class="line">                <span class="string">'title'</span>: $( <span class="string">'table.hbkTextTable td:nth-of-type(1) div:nth-of-type(3) table:nth-of-type(1) div'</span> ).eq( <span class="number">0</span> ).text().trim(),</span><br><span class="line">                <span class="string">'comment'</span>: $( <span class="string">'table.hbkTextTable td:nth-of-type(1) div:nth-of-type(3) table:nth-of-type(2) td'</span> ).eq( <span class="number">0</span> ).text().trim(),</span><br><span class="line">                <span class="string">'schedule'</span>: (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> _, text;</span><br><span class="line">                    _ = $( <span class="string">'table.hbkTextTable &gt; tr &gt; td:nth-of-type(2) &gt; div'</span> );</span><br><span class="line">                    <span class="keyword">if</span> ( !( text = _.eq( <span class="number">-5</span> ).text().trim() ) ) &#123;</span><br><span class="line">                        text = _.eq( <span class="number">-3</span> ).text();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> text;</span><br><span class="line">                &#125;)(),</span><br><span class="line">                <span class="string">'update'</span>: $( <span class="string">'.hbkDescriptonContents'</span> ).eq( <span class="number">-1</span> ).prev().prev().find( <span class="string">'span'</span> ).eq( <span class="number">0</span> ).text(),</span><br><span class="line">                <span class="string">'personality'</span>: $( <span class="string">'table.hbkTextTable td:nth-of-type(1) &gt; table table td:nth-of-type(2n) a'</span> ).map( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> $( <span class="keyword">this</span> ).text();&#125; ).get().join( <span class="string">''</span> ),<span class="string">'guest'</span>:<span class="string">''</span>,</span><br><span class="line">                <span class="string">'images'</span>: $( <span class="string">'table.hbkTextTable td:nth-of-type(1) div:nth-of-type(3) table:nth-of-type(2) td img'</span> ).map( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> $( <span class="keyword">this</span> ).attr( <span class="string">'src'</span> );&#125;).get(),</span><br><span class="line">                <span class="string">'audio'</span>: $( <span class="string">'div.hbkDescriptonContents embed'</span> ).eq( <span class="number">-1</span> ).attr( <span class="string">'src'</span> )</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"> err </span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log( <span class="string">'hibiki:get bangumi error:'</span> + err );</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( err );</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>代码看似很多，其实就是多了信息提取的部分，其他代码完全就是上一节中四个库的混合使用。</p><p>要注意的有一点，就是 promise 链中的 <code>then( fulfilledHandler, rejectedHandler )</code>。其中 <code>fulfilledHandler</code> 在最后需要使用 <code>return data;</code> 将数据传出去，而 <code>rejectedHandler</code> 也需要使用 <code>throw new Error( err );</code> 重新抛出错误，不然 promise 链中下一个函数将不会得到处理好的数据或者异常（因为已经处理掉了）。</p><p>最后别忘了将对象导出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = hibiki;</span><br></pre></td></tr></table></figure><p>同理，另外两个广播站的代码基本都一样，不同的只是信息提取的部分。</p><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>对于取数据的调用者而言，是无需理会数据从哪来的，只需要知道使用什么 API 就够了。</p><p>再者，既然有 “整合” 之名，就要行 “整合” 之实。因此要将这三个或者日后出现的更多个广播站提取代码整合起来，只提供一个调用入口。</p><p>新建目录 <code>provider</code>，将三个广播站的脚本都放进去。</p><p>再新建一个 <code>provider.js</code> 文件，写入以下代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> catalogue = &#123;</span><br><span class="line">    <span class="string">'hibiki'</span>: <span class="built_in">require</span>( <span class="string">'./provider/hibiki.js'</span> ),</span><br><span class="line">    <span class="string">'onsen'</span>: <span class="built_in">require</span>( <span class="string">'./provider/onsen.js'</span> ),</span><br><span class="line">    <span class="string">'animate'</span>: <span class="built_in">require</span>( <span class="string">'./provider/animate.js'</span> )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> provider = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the list of catalogue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;Array&#125;</span> </span>list of catalogue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getCatalogueList: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> arr = [],</span><br><span class="line">            item;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( item <span class="keyword">in</span> catalogue ) &#123;</span><br><span class="line">            arr.push(&#123;</span><br><span class="line">                id: item,</span><br><span class="line">                name: catalogue[item].catalogueName,</span><br><span class="line">                host: catalogue[item].host</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;,</span><br><span class="line">    getCatalogueAsync: <span class="function"><span class="keyword">function</span> (<span class="params"> id </span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( !( c = catalogue[id] ) ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c.getCatalogueAsync();</span><br><span class="line">    &#125;,</span><br><span class="line">    getBangumiAsync: <span class="function"><span class="keyword">function</span> (<span class="params"> catalogueID, bangumiID </span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( !( c = catalogue[catalogueID] ) ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c.getBangumiAsync( bangumiID );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = provider;</span><br></pre></td></tr></table></figure><p>整体思路是提供一个可调用的列表，然后根据参数调用相应脚本的功能，就是一个 <code>dispatcher</code> 的功能。</p><p>如此，就实现了应用的一大部分主要功能了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用-nodejs-的库&quot;&gt;&lt;a href=&quot;#使用-nodejs-的库&quot; class=&quot;headerlink&quot; title=&quot;使用 nodejs 的库&quot;&gt;&lt;/a&gt;使用 nodejs 的库&lt;/h2&gt;&lt;p&gt;python 脚本的详细编写，请看之前的博文：&lt;a href
      
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="技术" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="javascript" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/"/>
    
      <category term="electron" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/electron/"/>
    
    
      <category term="javascript" scheme="https://blog.e10t.net/tags/javascript/"/>
    
      <category term="angularjs" scheme="https://blog.e10t.net/tags/angularjs/"/>
    
      <category term="angular-material" scheme="https://blog.e10t.net/tags/angular-material/"/>
    
      <category term="electron" scheme="https://blog.e10t.net/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>配合 angular 和 angular-material 来开发基于 electron 的应用 · 1-- 分析与配置</title>
    <link href="https://blog.e10t.net/build-application-with-angular-and-ng-material-based-on-electron-1-analyze-and-configuration/"/>
    <id>https://blog.e10t.net/build-application-with-angular-and-ng-material-based-on-electron-1-analyze-and-configuration/</id>
    <published>2015-06-13T11:32:07.000Z</published>
    <updated>2015-09-05T09:11:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/kvb5CTf.png" alt="thumbnail"></p><blockquote><p><a href="https://github.com/radioit/radioit-desktop" target="_blank" rel="noopener">应用 github 地址</a>。github 代码和文章代码并不同步，用作预览和 PR。</p></blockquote><h2 id="目标分析"><a href="#目标分析" class="headerlink" title="目标分析"></a>目标分析</h2><p>一句话概述：开发的应用是一个抓取网页有用信息并重新统一排布的应用，是 <a href="http://blog.e10t.net/radioit-plan-animate-radio-script-radioitscript/">之前文章</a> 提到的 radioit 计划里脚本的 GUI 版本。</p><p>关键词：网页抓取、信息统一、信息排布、脚本的 GUI 版本</p><p>功能：</p><ol><li>浏览某一个广播站的广播</li><li>浏览某一个广播的详细信息</li><li>下载某一个广播最新的相关图片</li><li>下载某一个广播最新的相关音频</li><li>能够通过设置代理来突破某些限制</li><li>能够离线浏览（未定）</li><li>预定周期下载任务（未定）</li><li>整合视频压制工具（未定）</li></ol><p>业务流程：</p><ol><li>请求特定 url 资源</li><li>对取得的 url 资源进行信息提取</li><li>信息整合成统一格式</li><li>显示信息</li><li>某些情况下执行预定命令行（未定）</li></ol><p>技术联想：</p><ol><li>请求特定 url 资源 -&gt; node</li><li>对取得的 url 资源进行信息提取 -&gt; node 的某些库</li><li>信息整合成统一格式 -&gt; javascript, json</li><li>显示信息 -&gt; html、css、angular、angular material</li><li>某些情况下执行预定命令行（未定） -&gt; node</li></ol><h2 id="技术分析"><a href="#技术分析" class="headerlink" title="技术分析"></a>技术分析</h2><p>技术要点：</p><ol><li>node.js(io.js)，负责网络连接，网页内容解析提取，非浏览器环境因此能够进行跨域访问</li><li>angular，MVVM 框架，自动进行数据的渲染</li><li>angular material，angular 推出的 material design UI 框架，适合作为桌面应用使用</li><li>stylus，CSS 预处理器，合理直观的 CSS 编写格式</li></ol><p>脑内讨论</p><ul><li>Q：为什么使用 Electron？</li><li><p>A：Electron 有意思地使用了 <code>main</code> 进程和 <code>render</code> 进程，<code>render</code> 进程产生于 <code>main</code> 进程中，因此可以简单地产生多个 <code>render</code> 进程，也就是多窗口。这是一个优势。</p></li><li><p>Q：不用 angular，用 react 是否可以？</p></li><li><p>A：可以，然而在假定选用了 react 之后，然后脑内模拟了一下编程的过程，react 似乎并不适合 html 代码经常修改的场合。而自己比较在行的是写 html 和 css，在界面设计上必定经常修改。另外在 material design 的 UI 框架上，使用配合 angular 的 angular material 显然更具操作性。当然 react 下也有 material design 的 UI 框架，但在试用之后感觉不太好用。另外就是自己翻译过一篇很长的有关 angular 的<a href="http://blog.e10t.net/translation-building-the-2048-game-in-angularjs/">文章</a>，对 angular 比较熟悉。日后考虑改用 Polymer 重写。</p></li><li><p>Q：material design 是必须使用的吗？</p></li><li><p>A：作为桌面应用，需要有一点时刻记住的是桌面应用跟网页是不一样的。桌面应用需要稳定的窗口，要有标题栏等清晰的组件，也不需要太花哨的特效。material design 或者受 material design 影响的一些简洁 UI 风格已经在某些桌面软件上应用开来。Electron 作为使用网页作为 GUI 表现，使用 material design 是个稳妥之举。</p></li><li><p>Q：为什么不用 SASS / LESS？</p></li><li><p>A：SASS 需要 Ruby，对非 Rubyer 是非常无理的要求，逻辑表现能力强大而无用（非常用）；LESS 语法简单，支持混写，但逻辑表现力太弱。stylus 则是既有强有力的特性，也足够简单。有时，工具够用就行。参考：<a href="http://webdesign.tutsplus.com/articles/why-i-choose-stylus-and-you-should-too--webdesign-18412" target="_blank" rel="noopener">Why I Choose Stylus (And You Should Too)</a></p></li><li><p>Q：node 和页面中的 angular 如何沟通？</p></li><li><p>A：<code>main</code> 进程和 <code>reander</code> 进程有特定的模块进行通信。<code>render</code> 进程能通过页面中的全局变量和 angular 进行通讯。</p></li><li><p>Q：为什么要使用 node 的库来处理网页请求和内容提取？angular 自带有 $http 不是更方便？</p></li><li>A：如此一来，就能各自开发。node 只需要管如何得到数据，angular 只需要管如何显示数据。另外，如果需要更改 GUI，那么只需要去掉 angular，换上其他 UI 框架就可以，数据生成不受任何印象。只是如此开发需要更多的精力。</li></ul><h2 id="开发配置"><a href="#开发配置" class="headerlink" title="开发配置"></a>开发配置</h2><h3 id="NPM-配置"><a href="#NPM-配置" class="headerlink" title="NPM 配置"></a>NPM 配置</h3><p>node.js 的安装是必须的，不多介绍。安装完自带 npm 管理工具。</p><p>用的最多的 node 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm i xxx -g</span><br><span class="line">npm i xxx --save</span><br><span class="line">npm u xxx --save</span><br><span class="line">npm update</span><br></pre></td></tr></table></figure></p><p>第一条是全局安装 node 模块。比如一些常用工具，每一个项目都可以用到的工具等。这些模块可以写在 <code>package.json</code> 中的 <code>devDependencies</code> 字段中。</p><p>第二条是本地安装 node 模块并保存信息到 <code>package.json</code> 中。适合项目特定使用的模块。这些模块可以写在 <code>package.json</code> 中的 <code>dependencies</code> 字段中。</p><p>第三条是卸载本地安装的 node 模块。node 模块太多了，尝试多个选最好的。</p><p>第四条是升级 node 模块。</p><p>以下是 <code>package.json</code> 文件的暂时内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Radioit"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"radioit desktop edition"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"main.js"</span>,</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">"exoticknight"</span>,</span><br><span class="line">  <span class="string">"mail"</span>: <span class="string">"draco.knight0@gmail.com"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"jshint"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"rimraf"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"electron-packager"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"electron-prebuilt"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"silence-chromium"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"mkdirp"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"nib"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"stylus"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"uglifyjs"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"browserify"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"watchify"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"parallelshell"</span>: <span class="string">"latest"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build:css"</span>: <span class="string">"stylus -u nib src/css/app.styl -o static/css/app.css"</span>,</span><br><span class="line">    <span class="string">"watch:css"</span>: <span class="string">"stylus -u nib src/css/app.styl -o static/css/app.css -w"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"electron main.js 2&gt;&amp;1 | silence-chromium"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"npm run build:css &amp;&amp; electron main.js 2&gt;&amp;1 | silence-chromium"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"deepcopy"</span>: <span class="string">"^0.5.0"</span>,</span><br><span class="line">    <span class="string">"extend"</span>: <span class="string">"^2.0.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂时并没有太多的东西，注意要开发基于 Electron 应用，<code>electron-packager</code> 和 <code>electron-prebuilt</code> 必不可少，一个是 Electron 的打包工具，一个是 Electron 运行环境。而 <code>silence-chromium</code> 则是将 chromium 控制台信息输出到系统终端的工具。其他的工具都是博主开发过程中精选过的工具，还请读者自行 Google 之来学习。</p><p>如果你看过本博客之前的一篇文章：<a href="http://blog.e10t.net/write-i18n-js-with-help-of-npm-as-build-tool/">i18n.js 库的编写兼使用 npm 辅助开发</a>，就知道博主是能用 npm 就不用 gulp / grunt 的，因此在 <code>scripts</code> 字段中也写上了运行的脚本。</p><h3 id="angularjs-配置"><a href="#angularjs-配置" class="headerlink" title="angularjs 配置"></a>angularjs 配置</h3><p>angular 的版本比较稳定，因此直接用 <code>bower</code> 来获取，不推荐其他包管理工具。</p><blockquote><p><code>bower</code> 需要先使用 <code>npm install bower -g</code> 来安装，也需要配置了 git 的环境。如果你使用 github for windows，那么请使用 gitshell 来运行。</p></blockquote><p>angular 的安装在下一节中。</p><h3 id="angular-material-配置"><a href="#angular-material-配置" class="headerlink" title="angular material 配置"></a>angular material 配置</h3><p>对于 <code>bower</code> 来说，angular material 跟 angular 是一样的东西，只是后者是前者的依赖。</p><p>运行 <code>bower install angular-material</code>， bower 会自动将依赖的的 <code>angular</code>、<code>angular-aria</code> 和 <code>angular-animate</code> 一并安装上。</p><p>安装完后所有文件会在项目目录下的 <code>bower_components</code> 中找到。</p><h3 id="Electron-配置"><a href="#Electron-配置" class="headerlink" title="Electron 配置"></a>Electron 配置</h3><p>具体参考：<a href="https://github.com/atom/electron/blob/master/docs/tutorial/quick-start.md" target="_blank" rel="noopener">Quick Start</a></p><p>在 <code>package.json</code> 中有一个 <code>main</code> 字段，值是 <code>main.js</code>。这个就指定了 Electron 启动应用的入口。</p><p>准备好文件结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app/</span><br><span class="line">├── package.json</span><br><span class="line">├── main.js</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure><h3 id="初始程序"><a href="#初始程序" class="headerlink" title="初始程序"></a>初始程序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> BrowserWindow = <span class="built_in">require</span>( <span class="string">'browser-window'</span> );  <span class="comment">// Module to create native browser window.</span></span><br><span class="line"><span class="keyword">var</span> ipc = <span class="built_in">require</span>( <span class="string">'ipc'</span> );</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>( <span class="string">'path'</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// global variable</span></span><br><span class="line"><span class="keyword">var</span> APP_NAME = <span class="string">'Radioit'</span>;</span><br><span class="line"><span class="keyword">var</span> INDEX = <span class="string">'file://'</span> + path.join( __dirname, <span class="string">'index.html'</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Report crashes to our server.</span></span><br><span class="line"><span class="built_in">require</span>( <span class="string">'crash-reporter'</span> ).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keep a global reference of the window object, if you don't, the window will</span></span><br><span class="line"><span class="comment">// be closed automatically when the javascript object is GCed.</span></span><br><span class="line"><span class="keyword">var</span> mainWindow = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quit when all windows are closed.</span></span><br><span class="line">app.on( <span class="string">'window-all-closed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( process.platform != <span class="string">'darwin'</span> )</span><br><span class="line">    app.quit();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method will be called when Electron has done everything</span></span><br><span class="line"><span class="comment">// initialization and ready for creating browser windows.</span></span><br><span class="line">app.on( <span class="string">'ready'</span>, appReady );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appReady</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">        <span class="string">'width'</span>: <span class="number">1024</span>,</span><br><span class="line">        <span class="string">'height'</span>: <span class="number">600</span>,</span><br><span class="line">        <span class="string">'resizable'</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">'accept-first-mouse'</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'title'</span>: APP_NAME,</span><br><span class="line">        <span class="string">'show'</span>: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    mainWindow.loadUrl( INDEX );</span><br><span class="line">    mainWindow.openDevTools(); <span class="comment">// remove this</span></span><br><span class="line"></span><br><span class="line">    mainWindow.webContents.on( <span class="string">'did-finish-load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        mainWindow.show();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    mainWindow.on( <span class="string">'closed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        mainWindow = <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码好像很多，其实基本就是照抄 quick start，没有任何压力。</p><p>博主写的 <code>main.js</code> 和 quick start 中的有所不同。在新建 <code>mainWindow</code> 的时候，加入了其他参数 <code>show: false</code> 和 <code>resizable: false</code>，分别是隐藏窗口和窗口不可拉伸。也增加了一个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mainWindow.webContents.on( <span class="string">'did-finish-load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    mainWindow.show();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>作用是网页内容完全载入后才显示窗口，避免一些内容还没载入完就显示。</p><p>最后运行 <code>npm run test</code> 看看结果。</p><blockquote><p>有什么问题请留言。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/kvb5CTf.png&quot; alt=&quot;thumbnail&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/radioit/radioit-desktop&quot; targ
      
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="技术" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="javascript" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/"/>
    
      <category term="electron" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/electron/"/>
    
    
      <category term="javascript" scheme="https://blog.e10t.net/tags/javascript/"/>
    
      <category term="angularjs" scheme="https://blog.e10t.net/tags/angularjs/"/>
    
      <category term="angular-material" scheme="https://blog.e10t.net/tags/angular-material/"/>
    
      <category term="electron" scheme="https://blog.e10t.net/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>配合 angular 和 angular-material 来开发基于 electron 的应用 · 0-- 前言</title>
    <link href="https://blog.e10t.net/build-application-with-angular-and-ng-material-based-on-electron-0-preface/"/>
    <id>https://blog.e10t.net/build-application-with-angular-and-ng-material-based-on-electron-0-preface/</id>
    <published>2015-06-04T15:02:37.000Z</published>
    <updated>2015-10-20T00:28:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h2><p>Electron 是什么？它之前的名字是 Atom Shell，是 Github 开发的结合了 io.js 和 chromium 的跨平台桌面应用框架。Github 自己出的编辑器 Atom 以及微软出的编辑器 VSCode 都是基于这个框架。</p><p>众所周知，Google chrome 就是基于 chromium 而发展出来的一款优秀的浏览器。因其出色的体验和网页解析性能，所有国内出产的 &lt; del &gt; 山寨 &lt;/del &gt; 浏览器 / 双核浏览器，无不选用了 chrome 作为内核。所以在网页解析渲染方面，使用 chromium 是极其正确的选择。</p><p>那跟平常的桌面应用构建，使用 Electron 又有什么优势呢？</p><p>普通的桌面应用构建，比较成熟的语言不外乎 C/C++、Java、C#、Python 等。然而 C/C++ 易学难精，即使其 GUI 框架有 MFC、Qt、KDE 等众，也是极难快速开发；Java 的 GUI 烂得不提也罢；C# 极有可能成为以后霸主，然而还在跨平台表现上有所欠缺；Python 则是个人喜好关系顺带一提，其实很少作为 GUI 主力语言被使用。（当然你可以阅读本人的另一个 <a href="http://blog.e10t.net/python-with-qt-application-development-catalogue/">有关 python 和 Qt 构建桌面应用的系列</a>）</p><p>Electron 则是使用了 Javascript 作为主力语言，并且为其加上了原生支持 html5 和 CSS3 的浏览器。从 GUI 构建来说，使用 html 和 css 的网页构建显然更加简单，成熟的工具和技术数不胜数；而作为桌面应用着重依赖的 IO、进程和网络通信模块等则由支持 ES6 的 io.js 提供，这样前端后端均采用 Javascript 语言，大大降低技术复杂性。</p><h2 id="与-NW-js（旧名-node-webkit）的异同"><a href="#与-NW-js（旧名-node-webkit）的异同" class="headerlink" title="与 NW.js（旧名 node-webkit）的异同"></a>与 NW.js（旧名 node-webkit）的异同</h2><p>如果你有经常关注前端的消息，那么一定听说过一个国人开发的 GUI 框架：node-webkit。然后一看到 Electron，就会皱皱眉头：这不就是 node-webkit 嘛！</p><p>然而，Electron 和 node-webkit 并不一样，其 github 项目上有详细的对比，<a href="https://github.com/atom/electron/blob/master/docs/development/atom-shell-vs-node-webkit.md" target="_blank" rel="noopener">链接</a>。</p><p>就个人理解来说，NW.js 偏向网页主导，是一个加上了 node.js 的浏览器；Electron 则是 javascript 主导，是 io.js 加上了一个 chromium。</p><blockquote><p>准确来说，Electron 只是选择了网页作为 GUI，并非为 GUI 绑定了 javascript。在 Electron 文档的 <a href="https://github.com/atom/electron/blob/master/docs/development/atom-shell-vs-node-webkit.md" target="_blank" rel="noopener">Quick start</a> 中很明确地指出「It doesn’t mean Electron is a JavaScript binding to GUI libraries. Instead, Electron uses web pages as its GUI, so you could also see it as a minimal Chromium browser, controlled by JavaScript.」</p></blockquote><p>在听说了 node-webkit 之后，我曾经上手把玩了一下，当时也是惊讶于其结合了浏览器内核而得到的强大表现力。因为自己在前端方面有一点技术，所以在编写界面的过程中感觉非常舒服。不过我也留意到其在软件方面的能力明显有比较大的欠缺，除了能读写文件外似乎没有什么亮点。（当然不排除在改名为 NW.js 后会加入了更多功能的可能性）</p><p>总之，NW.js 更像是将网页打包成应用，而 Electron 则是实际开发的应用。</p><h2 id="angular-和-angular-material"><a href="#angular-和-angular-material" class="headerlink" title="angular 和 angular material"></a>angular 和 angular material</h2><p>如果要将网页设计应用到软件界面开发上，那么一些 MVC 框架或 UI 框架就比较适合。MVC 框架中比较有名的是 knockout 和 Backbone，而 UI 框架，则是 reactjs、angularjs 和 polymer 最为著名。国产的还有 avalon。</p><p>那么为什么选 angular 呢？因为 angular 的理念比较符合开发网页应用，更重要的是有 angular material 这样一个比较能使用的 UI 主题。相比之下，knockout 和 Backbone 功能太弱，reactjs 则是太激进（一开始我是选 reactjs 的，但是一番尝试之后还是放弃了），polymer 则未作深入了解。</p><p>不过，就像 Electron 只是选用了网页作为呈现 GUI 的方式，那么在编写基于 Electron 的应用的时候，GUI 框架的选择其实并非固定死的，如有必要或者个人喜好，转而使用 polymer 或者 reactjs 也未尝不可。</p><h2 id="本系列的目的"><a href="#本系列的目的" class="headerlink" title="本系列的目的"></a>本系列的目的</h2><p>如果有看过鄙人写的 <a href="http://blog.e10t.net/python-with-qt-application-development-catalogue/">python × Qt 应用开发系列</a>，那么一定知道本人的教程都偏向实践，喜欢实际解释代码和一定程度地搞清楚技术的细枝末节，而非跟着网上一搜一大把的英文教程或者官方文档演示一篇后以近乎翻译一般地写出所谓的 “教程”。官方文档就摆在那，谁不会 RTFM？</p><p>在本系列中，鄙人同样会以记录一个应用的开发流程的形式来呈现成功（或者说，可行）的开发方式。有时会有大量的代码，有时又会有长篇的理论讨论，有时又会有大段的思维解释，希望读者能耐心读下去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Electron&quot;&gt;&lt;a href=&quot;#Electron&quot; class=&quot;headerlink&quot; title=&quot;Electron&quot;&gt;&lt;/a&gt;Electron&lt;/h2&gt;&lt;p&gt;Electron 是什么？它之前的名字是 Atom Shell，是 Github 开发的结合
      
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="技术" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="javascript" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/"/>
    
      <category term="electron" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/electron/"/>
    
    
      <category term="javascript" scheme="https://blog.e10t.net/tags/javascript/"/>
    
      <category term="angularjs" scheme="https://blog.e10t.net/tags/angularjs/"/>
    
      <category term="angular-material" scheme="https://blog.e10t.net/tags/angular-material/"/>
    
      <category term="electron" scheme="https://blog.e10t.net/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>python × Qt 应用开发系列目录（连载中）</title>
    <link href="https://blog.e10t.net/python-with-qt-application-development-catalogue/"/>
    <id>https://blog.e10t.net/python-with-qt-application-development-catalogue/</id>
    <published>2015-06-04T14:54:21.000Z</published>
    <updated>2015-06-04T14:54:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.e10t.net/python-with-qt-application-development-0-prologue/">python × Qt 应用开发 · 0 — 序</a></p><p><a href="http://blog.e10t.net/python-with-qt-application-development-1-basic-view/">python × Qt 应用开发 · 1 — 基本界面</a></p><p><a href="http://blog.e10t.net/python-with-qt-application-development-2-preliminary-design/">python × Qt 应用开发 · 2 — 界面初步设计</a></p><p><a href="http://blog.e10t.net/python-with-qt-application-development-2-5-developing-gui/">python × Qt 应用开发 · 2.5 — 改进软件界面</a></p><p><a href="http://blog.e10t.net/python-with-qt-application-development-3-basic-model-in-mvc/">python × Qt 应用开发 · 3 — MVC 中 model 的基本实现</a></p><p><a href="http://blog.e10t.net/python-with-qt-application-development-4-database-design/">python × Qt 应用开发 · 4 — 数据库设计</a></p><p><a href="http://blog.e10t.net/python-with-qt-application-development-5-database-helper/">python × Qt 应用开发 · 5 — 数据库 helper 类的编写</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://blog.e10t.net/python-with-qt-application-development-0-prologue/&quot;&gt;python × Qt 应用开发 · 0 — 序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blo
      
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="技术" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="python" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"/>
    
      <category term="软件" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="python" scheme="https://blog.e10t.net/tags/python/"/>
    
      <category term="Qt" scheme="https://blog.e10t.net/tags/Qt/"/>
    
      <category term="software" scheme="https://blog.e10t.net/tags/software/"/>
    
  </entry>
  
  <entry>
    <title>i18n.js库的编写兼使用npm辅助开发</title>
    <link href="https://blog.e10t.net/write-i18n-js-with-help-of-npm-as-build-tool/"/>
    <id>https://blog.e10t.net/write-i18n-js-with-help-of-npm-as-build-tool/</id>
    <published>2015-04-23T11:06:26.000Z</published>
    <updated>2015-04-25T06:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>近来由于开发某页面需要支持多语言切换，遂写一个切换页面语言的JS库。</p><h2 id="编写库的既定事项"><a href="#编写库的既定事项" class="headerlink" title="编写库的既定事项"></a>编写库的既定事项</h2><p>写JS库也不是一两次了，当然只是小型或者微型的。不过思想和方法和大型库都是通用的。一般是直接在sublime text里打开一个JS文件，然后写下一个Self-Executing Anonymous Functions（自执行匿名函数？），接着在函数里面创造库的对象，最后将对象挂在<code>window</code>对象下。</p><p>Show you the code的话就是以下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i18n = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">i18n.bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.i18n = i18n;</span><br><span class="line"></span><br><span class="line">&#125;)( <span class="built_in">window</span> );</span><br></pre></td></tr></table></figure><p>学得这样的写法是来源于对jQuery源代码的阅读。</p><p>通过将代码都包在一个匿名函数中，实现了一个闭包。如此一来在闭包内随便折腾，也不会污染到外部全局环境（当然是在编写可靠的代码的情况下）。</p><p>不过，随着AMD和CommonJS标准的流行开来，越来越多JS库都将自己模块化。过程也不复杂，只要遵循一定的规则就可以了。</p><p>而对于编写一个简单的JS库，将github上<a href="https://github.com/umdjs/umd" target="_blank" rel="noopener">UMD</a>项目给出的模板修改一下就OK。</p><p>修改后代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"> root, name, definition </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd ) &#123;</span><br><span class="line">      define( [], definition );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span> &amp;&amp; <span class="built_in">module</span>.exports ) &#123;</span><br><span class="line">      <span class="built_in">module</span>.exports = definition();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      root[name] = definition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)( <span class="keyword">this</span>, <span class="string">'i18n'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i18n = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">i18n.bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return this library</span></span><br><span class="line"><span class="keyword">return</span> i18n;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意最后不再需要手动将库挂载在<code>window</code>对象下，而是只是返回对象。挂载方式已经转交给外部函数判断。</p><h2 id="思考多一点，代码少一点"><a href="#思考多一点，代码少一点" class="headerlink" title="思考多一点，代码少一点"></a>思考多一点，代码少一点</h2><p>很久的以前，我曾经写过一个jQuery插件，功能是为表格添加分页和异步载入。然而在写之前并没有清晰地定下整个插件的功能和限制，导致最后写出来的插件身兼数职，连表格美化与自定义CSS等也做了进去。加进去的功能有可能只是随手实现的，也许并不适合此插件管辖，造成了“做得不好非要做”的尴尬。</p><p>另外，功能的繁琐与代码段的反复抽象提取导致了代码的凌乱不堪，进而导致测试出bug的时候完全搞不清楚问题所在。</p><p>最后代码膨胀到完全不能控制，自己写出来的代码连自己都不敢修改。</p><blockquote><p>在写jQuery插件的时候，十分容易变成了写“使用jQuery的代码集合”，缺少性能和架构的考虑。这跟jQuery本身十分强大和灵活的特性有很大的关系。</p></blockquote><p>写库或插件，目的应该是将通用或者复杂的逻辑实现封装起来，通过提供简洁的API来实现功能的调用。</p><p>先将手从键盘上收回，拿出纸笔，好好列出对JS库的描述。</p><ul><li>Q1：i18n.js要做什么？</li><li>A1：对页面上的文本进行语言切换。</li><li>Q2：如何定位文本？</li><li>A2：为DOM元素增加’data-i18n’属性进行标记。</li><li>Q3：如何找到标注DOM元素？</li><li>A3：从给出的DOM元素作为根进行深度优先/广度优先遍历。</li><li>Q4：译文的来源？</li><li>A4：用户遵循某一标准自定义每一套语言的字典。</li><li>Q5：如何将译文和元素对应？</li><li>A5：对每一条文本，以唯一ID标识。凡是’data-i18n’属性的值为此ID的元素，即使用此ID对应文本。</li></ul><p>思路是不是清晰了很多呢？可以看到核心逻辑就是一个有访问函数的DFS或BFS算法。</p><h2 id="工欲善其事，必先利其器？"><a href="#工欲善其事，必先利其器？" class="headerlink" title="工欲善其事，必先利其器？"></a>工欲善其事，必先利其器？</h2><p>近年的前端大发展，也催生了很多自动化工具。node的流行更是让很多软件管理和后端开发的思想能应用到前端开发上。</p><p>经典的前端开发不外乎就是写HTML、写CSS、写Javascript，然而在前端代码量越来越大的现在，一个自动化的构建工具则能大大提高工作效率。</p><p>如果Google一下前端构建工具，那么基本就是Grunt和Gulp。</p><p>本质上，Grunt和Gulp都是任务运行器，尝试将前端的代码生成甚至发布统合到几个甚至一个命令行中。它们本身作为npm的一个模块，并没有什么作用，真正做事的是以其为平台的大量插件。通过将各种各样的插件整合起来，Grunt和Gulp就能实现自动化的任务执行。</p><p>但是慢着，以前不是很流行什么网页三剑客的吗？甚至用DreamWrear就能做网页啊。任务运行器、插件什么的是个什么鬼？！</p><p>是这样的，现在的前端开发，虽然最终结果还是写HTML、写CSS、写Javascript，但是过程却已经变化多端，内容也逐渐丰富。</p><p>HTML的话：</p><p>切图输出其实也已经算一种自动化。然而现在还能使用jade、HAML或者各种模板引擎生成，也就是有可能不是直接手写HTML代码了。这个就需要依赖编译了。</p><p>CSS的话：</p><p>SASS、LESS和Stylus都已经存在了很久了，源代码产出CSS也是需要编译的。CSS文件也能够进行合并和版本控制，如此一来又需要额外的工具。</p><p>Javascript的话：</p><p>本身就是一个编程语言，有工具能对其语法进行排错，不能不用吧？流行又高效的模块化开发，需要工具合并吧？压缩源代码，又需要操作了吧？注释呢？文档呢？统统需要工具啊。</p><p>总结起来，HTML要编译，CSS要编译、合并、压缩和，Javascript要编译/合并、压缩甚至生成文档。最后发布还要顾及CDN或者缓存或者bug跟踪进行版本管理如果以上每一步都要自己操作，那么即使只是打命令行也是够呛。</p><p>而使用上自动化构建，则在设定好以上多种工具的使用流程之后（几乎）一劳永逸，只需要专心写好流程最开始的源代码就OK，构建工具会完全自动地生成最终结果。能少干活就少干活，那个程序员愿意做重复性工作？</p><p>这也就是为什么自动化构建工具在一日发展千里、需求一日多改的前端如此受欢迎的原因了。</p><h3 id="Grunt-VS-Gulp"><a href="#Grunt-VS-Gulp" class="headerlink" title="Grunt VS Gulp"></a>Grunt VS Gulp</h3><p>是个程序员总会遇到圣战的时候，或是Emacas VS Vim，或是C# VS Java，或是Python VS Ruby，或是AngularJS VS ReactJS，或是IOS VS Android……</p><p><del>当然，PHP是最好的语言所以不用战争。</del></p><p>也有人只是选择困难症后期患者，一旦选项多于一就会头痛欲裂、浑身不自在。</p><p>那么，究竟Grunt or Gulp？</p><p>为此很多人写过分析的文章，有<a href="http://www.w3ctech.com/topic/114" title="谈谈Grunt,NPM,Gulp" target="_blank" rel="noopener">中文的</a>、<a href="http://www.hongkiat.com/blog/gulp-vs-grunt/" title="The Battle Of Build Scripts: Gulp Vs Grunt" target="_blank" rel="noopener">英文的</a>和<a href="http://jaysoo.ca/2014/01/27/gruntjs-vs-gulpjs/" title="Grunt vs Gulp - Beyond the Numbers" target="_blank" rel="noopener">另一篇英文的</a>，总的来说就是，</p><p>Grunt：插件比较多，社区成熟，风格偏配置，插件比较混乱，代码较长，过程有临时目录</p><p>Gulp：插件不够Grunt多，风格偏代码，插件功能单一专注，代码较短，流式工作无需临时目录</p><p>个人选择是Gulp，那个插件数量不够多是个伪缺点，只是不过Grunt多，其实也有上千个，还不够用？！从其他优点来看都是完胜Grunt了。</p><h3 id="逆袭的npm"><a href="#逆袭的npm" class="headerlink" title="逆袭的npm"></a>逆袭的npm</h3><p>那是不是选择Gulp来构建i18n.js呢？</p><p>并不是。</p><p>如果有仔细看给出的分析文章，可以看到还有一个构建工具：npm。</p><p>众所周知npm实际上是nodejs的包管理工具，然而在其配置文件package.json里面却也可以设置一些可运行项，然后通过<code>npm run xxx</code>来运行。从文章来看，也是能够胜任构建的任务。</p><p>那么问题来了，从网上基本千篇一律的教程来看，Grunt和Gulp的使用都是装上了自带npm的node，然后通过npm来安装的。既然npm本身就能作为构建工具，那为啥要用Grunt和Gulp？</p><p>注意到那篇中文的分析文章还提到“npm一般用在个人项目里,对于团队项目则不适用”，然而果真如此吗？</p><p>使用英文搜索一下，不难发现国外也有人提出<a href="http://blog.keithcirkel.co.uk/why-we-should-stop-using-grunt" title="Why we should stop using Grunt &amp; Gulp" target="_blank" rel="noopener">停止使用Grunt和Gulp的主张</a>，在文中列出类似或同类构建工具的问题：</p><ol><li>Bloat</li><li>Relying on plugins</li><li>Separate pain in updating</li><li>False Promises</li><li>Bad behaviours</li></ol><p>接着提出了使用npm的主张，并且<a href="http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/" title="How to Use npm as a Build Tool" target="_blank" rel="noopener">还给出了详细方法</a>，可以看到使用npm更易懂更简洁。</p><p>我使用Grunt和Gulp的经验并不多（实际也不是什么复杂的东西），对于文中提出的第一个问题已经深有感触。明明只是简单的工作，却要写一大堆罗嗦的配置。另外Grunt/Gulp插件使用都是local安装，于是明明只是写几个KB大小的库，却要将项目的文件夹弄成几十MB大。插件作用都很专一，更新频率很低，全局安装就好，每开一个项目就独立往项目塞一样的工具简直是闲得蛋疼，尤其npm下载插件经常由于网络原因而失败。</p><blockquote><p>当然独立安装项目依赖也有其存在的意义。当将项目发布给其他人使用或者开发的时候，独立安装项目依赖可以保证环境是一样的。</p></blockquote><p>所以结论是，<strong>不要为使用Grunt/Gulp而使用Grunt/Gulp，很多情况下并不需要将事情弄复杂。</strong></p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>参考国外配置npm的文章，写好package.json。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"i18n.js"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"concat-cli"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"jade"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"jshint"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"rimraf"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"nodemon"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"parallelshell"</span>: <span class="string">"latest"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"clean:test"</span>: <span class="string">"rimraf test/*"</span>,</span><br><span class="line">    <span class="string">"clean:dist"</span>: <span class="string">"rimraf dist/*"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">"lint"</span>: <span class="string">"jshint src/js/main.js"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">"test:html"</span>: <span class="string">"jade -P src/test.jade --out test"</span>,</span><br><span class="line">    <span class="string">"watch:html"</span>: <span class="string">"jade -w -P src/test.jade --out test"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">"prebuild:js"</span>: <span class="string">"npm run lint"</span>,</span><br><span class="line">    <span class="string">"build:js"</span>: <span class="string">"concat-cli -f src/js/wrap/prefix.js src/js/main.js src/js/wrap/suffix.js -o dist/i18n.js"</span>,</span><br><span class="line">    <span class="string">"postbuild:js"</span>: <span class="string">"uglifyjs dist/i18n.js -o dist/i18n.min.js -m -c"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">"pretest:js"</span>: <span class="string">"npm run lint"</span>,</span><br><span class="line">    <span class="string">"test:js"</span>: <span class="string">"concat-cli -f src/js/wrap/prefix.js src/js/main.js src/js/wrap/suffix.js -o test/i18n.js"</span>,</span><br><span class="line">    <span class="string">"watch:js"</span>: <span class="string">"nodemon --watch src/js --exec \"npm run test:js\""</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">"pretest"</span>: <span class="string">"npm run clean:test"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"npm run test:js &amp;&amp; test:html"</span>,</span><br><span class="line">    <span class="string">"test:watch"</span>: <span class="string">"parallelshell \"npm run watch:js\" \"npm run watch:html\""</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">"prebuild"</span>: <span class="string">"npm run clean:dist"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"npm run build:js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清晰明了。</p><p>测试环境清理：rimraf</p><p>HTML构建：jade</p><p>Javascript排错：jshint</p><p>Javascript合并：concat-cli（多个文件复制合并）</p><p>全部都是一句话配置，直指命令行。多个任务最终又可以汇集在<code>test</code>/<code>test:watch</code>中。</p><blockquote><p>使用concat-cli构建Javascript比较少见，更多的是使用browserify配合require语法。然而i18n.js库实在太小了，真的不需要复杂的模块化管理。</p></blockquote><h2 id="编写i18n-js"><a href="#编写i18n-js" class="headerlink" title="编写i18n.js"></a>编写i18n.js</h2><h3 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h3><p>先将原js文件拆分成三个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prefix.js</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"> root, name, definition </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd ) &#123;</span><br><span class="line">      define( [], definition );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span> &amp;&amp; <span class="built_in">module</span>.exports ) &#123;</span><br><span class="line">      <span class="built_in">module</span>.exports = definition();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      root[name] = definition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)( <span class="keyword">this</span>, <span class="string">'i18n'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// suffix.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return this library</span></span><br><span class="line"><span class="keyword">return</span> i18n;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> i18n = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">i18n.bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来可以专心在’main.js’中写代码了。</p><blockquote><p>在敲入代码之前记得使用<code>npm run watch:js</code>，不然配置毫无意义。</p></blockquote><h3 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save the global object, which is window in browser / global in Node.js.</span></span><br><span class="line"><span class="keyword">var</span> root = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This library and internal object</span></span><br><span class="line"><span class="keyword">var</span> i18n = &#123;&#125;,</span><br><span class="line">    _ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Current version.</span></span><br><span class="line">i18n.version = <span class="string">'0.0.1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Internel store</span></span><br><span class="line"><span class="keyword">var</span> TRANSLATION_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Current language</span></span><br><span class="line"><span class="keyword">var</span> CURRENT_LANGUAGE = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save the previous value of the `i18n` variable, can be restored later</span></span><br><span class="line"><span class="comment">// if 'noConflict' is called.</span></span><br><span class="line"><span class="keyword">var</span> previousi18n = root.i18n;</span><br></pre></td></tr></table></figure><p><code>TRANSLATION_TABLE</code>保存翻译文本，<code>CURRENT_LANGUAGE</code>保存当前使用的语言，<code>_</code>是内部使用的命名空间。另外使用<code>root</code>保存全局对象，<code>previousi18n</code>保存之前已存在的’i18n’对象。</p><h3 id="库函数（API）"><a href="#库函数（API）" class="headerlink" title="库函数（API）"></a>库函数（API）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Restore the previous value of 'i18n' and return our own i18n object.</span></span><br><span class="line">i18n.noConflict = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    root.i18n = previousi18n;</span><br><span class="line">    <span class="keyword">return</span> i18n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>noConflict函数，学jQuery的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load the translation table</span></span><br><span class="line">i18n.load = <span class="function"><span class="keyword">function</span> (<span class="params"> table </span>) </span>&#123;</span><br><span class="line">    TRANSLATION_TABLE = _.deepCopy( TRANSLATION_TABLE, table );</span><br><span class="line">    <span class="keyword">return</span> i18n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>载入翻译文本，使用深复制（应对多层对象）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the current set language</span></span><br><span class="line">i18n.current = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CURRENT_LANGUAGE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回当前使用的语言。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change the language, apply to all cached nodes or document.body</span></span><br><span class="line">i18n.use = <span class="function"><span class="keyword">function</span> (<span class="params"> language </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> langTable = TRANSLATION_TABLE[language],</span><br><span class="line">        nodes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( langTable ) &#123;</span><br><span class="line">        nodes = _.filterNodes( root.document.body );</span><br><span class="line">        _.translate( nodes, langTable );</span><br><span class="line">        CURRENT_LANGUAGE = language;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i18n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>切换语言。流程是匹配出语言配置，再从body开始抓取出需要翻译的DOM元素（_.filterNodes函数），然后翻译（_.translate函数），最后设置当前语言。</p><h3 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h3><p>API函数的内容写得简单，主要是需要基于不少的内部函数。</p><p>首先是深复制。</p><blockquote><p>Javascript中的赋值都是复制，因此对于基本类型（primitive value）：Undefined、Null、Boolean、Number、String来说，直接赋值就是复制。其他的复杂类型，直接赋值同样是复制——然而，复制的是引用，并不是引用的对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// can handle array and nested objects, not perfect</span></span><br><span class="line">_.deepCopy = <span class="function"><span class="keyword">function</span> (<span class="params"> des, src </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> beCopiedIsArray = <span class="literal">false</span>,</span><br><span class="line">        target,</span><br><span class="line">        name,</span><br><span class="line">        clone,</span><br><span class="line">        beCopied;</span><br><span class="line"></span><br><span class="line">    target = des;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( name <span class="keyword">in</span> src ) &#123;</span><br><span class="line">        beCopied = src[name];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( beCopied === src ) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( _.isObject( beCopied ) || ( beCopiedIsArray = _.isArray( beCopied ) ) ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( beCopiedIsArray ) &#123;</span><br><span class="line">                beCopiedIsArray = <span class="literal">false</span>;</span><br><span class="line">                clone = [];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                clone = &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            target[name] = _.deepCopy( clone, beCopied );</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( beCopied !== <span class="literal">undefined</span> ) &#123;</span><br><span class="line">            target[name] = beCopied;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改写自jQuery1.7内部实现的对象深复制函数，只保留了识别数组和对象的功能。因为译文文本就是JSON格式的普通对象（plain object），无需要实现太复杂的复制。核心代码的思想就是检测在当前对象的每一个属性（省略了hasOwnProperty的检测），如果是数组（_.isArray）或者普通对象（_.isObject），则实实在在创建一个数组 / 对象以供复制。</p><p>而数组 / 对象检测则是用以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// figure out array</span></span><br><span class="line">_.isArray = <span class="built_in">Array</span>.isArray || <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// figure out object</span></span><br><span class="line">_.isObject = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">'[object Object]'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而库的核心，一个带访问函数的DFS。DOM操作自带取子元素和兄弟元素，写起来很简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Walk the DOM, call the visit</span></span><br><span class="line">_.walkDOM = <span class="function"><span class="keyword">function</span> (<span class="params"> dom, visit </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nodeType === 1 means element</span></span><br><span class="line">    <span class="comment">// nodeType === 11 means DocumentFragment</span></span><br><span class="line">    <span class="keyword">if</span> ( dom &amp;&amp; <span class="number">1</span> === dom.nodeType || <span class="number">11</span> === dom.nodeType ) &#123;</span><br><span class="line">        visit( dom ); <span class="comment">// 访问当前DOM元素</span></span><br><span class="line"></span><br><span class="line">        node = dom.firstChild; <span class="comment">// 取当前DOM元素的第一个子元素</span></span><br><span class="line">        <span class="keyword">while</span> ( node ) &#123;</span><br><span class="line">            _.walkDOM( node, visit ); <span class="comment">// 对此子元素递归调用</span></span><br><span class="line">            node = node.nextSibling; <span class="comment">// 从此子元素返回，处理下一个兄弟元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过查看元素的属性来筛选出将要翻译的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns array of elements that have attribute 'data-i18n'</span></span><br><span class="line">_.filterNodes = <span class="function"><span class="keyword">function</span> (<span class="params"> root </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nodes = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traverse DOM tree and collect elements with 'data-i18n' attribute</span></span><br><span class="line">    _.walkDOM( root, <span class="function"><span class="keyword">function</span> (<span class="params"> ele </span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( _.hasAttr( ele, <span class="string">'data-i18n'</span> ) ) &#123;</span><br><span class="line">            nodes.push( ele );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上一个函数中用到的’_.hasAttr’，特别实现是因为IE的取属性方式跟其他浏览器不一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return true if ele has attribute otherwise false</span></span><br><span class="line">_.hasAttr = <span class="function"><span class="keyword">function</span> (<span class="params"> ele, attr </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ele.hasAttribute ? ele.hasAttribute( attr ) : ele[attr] !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来是改变元素的文本。代码很简单，做的事情就是遍历DOM元素数组，取属性’data-i18n’的值作为key值，在译文表格中查询value值（_.getTranslatedText），最后改变元素的文本（_.setText）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Translate each node in array with given language table</span></span><br><span class="line">_.translate = <span class="function"><span class="keyword">function</span> (<span class="params"> nodes, table </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> key, text, i, length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>, length = nodes.length; i &lt; length; i++ ) &#123;</span><br><span class="line">        key = nodes[i].getAttribute( <span class="string">'data-i18n'</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( key ) &#123;</span><br><span class="line">            text = _.getTranslation( key, table );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( <span class="keyword">typeof</span> text === <span class="string">'string'</span> ) &#123;</span><br><span class="line">                _.setText( nodes[i], text );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>_.getTranslatedText 支持使用点记法，代码直接用以前写过的。<a href="http://blog.e10t.net/implements-list-and-flag-in-simpletemplatejs/">参考</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get translation via path, support dot</span></span><br><span class="line">_.getTranslatedText = <span class="function"><span class="keyword">function</span> (<span class="params"> path, json </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fieldPath = path.split( <span class="string">'.'</span> ),</span><br><span class="line">        data = json,</span><br><span class="line">        index,</span><br><span class="line">        indexLength;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( index = <span class="number">0</span>, indexLength = fieldPath.length; index &lt; indexLength; index++ ) &#123;</span><br><span class="line">        data = data[fieldPath[index]];</span><br><span class="line">        <span class="keyword">if</span> ( !data ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>_.setText 函数就是用’innerText’或’textContent’来设置元素文本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cross-browser set text</span></span><br><span class="line">_.setText = <span class="function"><span class="keyword">function</span> (<span class="params"> ele, text </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nodeType = ele.nodeType,</span><br><span class="line">        textAttr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( nodeType &amp;&amp; <span class="number">1</span> === nodeType ) &#123;</span><br><span class="line">        textAttr = ( <span class="string">'innerText'</span> <span class="keyword">in</span> ele ) ? <span class="string">'innerText'</span> : <span class="string">'textContent'</span>;</span><br><span class="line">        ele[textAttr] = text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>看起来大概写完了，来写一些测试。</p><blockquote><p>实际上应该先写测试，再写代码。但是一来库很小，二来我不太懂，所以……不过之后写比较大型的库的时候要好好地用mocha等的测试框架。</p></blockquote><p>用jade语法写一个HTML文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">doctype html</span><br><span class="line">html</span><br><span class="line">  head</span><br><span class="line">    meta(charset=&quot;UTF-8&quot;)</span><br><span class="line">    title test</span><br><span class="line">    script(src=&quot;i18n.js&quot;)</span><br><span class="line">  body</span><br><span class="line">    select#language(name=&quot;language&quot;,onchange=&quot;toggle()&quot;)</span><br><span class="line">      option(value=&quot;en&quot;) English</span><br><span class="line">      option(value=&quot;zh&quot;) 中文</span><br><span class="line">      option(value=&quot;jp&quot;) 日本語</span><br><span class="line"></span><br><span class="line">    h1(data-i18n=&quot;TITLE&quot;) Title</span><br><span class="line">    p(data-i18n=&quot;p.text&quot;) This is test text.</span><br><span class="line">    button(data-i18n=&quot;BUTTON_TEXT&quot;) change</span><br><span class="line">    button(data-i18n=&quot;BUTTON_ADD&quot;,onclick=&quot;add()&quot;) add</span><br><span class="line"></span><br><span class="line">  script.</span><br><span class="line">    i18n.load(&#123;</span><br><span class="line">      &apos;en&apos;: &#123;</span><br><span class="line">        &apos;TITLE&apos;: &apos;Title&apos;,</span><br><span class="line">        &apos;BUTTON_TEXT&apos;: &apos;change&apos;,</span><br><span class="line">        &apos;BUTTON_ADD&apos;: &apos;add&apos;,</span><br><span class="line">        &apos;p&apos;: &#123;</span><br><span class="line">          &apos;text&apos;: &apos;This is test text.&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &apos;zh&apos;: &#123;</span><br><span class="line">        &apos;TITLE&apos;: &apos;标题&apos;,</span><br><span class="line">        &apos;BUTTON_TEXT&apos;: &apos;变&apos;,</span><br><span class="line">        &apos;BUTTON_ADD&apos;: &apos;添加&apos;,</span><br><span class="line">        &apos;p&apos;: &#123;</span><br><span class="line">          &apos;text&apos;: &apos;这是测试文本。&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &apos;jp&apos;: &#123;</span><br><span class="line">        &apos;TITLE&apos;: &apos;タイトル&apos;,</span><br><span class="line">        &apos;BUTTON_TEXT&apos;: &apos;変更&apos;,</span><br><span class="line">        &apos;BUTTON_ADD&apos;: &apos;追加する&apos;,</span><br><span class="line">        &apos;p&apos;: &#123;</span><br><span class="line">          &apos;text&apos;: &apos;これはテストテキストです&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    function toggle () &#123;</span><br><span class="line">      var ele = document.getElementById( &apos;language&apos; ),</span><br><span class="line">        value = ele.value;</span><br><span class="line"></span><br><span class="line">      i18n.use( value );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>控制台运行<code>npm run test:html</code>生成HTML文件，用浏览器打开，切换一下语言，没问题。</p><h2 id="继续开发"><a href="#继续开发" class="headerlink" title="继续开发"></a>继续开发</h2><p>应用i18n.js的多语言页面，是有可能动态添加DOM元素的（AJAX拉取数据之类的操作），所以i18n.js库也需要将添加的DOM元素翻译一下。于是再添加一个名为’translate’的API好了。</p><blockquote><p>由于需要同时修改jade文件和js文件，所以使用<code>npm run test:watch</code>，同时监视jade文件和js文件的变化。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Translate nodes</span></span><br><span class="line">i18n.translate = <span class="function"><span class="keyword">function</span> (<span class="params"> eles </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> langTable, nodeList, i, index, nodes;</span><br><span class="line"></span><br><span class="line">    langTable = TRANSLATION_TABLE[CURRENT_LANGUAGE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( langTable ) &#123;</span><br><span class="line">        nodeList = <span class="built_in">Object</span>.prototype.toString.call( eles ) === <span class="string">'[object NodeList]'</span> ||</span><br><span class="line">            <span class="string">'length'</span> <span class="keyword">in</span> eles ?</span><br><span class="line">            eles :</span><br><span class="line">            [eles];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>, index = nodeList.length; i &lt; index; i++ ) &#123;</span><br><span class="line">            nodes = _.filterNodes( nodeList[i] );</span><br><span class="line">            _.translate( nodes, langTable );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>做的事其实和<code>use</code>大同小异，只是目标DOM元素不一样。</p><p>修改一下测试文件，增加一点代码。</p><p>在 body 中添加两个按钮。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">button(data-i18n=&quot;BUTTON_ADD_1&quot;,onclick=&quot;add(1)&quot;) add one</span><br><span class="line">button(data-i18n=&quot;BUTTON_ADD_2&quot;,onclick=&quot;add(2)&quot;) add two</span><br></pre></td></tr></table></figure><p>在数据中增加按钮的文本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'BUTTON_ADD_1'</span>: <span class="string">'add one line'</span>,</span><br><span class="line"><span class="string">'BUTTON_ADD_2'</span>: <span class="string">'add two line'</span>,</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="string">'BUTTON_ADD_1'</span>: <span class="string">'添加一行'</span>,</span><br><span class="line"><span class="string">'BUTTON_ADD_2'</span>: <span class="string">'添加两行'</span>,</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="string">'BUTTON_ADD_1'</span>: <span class="string">'1行を追加する'</span>,</span><br><span class="line"><span class="string">'BUTTON_ADD_2'</span>: <span class="string">'2行を追加する'</span>,</span><br></pre></td></tr></table></figure><p>在脚本中增加一个函数，用作模拟动态添加DOM元素。可以添加一个或多个DOM元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params"> num </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementsByTagName( <span class="string">'p'</span> )</span><br><span class="line">    , newP = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> )</span><br><span class="line">    , i</span><br><span class="line">    , node</span><br><span class="line">    , fragment;</span><br><span class="line"></span><br><span class="line">  fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">  newP.innerHTML = <span class="string">'&lt;p data-i18n="p.text"&gt;This is test text.&lt;/p&gt;'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; num; i++ ) &#123;</span><br><span class="line">    node = newP.firstChild.cloneNode( <span class="literal">true</span> );</span><br><span class="line">    fragment.appendChild( node );</span><br><span class="line">  &#125;</span><br><span class="line">  i18n.translate( fragment );</span><br><span class="line"></span><br><span class="line">  p = p[p.length<span class="number">-1</span>];</span><br><span class="line">  p.parentNode.insertBefore( fragment, p.nextSibling );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再使用浏览器测试一下，同样没问题了。</p><h3 id="再拆分一下"><a href="#再拆分一下" class="headerlink" title="再拆分一下"></a>再拆分一下</h3><p>现在<code>main.js</code>文件看起来比较复杂，可以再分别拆分成<code>var.js</code>，存放顶层变量；<code>util.js</code>，包含内部的函数；<code>api.js</code>，包含库的API。</p><p>稍微修改一下<code>package.json</code>文件，相关位置改成拆分后的文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="string">"lint"</span>: <span class="string">"jshint src/js/var.js &amp;&amp; jshint src/js/util.js &amp;&amp; jshint src/js/api.js"</span>,</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">    <span class="string">"build:js"</span>: <span class="string">"concat-cli -f src/js/wrap/prefix.js src/js/var.js src/js/util.js src/js/api.js src/js/wrap/suffix.js -o dist/i18n.js"</span>,</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">    <span class="string">"test:js"</span>: <span class="string">"concat-cli -f src/js/wrap/prefix.js src/js/var.js src/js/util.js src/js/api.js src/js/wrap/suffix.js -o test/i18n.js"</span>,</span><br></pre></td></tr></table></figure><p>最后运行<code>npm run build</code>将js库编译出来并压缩。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近来由于开发某页面需要支持多语言切换，遂写一个切换页面语言的JS库。&lt;/p&gt;
&lt;h2 id=&quot;编写库的既定事项&quot;&gt;&lt;a href=&quot;#编写库的既定事项&quot; class=&quot;headerlink&quot; title=&quot;编写库的既定事项&quot;&gt;&lt;/a&gt;编写库的既定事项&lt;/h2&gt;&lt;p&gt;写JS库
      
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="技术" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="前端" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/javascript/"/>
    
    
      <category term="javascript" scheme="https://blog.e10t.net/tags/javascript/"/>
    
      <category term="i18n" scheme="https://blog.e10t.net/tags/i18n/"/>
    
  </entry>
  
  <entry>
    <title>radioit 计划——动画广播辅助脚本 radioitScript</title>
    <link href="https://blog.e10t.net/radioit-plan-animate-radio-script-radioitscript/"/>
    <id>https://blog.e10t.net/radioit-plan-animate-radio-script-radioitscript/</id>
    <published>2015-03-23T12:25:53.000Z</published>
    <updated>2015-03-23T12:27:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="http://blog.e10t.net/how-to-save-internet-radio/">这篇文章</a> 的实践基础和 <a href="http://blog.e10t.net/append-a-python-script-for-last-post-about-saving-internet-radio/">这篇文章</a> 的代码基础上，我重新将代码整理一下，并添加了一些功能，将原来三个脚本的共同点提炼，写成一个网络广播查看和获取的框架。继而在这个框架上，写出对应三个广播站的脚本的 ver 2.0。</p><p>原来的脚本的功能就不再详述了，来说说一下新版脚本三大功能，分别是：探索广播、下载广播和查看广播。</p><p>探索广播是指能够列出某一个广播站上所有的 / 当天的 / 星期 x 的 / 最新的广播，旨在能够帮助使用者发现自己喜欢的广播和新推出的广播。</p><p>下载广播是指能提取出广播音频 / 图片的地址，供第三方播放器播放或保存。</p><p>查看广播是指能够列出某广播的主要信息：包括更新日期、最新一期的内容、主持人等。</p><p>基本可以说，有了新版的脚本，基本就不需要用浏览器浏览广播站的网页了。并且，因为脚本只是需要抓单个页面和将网页内容整理好再输出，所以对比起网页，能更快更高效地呈现有用的信息。</p><h2 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h2><p>对比旧版，新版脚本的一大改进是引入了子命令。最直观的反映就是，调用方式的不同。</p><p>旧版<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python www.py -x -y zzz</span><br></pre></td></tr></table></figure></p><p>新版<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python www.py xxx -y zzz</span><br></pre></td></tr></table></figure></p><p>就是类似 <code>git</code> 命令行的那样，<code>argparse</code> 库非常给力地支持这种方法。</p><p>重点是使用 <code>add_subparsers</code> 函数和 <code>add_parser</code> 函数，详细使用看 <a href="https://docs.python.org/2/library/argparse.html" target="_blank" rel="noopener">文档</a> 和<a href="https://github.com/exoticknight/radioitScript/blob/master/_radioit_script_template.py" target="_blank" rel="noopener">github 上的代码</a>。</p><p>多亏了能够这样嵌套命令，即使再多的功能也能变得清晰分明。</p><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p>ver 2.0 的起点是一个脚本框架，承载参数的解释和自定义函数调用的重要功能。</p><p>脚本的一次执行基本流程是：</p><p>入口 → 解析参数 → 调用自定义函数 → 执行自定义函数</p><p>前三个都能够定下来，不同的广播站只需要各自填充自定义函数就可以了。</p><p>最简框架代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""自定义函数"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""子命令和参数跳转"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(option)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> option.sp_name == <span class="string">"www"</span>:</span><br><span class="line">        <span class="keyword">if</span> option.xxx:</span><br><span class="line">            foo()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""入口"""</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(version=<span class="string">"2.0"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 子命令</span></span><br><span class="line">    sp = parser.add_subparsers(title=<span class="string">"commands"</span>, description=<span class="string">"support commands"</span>, help=<span class="string">"what they will do"</span>, dest=<span class="string">"sp_name"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加子命令</span></span><br><span class="line">    sp_www = sp.add_parser(<span class="string">"www"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加子命令参数</span></span><br><span class="line">    sp_www.add_argument(<span class="string">"-x"</span>, <span class="string">"--xxx"</span>, action=<span class="string">"store_true"</span>, dest=<span class="string">"xxx"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        args = parser.parse_args(sys.argv[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">except</span> argparse.ArgumentError, e:</span><br><span class="line">        print(<span class="string">"bad options: &#123;0&#125;"</span>.format(e))</span><br><span class="line">    <span class="keyword">except</span> argparse.ArgumentTypeError, e:</span><br><span class="line">        print(<span class="string">"bad option value: &#123;0&#125;"</span>.format(e))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        process(args)</span><br></pre></td></tr></table></figure><h2 id="自定义函数骨架"><a href="#自定义函数骨架" class="headerlink" title="自定义函数骨架"></a>自定义函数骨架</h2><p>框架还基于库 <code>urllib</code>、<code>urllib2</code>、<code>argparse</code> 和 <code>bs4</code>，制定了自定义函数的骨架。</p><p>脚本做的事情，无非就是获取网页资源，接着在 html 结构中筛选有用信息，然后格式化成文本输出。因此，自定义函数也可以制定出骨架，不同的广播站就只需要指定筛选的规则就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取网页</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    soup = BeautifulSoup(urllib2.urlopen(<span class="string">u"http://url"</span>, timeout=<span class="number">60</span>)) <span class="comment"># 1</span></span><br><span class="line"><span class="keyword">except</span> Exception, e:</span><br><span class="line">    handle_error(e, <span class="string">"Network Error."</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选</span></span><br><span class="line">content = soup.select(<span class="string">"html"</span>) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组织内容</span></span><br><span class="line">table = [(<span class="string">u"ID"</span>, <span class="string">u"Name"</span>)] + [a <span class="keyword">for</span> a <span class="keyword">in</span> content] <span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 格式化文本</span></span><br><span class="line">text = prettify_table(table)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">print(text.encode(<span class="string">"gb18030"</span>))</span><br></pre></td></tr></table></figure><p>虽说骨架是定下来了，但在特殊函数比如下载函数就需要另外编写。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然新版脚本框架是为了 radioit 计划而写的代码，但是其中 <code>argparse</code> 模块的使用的代码也是能被借鉴在其他需要带参数运行的 python 脚本中。</p><p>新版对比旧版，增加了功能，但是也增加了使用的复杂度和代码的长度。旧版还是可以保留下来，供日常快速使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 &lt;a href=&quot;http://blog.e10t.net/how-to-save-internet-radio/&quot;&gt;这篇文章&lt;/a&gt; 的实践基础和 &lt;a href=&quot;http://blog.e10t.net/append-a-python-script-for-las
      
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="技术" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="黑客" scheme="https://blog.e10t.net/categories/%E6%8A%80%E6%9C%AF/%E9%BB%91%E5%AE%A2/"/>
    
      <category term="python" scheme="https://blog.e10t.net/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"/>
    
    
      <category term="python" scheme="https://blog.e10t.net/tags/python/"/>
    
      <category term="radioit" scheme="https://blog.e10t.net/tags/radioit/"/>
    
  </entry>
  
</feed>
